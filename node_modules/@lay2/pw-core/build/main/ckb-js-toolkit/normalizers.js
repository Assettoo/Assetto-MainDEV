"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizers = exports.NormalizeWitnessArgs = exports.NormalizeCellbaseWitness = exports.NormalizeBlock = exports.NormalizeUncleBlock = exports.NormalizeHeader = exports.NormalizeRawHeader = exports.NormalizeTransaction = exports.NormalizeRawTransaction = exports.NormalizeCellDep = exports.NormalizeCellOutput = exports.NormalizeCellInput = exports.NormalizeOutPoint = exports.NormalizeScript = void 0;
// This package provides normalizer functions. Even though CKB uses molecule
// as the serialization layer. There is still CKB specific knowledge that does
// not belong in molecule. For example, all numbers in CKB protocols are
// serialized using little endian format. This package tries to encode such
// knowledge. The goal here, is that you are free to use whatever types that
// makes most sense to represent the values. As long as you pass your object
// through the normalizers here, molecule should be able to serialize the values
// into correct formats required by CKB.
//
// Note this is only used when you need to deal with CKB structures in molecule
// format. If you are using RPCs or GraphQL to interact with CKB, chances are you
// will not need this package.
const jsbi_1 = __importDefault(require("jsbi"));
const reader_1 = require("./reader");
const rpc_1 = require("./rpc");
function normalizeHexNumber(length) {
    return function (debugPath, value) {
        if (!(value instanceof ArrayBuffer)) {
            let intValue = rpc_1.BigIntToHexString(jsbi_1.default.BigInt(value)).substr(2);
            if (intValue.length % 2 !== 0) {
                intValue = '0' + intValue;
            }
            if (intValue.length / 2 > length) {
                throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);
            }
            const view = new DataView(new ArrayBuffer(length));
            for (let i = 0; i < intValue.length / 2; i++) {
                const start = intValue.length - (i + 1) * 2;
                view.setUint8(i, parseInt(intValue.substr(start, 2), 16));
            }
            value = view.buffer;
        }
        if (value.byteLength < length) {
            const array = new Uint8Array(length);
            array.set(new Uint8Array(value), 0);
            value = array.buffer;
        }
        return value;
    };
}
function normalizeRawData(length) {
    return function (debugPath, value) {
        value = new reader_1.Reader(value).toArrayBuffer();
        if (length > 0 && value.byteLength !== length) {
            throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);
        }
        return value;
    };
}
function normalizeObject(debugPath, object, keys) {
    const result = {};
    for (const [key, f] of Object.entries(keys)) {
        const value = object[key];
        if (!value) {
            throw new Error(`${debugPath} is missing ${key}!`);
        }
        result[key] = f(`${debugPath}.${key}`, value);
    }
    return result;
}
function NormalizeScript(script, { debugPath = 'script' } = {}) {
    return normalizeObject(debugPath, script, {
        code_hash: normalizeRawData(32),
        hash_type: function (debugPath, value) {
            switch (value) {
                case 'data':
                    return 0;
                case 'type':
                    return 1;
                case 0:
                    return value;
                case 1:
                    return value;
                default:
                    throw new Error(`${debugPath}.hash_type has invalid value: ${value}`);
            }
        },
        args: normalizeRawData(-1),
    });
}
exports.NormalizeScript = NormalizeScript;
function NormalizeOutPoint(outPoint, { debugPath = 'out_point' } = {}) {
    return normalizeObject(debugPath, outPoint, {
        tx_hash: normalizeRawData(32),
        index: normalizeHexNumber(4),
    });
}
exports.NormalizeOutPoint = NormalizeOutPoint;
function toNormalize(normalize) {
    return function (debugPath, value) {
        return normalize(value, {
            debugPath,
        });
    };
}
function NormalizeCellInput(cellInput, { debugPath = 'cell_input' } = {}) {
    return normalizeObject(debugPath, cellInput, {
        since: normalizeHexNumber(8),
        previous_output: toNormalize(NormalizeOutPoint),
    });
}
exports.NormalizeCellInput = NormalizeCellInput;
function NormalizeCellOutput(cellOutput, { debugPath = 'cell_output' } = {}) {
    const result = normalizeObject(debugPath, cellOutput, {
        capacity: normalizeHexNumber(8),
        lock: toNormalize(NormalizeScript),
    });
    if (cellOutput.type) {
        result.type_ = NormalizeScript(cellOutput.type, {
            debugPath: `${debugPath}.type`,
        });
    }
    return result;
}
exports.NormalizeCellOutput = NormalizeCellOutput;
function NormalizeCellDep(cellDep, { debugPath = 'cell_dep' } = {}) {
    return normalizeObject(debugPath, cellDep, {
        out_point: toNormalize(NormalizeOutPoint),
        dep_type: function (debugPath, value) {
            switch (value) {
                case 'code':
                    return 0;
                case 'dep_group':
                    return 1;
                case 0:
                    return value;
                case 1:
                    return value;
                default:
                    throw new Error(`${debugPath}.dep_type has invalid value: ${value}`);
            }
        },
    });
}
exports.NormalizeCellDep = NormalizeCellDep;
function toNormalizeArray(normalizeFunction) {
    return function (debugPath, array) {
        return array.map((item, i) => {
            return normalizeFunction(`${debugPath}[${i}]`, item);
        });
    };
}
function NormalizeRawTransaction(rawTransaction, { debugPath = 'raw_transaction' } = {}) {
    return normalizeObject(debugPath, rawTransaction, {
        version: normalizeHexNumber(4),
        cell_deps: toNormalizeArray(toNormalize(NormalizeCellDep)),
        header_deps: toNormalizeArray(normalizeRawData(32)),
        inputs: toNormalizeArray(toNormalize(NormalizeCellInput)),
        outputs: toNormalizeArray(toNormalize(NormalizeCellOutput)),
        outputs_data: toNormalizeArray(normalizeRawData(-1)),
    });
}
exports.NormalizeRawTransaction = NormalizeRawTransaction;
function NormalizeTransaction(transaction, { debugPath = 'transaction' } = {}) {
    const rawTransaction = NormalizeRawTransaction(transaction, {
        debugPath: `(raw)${debugPath}`,
    });
    const result = normalizeObject(debugPath, transaction, {
        witnesses: toNormalizeArray(normalizeRawData(-1)),
    });
    result.raw = rawTransaction;
    return result;
}
exports.NormalizeTransaction = NormalizeTransaction;
function NormalizeRawHeader(rawHeader, { debugPath = 'raw_header' } = {}) {
    return normalizeObject(debugPath, rawHeader, {
        version: normalizeHexNumber(4),
        compact_target: normalizeHexNumber(4),
        timestamp: normalizeHexNumber(8),
        number: normalizeHexNumber(8),
        epoch: normalizeHexNumber(8),
        parent_hash: normalizeRawData(32),
        transactions_root: normalizeRawData(32),
        proposals_hash: normalizeRawData(32),
        uncles_hash: normalizeRawData(32),
        dao: normalizeRawData(32),
    });
}
exports.NormalizeRawHeader = NormalizeRawHeader;
function NormalizeHeader(header, { debugPath = 'header' } = {}) {
    const rawHeader = NormalizeRawHeader(header, {
        debugPath: `(raw)${debugPath}`,
    });
    const result = normalizeObject(debugPath, header, {
        nonce: normalizeHexNumber(16),
    });
    result.raw = rawHeader;
    return result;
}
exports.NormalizeHeader = NormalizeHeader;
function NormalizeUncleBlock(uncleBlock, { debugPath = 'uncle_block' } = {}) {
    return normalizeObject(debugPath, uncleBlock, {
        header: toNormalize(NormalizeHeader),
        proposals: toNormalizeArray(normalizeRawData(10)),
    });
}
exports.NormalizeUncleBlock = NormalizeUncleBlock;
function NormalizeBlock(block, { debugPath = 'block' } = {}) {
    return normalizeObject(debugPath, block, {
        header: toNormalize(NormalizeHeader),
        uncles: toNormalizeArray(toNormalize(NormalizeUncleBlock)),
        transactions: toNormalizeArray(toNormalize(NormalizeTransaction)),
        proposals: toNormalizeArray(normalizeRawData(10)),
    });
}
exports.NormalizeBlock = NormalizeBlock;
function NormalizeCellbaseWitness(cellbaseWitness, { debugPath = 'cellbase_witness' } = {}) {
    return normalizeObject(debugPath, cellbaseWitness, {
        lock: toNormalize(NormalizeScript),
        message: normalizeRawData(-1),
    });
}
exports.NormalizeCellbaseWitness = NormalizeCellbaseWitness;
function NormalizeWitnessArgs(witnessArgs, { debugPath = 'witness_args' } = {}) {
    const result = {};
    if (witnessArgs.lock) {
        result.lock = normalizeRawData(-1)(`${debugPath}.lock`, witnessArgs.lock);
    }
    if (witnessArgs.input_type) {
        result.input_type = normalizeRawData(-1)(`${debugPath}.input_type`, witnessArgs.input_type);
    }
    if (witnessArgs.output_type) {
        result.output_type = normalizeRawData(-1)(`${debugPath}.output_type`, witnessArgs.output_type);
    }
    return result;
}
exports.NormalizeWitnessArgs = NormalizeWitnessArgs;
exports.normalizers = {
    NormalizeScript,
    NormalizeOutPoint,
    NormalizeCellInput,
    NormalizeCellOutput,
    NormalizeCellDep,
    NormalizeRawTransaction,
    NormalizeTransaction,
    NormalizeRawHeader,
    NormalizeHeader,
    NormalizeUncleBlock,
    NormalizeBlock,
    NormalizeCellbaseWitness,
    NormalizeWitnessArgs,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9ybWFsaXplcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2tiLWpzLXRvb2xraXQvbm9ybWFsaXplcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNEVBQTRFO0FBQzVFLDhFQUE4RTtBQUM5RSx3RUFBd0U7QUFDeEUsMkVBQTJFO0FBQzNFLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUsZ0ZBQWdGO0FBQ2hGLHdDQUF3QztBQUN4QyxFQUFFO0FBQ0YsK0VBQStFO0FBQy9FLGlGQUFpRjtBQUNqRiw4QkFBOEI7QUFDOUIsZ0RBQXdCO0FBQ3hCLHFDQUFrQztBQUNsQywrQkFBMEM7QUFFMUMsU0FBUyxrQkFBa0IsQ0FBQyxNQUFNO0lBQ2hDLE9BQU8sVUFBVSxTQUFTLEVBQUUsS0FBSztRQUMvQixJQUFJLENBQUMsQ0FBQyxLQUFLLFlBQVksV0FBVyxDQUFDLEVBQUU7WUFDbkMsSUFBSSxRQUFRLEdBQUcsdUJBQWlCLENBQUMsY0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDN0IsUUFBUSxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUM7YUFDM0I7WUFDRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLE1BQU0sRUFBRTtnQkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FDYixHQUFHLFNBQVMsT0FDVixRQUFRLENBQUMsTUFBTSxHQUFHLENBQ3BCLG1DQUFtQyxNQUFNLEdBQUcsQ0FDN0MsQ0FBQzthQUNIO1lBQ0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNuRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxD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