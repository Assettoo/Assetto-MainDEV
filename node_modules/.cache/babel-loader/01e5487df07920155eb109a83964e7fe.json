{"ast":null,"code":"import { retrieve } from \"../utils/crypt\";\n\nconst getData = async (ipfsHash, certkey, contract) => {\n  let ipfsData, certData;\n\n  if (!!ipfsHash & !!certkey) {\n    await contract.methods.verify(ipfsHash).call().then(res => certData = res).catch(error => console.log(error));\n    ipfsData = JSON.parse(await retrieve(ipfsHash, certkey));\n  }\n\n  return { ...certData,\n    ...ipfsData\n  };\n};\n\nconst fetchCertData = (ipfsHash, certkey, contract) => {\n  return wrapPromise(getData(ipfsHash, certkey, contract));\n};\n\nfunction wrapPromise(promise) {\n  let status = \"pending\";\n  let result;\n  let suspender = promise.then(r => {\n    status = \"success\";\n    result = r;\n  }, e => {\n    status = \"error\";\n    result = e;\n  });\n  return {\n    read() {\n      if (status === \"pending\") {\n        throw suspender;\n      } else if (status === \"error\") {\n        throw result;\n      } else if (status === \"success\") {\n        return result;\n      }\n    }\n\n  };\n}\n\nexport default fetchCertData;","map":{"version":3,"sources":["/Users/pranjilpathak/Downloads/certifier.-main/src/utils/fetchCertData.js"],"names":["retrieve","getData","ipfsHash","certkey","contract","ipfsData","certData","methods","verify","call","then","res","catch","error","console","log","JSON","parse","fetchCertData","wrapPromise","promise","status","result","suspender","r","e","read"],"mappings":"AAAA,SAASA,QAAT,QAAyB,gBAAzB;;AAEA,MAAMC,OAAO,GAAG,OAAOC,QAAP,EAAiBC,OAAjB,EAA0BC,QAA1B,KAAuC;AACtD,MAAIC,QAAJ,EAAcC,QAAd;;AACA,MAAI,CAAC,CAACJ,QAAF,GAAa,CAAC,CAACC,OAAnB,EAA4B;AAC3B,UAAMC,QAAQ,CAACG,OAAT,CACJC,MADI,CACGN,QADH,EAEJO,IAFI,GAGJC,IAHI,CAGEC,GAAD,IAAUL,QAAQ,GAAGK,GAHtB,EAIJC,KAJI,CAIGC,KAAD,IAAWC,OAAO,CAACC,GAAR,CAAYF,KAAZ,CAJb,CAAN;AAKAR,IAAAA,QAAQ,GAAGW,IAAI,CAACC,KAAL,CAAW,MAAMjB,QAAQ,CAACE,QAAD,EAAWC,OAAX,CAAzB,CAAX;AACA;;AACD,SAAO,EACN,GAAGG,QADG;AAEN,OAAGD;AAFG,GAAP;AAIA,CAdD;;AAeA,MAAMa,aAAa,GAAG,CAAChB,QAAD,EAAWC,OAAX,EAAoBC,QAApB,KAAiC;AACtD,SAAOe,WAAW,CAAClB,OAAO,CAACC,QAAD,EAAWC,OAAX,EAAoBC,QAApB,CAAR,CAAlB;AACA,CAFD;;AAGA,SAASe,WAAT,CAAqBC,OAArB,EAA8B;AAC7B,MAAIC,MAAM,GAAG,SAAb;AACA,MAAIC,MAAJ;AACA,MAAIC,SAAS,GAAGH,OAAO,CAACV,IAAR,CACdc,CAAD,IAAO;AACNH,IAAAA,MAAM,GAAG,SAAT;AACAC,IAAAA,MAAM,GAAGE,CAAT;AACA,GAJc,EAKdC,CAAD,IAAO;AACNJ,IAAAA,MAAM,GAAG,OAAT;AACAC,IAAAA,MAAM,GAAGG,CAAT;AACA,GARc,CAAhB;AAUA,SAAO;AACNC,IAAAA,IAAI,GAAG;AACN,UAAIL,MAAM,KAAK,SAAf,EAA0B;AACzB,cAAME,SAAN;AACA,OAFD,MAEO,IAAIF,MAAM,KAAK,OAAf,EAAwB;AAC9B,cAAMC,MAAN;AACA,OAFM,MAEA,IAAID,MAAM,KAAK,SAAf,EAA0B;AAChC,eAAOC,MAAP;AACA;AACD;;AATK,GAAP;AAWA;;AAED,eAAeJ,aAAf","sourcesContent":["import { retrieve } from \"../utils/crypt\";\n\nconst getData = async (ipfsHash, certkey, contract) => {\n\tlet ipfsData, certData;\n\tif (!!ipfsHash & !!certkey) {\n\t\tawait contract.methods\n\t\t\t.verify(ipfsHash)\n\t\t\t.call()\n\t\t\t.then((res) => (certData = res))\n\t\t\t.catch((error) => console.log(error));\n\t\tipfsData = JSON.parse(await retrieve(ipfsHash, certkey));\n\t}\n\treturn {\n\t\t...certData,\n\t\t...ipfsData,\n\t};\n};\nconst fetchCertData = (ipfsHash, certkey, contract) => {\n\treturn wrapPromise(getData(ipfsHash, certkey, contract));\n};\nfunction wrapPromise(promise) {\n\tlet status = \"pending\";\n\tlet result;\n\tlet suspender = promise.then(\n\t\t(r) => {\n\t\t\tstatus = \"success\";\n\t\t\tresult = r;\n\t\t},\n\t\t(e) => {\n\t\t\tstatus = \"error\";\n\t\t\tresult = e;\n\t\t}\n\t);\n\treturn {\n\t\tread() {\n\t\t\tif (status === \"pending\") {\n\t\t\t\tthrow suspender;\n\t\t\t} else if (status === \"error\") {\n\t\t\t\tthrow result;\n\t\t\t} else if (status === \"success\") {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport default fetchCertData;\n"]},"metadata":{},"sourceType":"module"}