{"version":3,"sources":["../../src/mnemonic/index.ts"],"names":["RADIX","PBKDF2_ROUNDS","KEY_LEN","MIN_ENTROPY_SIZE","MAX_ENTROPY_SIZE","MIN_WORDS_SIZE","MAX_WORDS_SIZE","INVALID_MNEMONIC","INVALID_CHECKSUM","ENTROPY_NOT_DIVISIBLE","ENTROPY_TOO_LONG","ENTROPY_TOO_SHORT","WORDS_TOO_LONG","WORDS_TOO_SHORT","wordList","length","Error","bytesToBinary","bytes","reduce","binary","byte","toString","padStart","deriveChecksumBits","entropyBuffer","ENT","CS","hash","crypto","createHash","update","digest","slice","salt","password","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","from","normalize","saltBuffer","pbkdf2Sync","mnemonicToSeed","Promise","resolve","reject","pbkdf2","err","data","error","mnemonicToEntropy","words","split","bits","map","word","index","indexOf","join","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","parseInt","entropy","newChecksum","entropyToMnemonic","entropyStr","TypeError","checksumBytes","chunks","validateMnemonic","e","generateMnemonic","entropySize","randomBytes"],"mappings":"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","sourcesContent":["import crypto from \"crypto\";\nimport wordList from \"./word_list\";\nimport { HexString } from \"@ckb-lumos/base\";\n\nconst RADIX = 2048;\nconst PBKDF2_ROUNDS = 2048;\nconst KEY_LEN = 64;\nconst MIN_ENTROPY_SIZE = 16;\nconst MAX_ENTROPY_SIZE = 32;\nconst MIN_WORDS_SIZE = 12;\nconst MAX_WORDS_SIZE = 24;\n\nconst INVALID_MNEMONIC = `Invalid mnemonic`;\nconst INVALID_CHECKSUM = `Invalid checksum`;\nconst ENTROPY_NOT_DIVISIBLE = `Entropy should be divisable by 4`;\nconst ENTROPY_TOO_LONG = `Entropy should be shorter than ${\n  MAX_ENTROPY_SIZE + 1\n}`;\nconst ENTROPY_TOO_SHORT = `Entropy should be longer than ${\n  MIN_ENTROPY_SIZE - 1\n}`;\nconst WORDS_TOO_LONG = `Words should be shorter than ${MAX_WORDS_SIZE + 1}`;\nconst WORDS_TOO_SHORT = `Words should be longer than ${MIN_WORDS_SIZE - 1}`;\n\nif (wordList.length !== RADIX) {\n  throw new Error(\n    `Word list should have ${RADIX} words, but ${wordList.length} received in fact`\n  );\n}\n\nfunction bytesToBinary(bytes: Buffer): string {\n  return bytes.reduce((binary, byte) => {\n    return binary + byte.toString(2).padStart(8, \"0\");\n  }, \"\");\n}\n\nfunction deriveChecksumBits(entropyBuffer: Buffer): string {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = crypto.createHash(\"sha256\").update(entropyBuffer).digest();\n  return bytesToBinary(hash).slice(0, CS);\n}\n\nfunction salt(password: string = \"\"): string {\n  return `mnemonic${password}`;\n}\n\nexport function mnemonicToSeedSync(\n  mnemonic: string = \"\",\n  password: string = \"\"\n): Buffer {\n  const mnemonicBuffer = Buffer.from(mnemonic.normalize(\"NFKD\"), \"utf8\");\n  const saltBuffer = Buffer.from(salt(password.normalize(\"NFKD\")), \"utf8\");\n  return crypto.pbkdf2Sync(\n    mnemonicBuffer,\n    saltBuffer,\n    PBKDF2_ROUNDS,\n    KEY_LEN,\n    \"sha512\"\n  );\n}\n\nexport function mnemonicToSeed(\n  mnemonic: string = \"\",\n  password: string = \"\"\n): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    try {\n      const mnemonicBuffer = Buffer.from(mnemonic.normalize(\"NFKD\"), \"utf8\");\n      const saltBuffer = Buffer.from(salt(password.normalize(\"NFKD\")), \"utf8\");\n      crypto.pbkdf2(\n        mnemonicBuffer,\n        saltBuffer,\n        PBKDF2_ROUNDS,\n        KEY_LEN,\n        \"sha512\",\n        (err, data) => {\n          if (err) {\n            reject(err);\n          }\n          resolve(data);\n        }\n      );\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nexport function mnemonicToEntropy(mnemonic: string = \"\"): HexString {\n  const words = mnemonic.normalize(\"NFKD\").split(\" \");\n  if (words.length < MIN_WORDS_SIZE) {\n    throw new Error(WORDS_TOO_SHORT);\n  }\n  if (words.length > MAX_WORDS_SIZE) {\n    throw new Error(WORDS_TOO_LONG);\n  }\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  const bits = words\n    .map((word) => {\n      const index = wordList!.indexOf(word);\n      if (index === -1) {\n        throw new Error(INVALID_MNEMONIC);\n      }\n      return index.toString(2).padStart(11, \"0\");\n    })\n    .join(\"\");\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n\n  const entropyBytes = entropyBits\n    .match(/(.{1,8})/g)!\n    .map((byte) => parseInt(byte, 2));\n  if (entropyBytes.length < MIN_ENTROPY_SIZE) {\n    throw new Error(ENTROPY_TOO_SHORT);\n  }\n  if (entropyBytes.length > MAX_ENTROPY_SIZE) {\n    throw new Error(ENTROPY_TOO_LONG);\n  }\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(ENTROPY_NOT_DIVISIBLE);\n  }\n\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n\n  return \"0x\" + entropy.toString(\"hex\");\n}\n\nexport function entropyToMnemonic(entropyStr: HexString): string {\n  const entropy = Buffer.from(entropyStr.slice(2), \"hex\");\n\n  if (entropy.length < MIN_ENTROPY_SIZE) {\n    throw new TypeError(ENTROPY_TOO_SHORT);\n  }\n  if (entropy.length > MAX_ENTROPY_SIZE) {\n    throw new TypeError(ENTROPY_TOO_LONG);\n  }\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(ENTROPY_NOT_DIVISIBLE);\n  }\n\n  const entropyBytes = bytesToBinary(entropy);\n  const checksumBytes = deriveChecksumBits(entropy);\n\n  const bytes = entropyBytes + checksumBytes;\n  const chunks = bytes.match(/(.{1,11})/g)!;\n  const words = chunks.map((binary) => {\n    const index = parseInt(binary, 2);\n    return wordList[index];\n  });\n\n  return words.join(\" \");\n}\n\nexport function validateMnemonic(mnemonic: string): boolean {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n// Generate 12 words mnemonic code\nexport function generateMnemonic(): string {\n  const entropySize = 16;\n  const entropy: HexString =\n    \"0x\" + crypto.randomBytes(entropySize).toString(\"hex\");\n  return entropyToMnemonic(entropy);\n}\n\nexport default {\n  entropyToMnemonic,\n  mnemonicToEntropy,\n  mnemonicToSeed,\n  mnemonicToSeedSync,\n  validateMnemonic,\n  generateMnemonic,\n};\n"],"file":"index.js"}