{"version":3,"sources":["../src/key.ts"],"names":["ec","EC","signRecoverable","message","privateKey","utils","assertHexString","key","keyFromPrivate","slice","r","s","recoveryParam","sign","canonical","Error","fmtR","toString","padStart","fmtS","fmtRecoverableParam","recoverFromSignature","signature","msgBuffer","Buffer","from","sigBuffer","point","recoverPubKey","publicKey","encode","toLowerCase","privateToPublic","pkBuffer","length","publickey","getPublic","publicKeyToBlake160","blake160","CKBHasher","update","digestHex","privateKeyToBlake160"],"mappings":";;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA,MAAMA,EAAE,GAAG,IAAIC,YAAJ,CAAO,WAAP,CAAX;;AAEO,SAASC,eAAT,CACLC,OADK,EAELC,UAFK,EAGM;AACXC,cAAMC,eAAN,CAAsB,SAAtB,EAAiCH,OAAjC;;AACA,gCAAiBC,UAAjB;AAEA,QAAMG,GAAG,GAAGP,EAAE,CAACQ,cAAH,CAAkBJ,UAAU,CAACK,KAAX,CAAiB,CAAjB,CAAlB,CAAZ;AACA,QAAM;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA;AAAR,MAA0BL,GAAG,CAACM,IAAJ,CAASV,OAAO,CAACM,KAAR,CAAc,CAAd,CAAT,EAA2B;AACzDK,IAAAA,SAAS,EAAE;AAD8C,GAA3B,CAAhC;;AAGA,MAAIF,aAAa,KAAK,IAAtB,EAA4B;AAC1B,UAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;AACD;;AACD,QAAMC,IAAI,GAAGN,CAAC,CAACO,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,EAAxB,EAA4B,GAA5B,CAAb;AACA,QAAMC,IAAI,GAAGR,CAAC,CAACM,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,EAAxB,EAA4B,GAA5B,CAAb;AACA,QAAME,mBAAmB,GAAGR,aAAa,CAACK,QAAd,CAAuB,EAAvB,EAA2BC,QAA3B,CAAoC,CAApC,EAAuC,GAAvC,CAA5B;AACA,SAAO,OAAOF,IAAP,GAAcG,IAAd,GAAqBC,mBAA5B;AACD;;AAEM,SAASC,oBAAT,CACLlB,OADK,EAELmB,SAFK,EAGM;AACXjB,cAAMC,eAAN,CAAsB,SAAtB,EAAiCH,OAAjC;;AACAE,cAAMC,eAAN,CAAsB,WAAtB,EAAmCgB,SAAnC;;AAEA,QAAMC,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYtB,OAAO,CAACM,KAAR,CAAc,CAAd,CAAZ,EAA8B,KAA9B,CAAlB;AACA,QAAMiB,SAAS,GAAGF,MAAM,CAACC,IAAP,CAAYH,SAAS,CAACb,KAAV,CAAgB,CAAhB,CAAZ,EAAgC,KAAhC,CAAlB;AAEA,QAAMI,IAAoB,GAAG;AAC3BH,IAAAA,CAAC,EAAEgB,SAAS,CAACjB,KAAV,CAAgB,CAAhB,EAAmB,EAAnB,CADwB;AAE3BE,IAAAA,CAAC,EAAEe,SAAS,CAACjB,KAAV,CAAgB,EAAhB,EAAoB,EAApB,CAFwB;AAG3BG,IAAAA,aAAa,EAAEc,SAAS,CAAC,EAAD;AAHG,GAA7B;AAMA,QAAMC,KAAK,GAAG3B,EAAE,CAAC4B,aAAH,CAAiBL,SAAjB,EAA4BV,IAA5B,EAAkCA,IAAI,CAACD,aAAvC,CAAd;AACA,QAAMiB,SAAS,GAAG,OAAOF,KAAK,CAACG,MAAN,CAAa,KAAb,EAAoB,IAApB,EAA0BC,WAA1B,EAAzB;AACA,SAAOF,SAAP;AACD;;AAKM,SAASG,eAAT,CACL5B,UADK,EAEe;AACpB,MAAI6B,QAAQ,GAAG7B,UAAf;;AACA,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,kCAAiBA,UAAjB;AACA6B,IAAAA,QAAQ,GAAGT,MAAM,CAACC,IAAP,CAAYrB,UAAU,CAACK,KAAX,CAAiB,CAAjB,CAAZ,EAAiC,KAAjC,CAAX;AACD;;AACD,MAAIwB,QAAQ,CAACC,MAAT,KAAoB,EAAxB,EAA4B;AAC1B,UAAM,IAAInB,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,QAAMoB,SAAS,GAAGnC,EAAE,CAACQ,cAAH,CAAkByB,QAAlB,EAA4BG,SAA5B,CAAsC,IAAtC,EAA4C,KAA5C,CAAlB;;AACA,MAAI,OAAOhC,UAAP,KAAsB,QAA1B,EAAoC;AAClC,WAAO,OAAO+B,SAAd;AACD;;AACD,SAAOX,MAAM,CAACC,IAAP,CAAYU,SAAZ,EAAuB,KAAvB,CAAP;AACD;;AAEM,SAASE,mBAAT,CAA6BR,SAA7B,EAA8D;AACnE,+BAAgBA,SAAhB;AAEA,QAAMS,QAAgB,GAAG,IAAIjC,YAAMkC,SAAV,GACtBC,MADsB,CACfX,SADe,EAEtBY,SAFsB,GAGtBhC,KAHsB,CAGhB,CAHgB,EAGb,EAHa,CAAzB;AAKA,SAAO6B,QAAP;AACD;;AAEM,SAASI,oBAAT,CAA8BtC,UAA9B,EAAgE;AACrE,QAAMyB,SAAoB,GAAGG,eAAe,CAAC5B,UAAD,CAA5C;AACA,SAAOiC,mBAAmB,CAACR,SAAD,CAA1B;AACD;;eAEc;AACb3B,EAAAA,eADa;AAEbmB,EAAAA,oBAFa;AAGbW,EAAAA,eAHa;AAIbK,EAAAA,mBAJa;AAKbK,EAAAA;AALa,C","sourcesContent":["import { HexString, utils } from \"@ckb-lumos/base\";\nimport { ec as EC, SignatureInput } from \"elliptic\";\nimport { assertPrivateKey, assertPublicKey } from \"./helper\";\n\nconst ec = new EC(\"secp256k1\");\n\nexport function signRecoverable(\n  message: HexString,\n  privateKey: HexString\n): HexString {\n  utils.assertHexString(\"message\", message);\n  assertPrivateKey(privateKey);\n\n  const key = ec.keyFromPrivate(privateKey.slice(2));\n  const { r, s, recoveryParam } = key.sign(message.slice(2), {\n    canonical: true,\n  });\n  if (recoveryParam === null) {\n    throw new Error(\"Sign message failed!\");\n  }\n  const fmtR = r.toString(16).padStart(64, \"0\");\n  const fmtS = s.toString(16).padStart(64, \"0\");\n  const fmtRecoverableParam = recoveryParam.toString(16).padStart(2, \"0\");\n  return \"0x\" + fmtR + fmtS + fmtRecoverableParam;\n}\n\nexport function recoverFromSignature(\n  message: HexString,\n  signature: HexString\n): HexString {\n  utils.assertHexString(\"message\", message);\n  utils.assertHexString(\"signature\", signature);\n\n  const msgBuffer = Buffer.from(message.slice(2), \"hex\");\n  const sigBuffer = Buffer.from(signature.slice(2), \"hex\");\n\n  const sign: SignatureInput = {\n    r: sigBuffer.slice(0, 32),\n    s: sigBuffer.slice(32, 64),\n    recoveryParam: sigBuffer[64],\n  };\n\n  const point = ec.recoverPubKey(msgBuffer, sign, sign.recoveryParam!);\n  const publicKey = \"0x\" + point.encode(\"hex\", true).toLowerCase();\n  return publicKey;\n}\n\nexport function privateToPublic(privateKey: Buffer): Buffer;\nexport function privateToPublic(privateKey: HexString): HexString;\n\nexport function privateToPublic(\n  privateKey: Buffer | HexString\n): Buffer | HexString {\n  let pkBuffer = privateKey;\n  if (typeof privateKey === \"string\") {\n    assertPrivateKey(privateKey);\n    pkBuffer = Buffer.from(privateKey.slice(2), \"hex\");\n  }\n  if (pkBuffer.length !== 32) {\n    throw new Error(\"Private key must be 32 bytes!\");\n  }\n\n  const publickey = ec.keyFromPrivate(pkBuffer).getPublic(true, \"hex\");\n  if (typeof privateKey === \"string\") {\n    return \"0x\" + publickey;\n  }\n  return Buffer.from(publickey, \"hex\");\n}\n\nexport function publicKeyToBlake160(publicKey: HexString): HexString {\n  assertPublicKey(publicKey);\n\n  const blake160: string = new utils.CKBHasher()\n    .update(publicKey)\n    .digestHex()\n    .slice(0, 42);\n\n  return blake160;\n}\n\nexport function privateKeyToBlake160(privateKey: HexString): HexString {\n  const publicKey: HexString = privateToPublic(privateKey);\n  return publicKeyToBlake160(publicKey);\n}\n\nexport default {\n  signRecoverable,\n  recoverFromSignature,\n  privateToPublic,\n  publicKeyToBlake160,\n  privateKeyToBlake160,\n};\n"],"file":"key.js"}