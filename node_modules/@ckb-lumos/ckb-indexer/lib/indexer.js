"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CkbIndexer = void 0;

var _base = require("@ckb-lumos/base");

var _toolkit = require("@ckb-lumos/toolkit");

var _rpc = require("@ckb-lumos/rpc");

var _services = require("./services");

var _collector = require("./collector");

var _events = require("events");

var _type = require("./type");

var _bi = require("@ckb-lumos/bi");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DefaultTerminator = () => {
  return {
    stop: false,
    push: true
  };
};

function defaultLogger(level, message) {
  console.log(`[${level}] ${message}`);
}
/** CkbIndexer.collector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */


class CkbIndexer {
  constructor(ckbIndexerUrl, ckbRpcUrl) {
    _defineProperty(this, "medianTimeEmitters", []);

    _defineProperty(this, "emitters", []);

    _defineProperty(this, "isSubscribeRunning", false);

    this.ckbIndexerUrl = ckbIndexerUrl;
    this.ckbRpcUrl = ckbRpcUrl;
    this.uri = ckbRpcUrl;
  }

  getCkbRpc() {
    return new _rpc.RPC(this.ckbRpcUrl);
  }

  async tip() {
    const res = await (0, _services.request)(this.ckbIndexerUrl, "get_tip");
    return res;
  }

  asyncSleep(timeout) {
    return new Promise(resolve => setTimeout(resolve, timeout));
  }

  async waitForSync(blockDifference = 0) {
    const rpcTipNumber = parseInt((await this.getCkbRpc().get_tip_header()).number, 16);

    while (true) {
      const indexerTipNumber = parseInt((await this.tip()).block_number, 16);

      if (indexerTipNumber + blockDifference >= rpcTipNumber) {
        return;
      }

      await this.asyncSleep(1000);
    }
  }
  /** collector cells without block_hash by default.if you need block_hash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl.
   * don't use OtherQueryOption if you don't need block_hash,cause it will slowly your collect.
   */


  collector(queries, otherQueryOptions) {
    return new _collector.CKBCellCollector(this, queries, otherQueryOptions);
  }

  async request(method, // eslint-disable-next-line @typescript-eslint/no-explicit-any
  params, ckbIndexerUrl = this.ckbIndexerUrl // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ) {
    return (0, _services.request)(ckbIndexerUrl, method, params);
  }

  async getCells(searchKey, terminator = DefaultTerminator, searchKeyFilter = {}) {
    const infos = [];
    let cursor = searchKeyFilter.lastCursor;
    const sizeLimit = searchKeyFilter.sizeLimit || 100;
    const order = searchKeyFilter.order || "asc";
    const index = 0;

    while (true) {
      const params = [searchKey, order, `0x${sizeLimit.toString(16)}`, cursor];
      const res = await this.request("get_cells", params);
      const liveCells = res.objects;
      cursor = res.last_cursor;

      for (const liveCell of liveCells) {
        const cell = {
          cell_output: liveCell.output,
          data: liveCell.output_data,
          out_point: liveCell.out_point,
          block_number: liveCell.block_number
        };
        const {
          stop,
          push
        } = terminator(index, cell);

        if (push) {
          infos.push(cell);
        }

        if (stop) {
          return {
            objects: infos,
            lastCursor: cursor
          };
        }
      }

      if (liveCells.length <= sizeLimit) {
        break;
      }
    }

    return {
      objects: infos,
      lastCursor: cursor
    };
  }

  async getTransactions(searchKey, searchKeyFilter = {}) {
    let infos = [];
    let cursor = searchKeyFilter.lastCursor;
    const sizeLimit = searchKeyFilter.sizeLimit || 100;
    const order = searchKeyFilter.order || "asc";

    while (true) {
      const params = [searchKey, order, `0x${sizeLimit.toString(16)}`, cursor];
      const res = await this.request("get_transactions", params);
      const txs = res.objects;
      cursor = res.last_cursor;
      infos = infos.concat(txs);

      if (txs.length <= sizeLimit) {
        break;
      }
    }

    return {
      objects: infos,
      lastCursor: cursor
    };
  }

  running() {
    return true;
  }

  start() {
    defaultLogger("warn", "deprecated: no need to start the ckb-indexer manually");
  }

  startForever() {
    defaultLogger("warn", "deprecated: no need to startForever the ckb-indexer manually");
  }

  stop() {
    defaultLogger("warn", "deprecated: no need to stop the ckb-indexer manually");
  }

  subscribe(queries) {
    this.isSubscribeRunning = true;
    this.scheduleLoop();

    if (queries.lock && queries.type) {
      throw new Error("The notification machanism only supports you subscribing for one script once so far!");
    }

    if (queries.toBlock !== null || queries.skip !== null) {
      defaultLogger("warn", "The passing fields such as toBlock and skip are ignored in subscribe() method.");
    }

    const emitter = new _type.IndexerEmitter();
    emitter.argsLen = queries.argsLen;
    emitter.outputData = queries.data;

    if (queries.fromBlock) {
      _base.utils.assertHexadecimal("fromBlock", queries.fromBlock);
    }

    emitter.fromBlock = !queries.fromBlock ? _bi.BI.from(0) : _bi.BI.from(queries.fromBlock);

    if (queries.lock) {
      _toolkit.validators.ValidateScript(queries.lock);

      emitter.lock = queries.lock;
    } else if (queries.type && queries.type !== "empty") {
      _toolkit.validators.ValidateScript(queries.type);

      emitter.type = queries.type;
    } else {
      throw new Error("Either lock or type script must be provided!");
    }

    this.emitters.push(emitter);
    return emitter;
  }

  loop() {
    if (!this.isSubscribeRunning) {
      return;
    }

    this.poll().then(timeout => {
      this.scheduleLoop(timeout);
    }).catch(e => {
      defaultLogger("error", `Error occurs: ${e} ${e.stack}, stopping indexer!`);
      this.isSubscribeRunning = false;
    });
  }

  scheduleLoop(timeout = 1) {
    setTimeout(() => {
      this.loop();
    }, timeout);
  }

  async poll() {
    let timeout = 1;
    const tip = await this.tip();
    const {
      block_number,
      block_hash
    } = tip;

    if (block_number === "0x0") {
      const block = await this.request("get_block_by_number", [block_number], this.ckbRpcUrl);
      await this.publishAppendBlockEvents(block);
    }

    const nextBlockNumber = _bi.BI.from(block_number).add(1);

    const block = await this.request("get_block_by_number", [`0x${nextBlockNumber.toString(16)}`], this.ckbRpcUrl);

    if (block) {
      if (block.header.parent_hash === block_hash) {
        await this.publishAppendBlockEvents(block);
      } else {
        const block = await this.request("get_block_by_number", [block_number], this.ckbRpcUrl);
        await this.publishAppendBlockEvents(block);
      }
    } else {
      const block = await this.request("get_block_by_number", [block_number], this.ckbRpcUrl);
      await this.publishAppendBlockEvents(block);
      timeout = 3 * 1000;
    }

    return timeout;
  }

  async publishAppendBlockEvents(block) {
    for (const [txIndex, tx] of block.transactions.entries()) {
      const blockNumber = block.header.number; // publish changed events if subscribed script exists in previous output cells , skip the cellbase.

      if (txIndex > 0) {
        const requestData = tx.inputs.map((input, index) => {
          return {
            id: index,
            jsonrpc: "2.0",
            method: "get_transaction",
            params: [input.previous_output.tx_hash]
          };
        }); // batch request by block

        const transactionResponse = await (0, _services.requestBatch)(this.ckbRpcUrl, requestData).then(response => {
          return response.map((item, index) => {
            const cellIndex = tx.inputs[index].previous_output.index;
            const outputCell = item.result.transaction.outputs[parseInt(cellIndex)];
            const outputData = item.result.transaction.outputs_data[parseInt(cellIndex)];
            return {
              output: outputCell,
              outputData
            };
          });
        });
        transactionResponse.forEach(({
          output,
          outputData
        }) => {
          this.filterEvents(output, blockNumber, outputData);
        });
      } // publish changed events if subscribed script exists in output cells.


      for (const [outputIndex, output] of tx.outputs.entries()) {
        const outputData = tx.outputs_data[outputIndex];
        this.filterEvents(output, blockNumber, outputData);
      }
    }

    await this.emitMedianTimeEvents();
  }

  filterEvents(output, blockNumber, outputData) {
    for (const emitter of this.emitters) {
      if (emitter.lock !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.lock, output.lock)) {
        emitter.emit("changed");
      }
    }

    if (output.type !== null) {
      for (const emitter of this.emitters) {
        if (emitter.type !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.type, output.type)) {
          emitter.emit("changed");
        }
      }
    }
  }

  checkFilterOptions(emitter, blockNumber, outputData, emitterScript, script) {
    const checkBlockNumber = emitter.fromBlock ? _bi.BI.from(emitter.fromBlock).lte(blockNumber) : true;
    const checkOutputData = emitter.outputData === "any" || !emitter.outputData ? true : emitter.outputData === outputData;
    const checkScript = !script ? true : emitterScript.code_hash === script.code_hash && emitterScript.hash_type === script.hash_type && this.checkArgs(emitter.argsLen, emitterScript.args, script.args);
    return checkBlockNumber && checkOutputData && checkScript;
  }

  checkArgs(argsLen, emitterArgs, args) {
    if (argsLen === -1 || !argsLen && argsLen !== 0) {
      return emitterArgs === args;
    } else if (typeof argsLen === "number" && args.length === argsLen * 2 + 2) {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else if (argsLen === "any") {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else {
      return false;
    }
  }

  async emitMedianTimeEvents() {
    if (this.medianTimeEmitters.length === 0) {
      return;
    }

    const info = await (0, _services.request)(this.ckbRpcUrl, "get_blockchain_info");
    const medianTime = info.median_time;

    for (const medianTimeEmitter of this.medianTimeEmitters) {
      medianTimeEmitter.emit("changed", medianTime);
    }
  }

  subscribeMedianTime() {
    this.isSubscribeRunning = true;
    this.scheduleLoop();
    const medianTimeEmitter = new _events.EventEmitter();
    this.medianTimeEmitters.push(medianTimeEmitter);
    return medianTimeEmitter;
  }

}

exports.CkbIndexer = CkbIndexer;
//# sourceMappingURL=indexer.js.map