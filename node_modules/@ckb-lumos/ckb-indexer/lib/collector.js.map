{"version":3,"sources":["../src/collector.ts"],"names":["CKBCellCollector","constructor","indexer","queries","otherQueryOptions","defaultQuery","lock","undefined","type","argsLen","data","fromBlock","toBlock","order","skip","outputDataLenRange","outputCapacityRange","bufferSize","validateQueryOption","convertQueryOptionToSearchKey","Error","validators","ValidateScript","script","utils","assertHexadecimal","dataLen","Number","dataLenRange","toString","getLiveCell","lastCursor","searchKeyFilter","sizeLimit","result","getCells","shouldSkipped","cell","skippedCount","cell_output","args","count","getCellWithCursor","objects","counter","cells","length","buffer","index","request","rpcUrl","res","method","body","JSON","stringify","headers","status","json","error","getLiveCellWithBlockHash","requestData","map","id","jsonrpc","params","block_number","blockHashList","ckbRpcUrl","item","rpcResponse","find","responseItem","block_hash","collect","withBlockHash"],"mappings":"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","sourcesContent":["import { utils, Cell, BaseCellCollector } from \"@ckb-lumos/base\";\nimport { validators } from \"@ckb-lumos/toolkit\";\nimport {\n  SearchKeyFilter,\n  CKBIndexerQueryOptions,\n  GetCellsResults,\n  Order,\n  OtherQueryOptions,\n} from \"./type\";\n\nimport { CkbIndexer } from \"./indexer\";\nimport {\n  generateSearchKey,\n  getHexStringBytes,\n  instanceOfScriptWrapper,\n} from \"./services\";\nimport fetch from \"cross-fetch\";\n\ninterface GetBlockHashRPCResult {\n  jsonrpc: string;\n  id: number;\n  result: string;\n}\n\n/** CellCollector will not get cell with block_hash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get block_hash if you need. */\nexport class CKBCellCollector implements BaseCellCollector {\n  constructor(\n    public indexer: CkbIndexer,\n    public queries: CKBIndexerQueryOptions,\n    public otherQueryOptions?: OtherQueryOptions\n  ) {\n    const defaultQuery: CKBIndexerQueryOptions = {\n      lock: undefined,\n      type: undefined,\n      argsLen: -1,\n      data: \"any\",\n      fromBlock: undefined,\n      toBlock: undefined,\n      order: \"asc\",\n      skip: undefined,\n      outputDataLenRange: undefined,\n      outputCapacityRange: undefined,\n      bufferSize: undefined,\n    };\n    this.queries = { ...defaultQuery, ...this.queries };\n    this.validateQueryOption(this.queries);\n    this.convertQueryOptionToSearchKey();\n  }\n\n  public validateQueryOption(queries: CKBIndexerQueryOptions): void {\n    if (!queries.lock && (!queries.type || queries.type === \"empty\")) {\n      throw new Error(\"Either lock or type script must be provided!\");\n    }\n\n    if (queries.lock) {\n      if (!instanceOfScriptWrapper(queries.lock)) {\n        validators.ValidateScript(queries.lock);\n      } else if (instanceOfScriptWrapper(queries.lock)) {\n        validators.ValidateScript(queries.lock.script);\n      }\n    }\n\n    if (queries.type && queries.type !== \"empty\") {\n      if (\n        typeof queries.type === \"object\" &&\n        !instanceOfScriptWrapper(queries.type)\n      ) {\n        validators.ValidateScript(queries.type);\n      } else if (\n        typeof queries.type === \"object\" &&\n        instanceOfScriptWrapper(queries.type)\n      ) {\n        validators.ValidateScript(queries.type.script);\n      }\n    }\n\n    if (queries.fromBlock) {\n      utils.assertHexadecimal(\"fromBlock\", queries.fromBlock);\n    }\n    if (queries.toBlock) {\n      utils.assertHexadecimal(\"toBlock\", queries.toBlock);\n    }\n    if (queries.order !== \"asc\" && queries.order !== \"desc\") {\n      throw new Error(\"Order must be either asc or desc!\");\n    }\n    if (queries.outputCapacityRange) {\n      utils.assertHexadecimal(\n        \"outputCapacityRange[0]\",\n        queries.outputCapacityRange[0]\n      );\n      utils.assertHexadecimal(\n        \"outputCapacityRange[1]\",\n        queries.outputCapacityRange[1]\n      );\n    }\n\n    if (queries.outputDataLenRange) {\n      utils.assertHexadecimal(\n        \"outputDataLenRange[0]\",\n        queries.outputDataLenRange[0]\n      );\n      utils.assertHexadecimal(\n        \"outputDataLenRange[1]\",\n        queries.outputDataLenRange[1]\n      );\n    }\n\n    if (queries.outputDataLenRange && queries.data && queries.data !== \"any\") {\n      const dataLen = getHexStringBytes(queries.data);\n      if (\n        dataLen < Number(queries.outputDataLenRange[0]) ||\n        dataLen >= Number(queries.outputDataLenRange[1])\n      ) {\n        throw new Error(\"data length not match outputDataLenRange\");\n      }\n    }\n\n    if (queries.skip && typeof queries.skip !== \"number\") {\n      throw new Error(\"skip must be a number!\");\n    }\n\n    if (queries.bufferSize && typeof queries.bufferSize !== \"number\") {\n      throw new Error(\"bufferSize must be a number!\");\n    }\n  }\n\n  public convertQueryOptionToSearchKey(): void {\n    // unWrap `ScriptWrapper` into `Script`.\n    if (this.queries.lock) {\n      if (instanceOfScriptWrapper(this.queries.lock)) {\n        validators.ValidateScript(this.queries.lock.script);\n        this.queries.lock = this.queries.lock.script;\n      }\n    }\n\n    // unWrap `ScriptWrapper` into `Script`.\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      if (\n        typeof this.queries.type === \"object\" &&\n        instanceOfScriptWrapper(this.queries.type)\n      ) {\n        this.queries.type = this.queries.type.script;\n      }\n    }\n\n    if (!this.queries.outputDataLenRange) {\n      if (this.queries.data && this.queries.data !== \"any\") {\n        const dataLenRange = getHexStringBytes(this.queries.data);\n        this.queries.outputDataLenRange = [\n          \"0x\" + dataLenRange.toString(16),\n          \"0x\" + (dataLenRange + 1).toString(16),\n        ];\n      }\n    }\n  }\n\n  private async getLiveCell(lastCursor?: string): Promise<GetCellsResults> {\n    const searchKeyFilter: SearchKeyFilter = {\n      sizeLimit: this.queries.bufferSize,\n      order: this.queries.order as Order,\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    const result: GetCellsResults = await this.indexer.getCells(\n      generateSearchKey(this.queries),\n      undefined,\n      searchKeyFilter\n    );\n    return result;\n  }\n\n  private shouldSkipped(cell: Cell, skippedCount = 0) {\n    if (this.queries.skip && skippedCount < this.queries.skip) {\n      return true;\n    }\n    if (cell && this.queries.type === \"empty\" && cell.cell_output.type) {\n      return true;\n    }\n    if (this.queries.data !== \"any\" && cell.data !== this.queries.data) {\n      return true;\n    }\n    if (\n      this.queries.argsLen !== -1 &&\n      this.queries.argsLen !== \"any\" &&\n      getHexStringBytes(cell.cell_output.lock.args) !== this.queries.argsLen\n    ) {\n      return true;\n    }\n  }\n\n  async count(): Promise<number> {\n    let lastCursor: undefined | string = undefined;\n    const getCellWithCursor = async (): Promise<Cell[]> => {\n      const result: GetCellsResults = await this.getLiveCell(lastCursor);\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let cells: Cell[] = await getCellWithCursor();\n    if (cells.length === 0) {\n      return 0;\n    }\n    let buffer: Promise<Cell[]> = getCellWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (!this.shouldSkipped(cells[index], skippedCount)) {\n        counter += 1;\n      } else {\n        skippedCount++;\n      }\n      index++;\n      //reset index and exchange `cells` and `buffer` after count last cell\n      if (index === cells.length) {\n        index = 0;\n        cells = await buffer;\n        // break if can not get more cells\n        if (cells.length === 0) {\n          break;\n        }\n        buffer = getCellWithCursor();\n      }\n    }\n    return counter;\n  }\n\n  // eslint-disable-next-line\n  private async request(rpcUrl: string, data: unknown): Promise<any> {\n    const res: Response = await fetch(rpcUrl, {\n      method: \"POST\",\n      body: JSON.stringify(data),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    if (res.status !== 200) {\n      throw new Error(`indexer request failed with HTTP code ${res.status}`);\n    }\n    const result = await res.json();\n    if (result.error !== undefined) {\n      throw new Error(\n        `indexer request rpc failed with error: ${JSON.stringify(result.error)}`\n      );\n    }\n    return result;\n  }\n\n  private async getLiveCellWithBlockHash(lastCursor?: string) {\n    if (!this.otherQueryOptions) {\n      throw new Error(\"CKB Rpc URL must provide\");\n    }\n    const result: GetCellsResults = await this.getLiveCell(lastCursor);\n    if (result.objects.length === 0) {\n      return result;\n    }\n    const requestData = result.objects.map((cell, index) => {\n      return {\n        id: index,\n        jsonrpc: \"2.0\",\n        method: \"get_block_hash\",\n        params: [cell.block_number],\n      };\n    });\n    const blockHashList: GetBlockHashRPCResult[] = await this.request(\n      this.otherQueryOptions.ckbRpcUrl,\n      requestData\n    );\n    result.objects = result.objects.map((item, index) => {\n      const rpcResponse = blockHashList.find(\n        (responseItem: GetBlockHashRPCResult) => responseItem.id === index\n      );\n      const block_hash = rpcResponse && rpcResponse.result;\n      return { ...item, block_hash };\n    });\n    return result;\n  }\n\n  /** collect cells without block_hash by default.if you need block_hash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl when constructor CellCollect.\n   * don't use OtherQueryOption if you don't need block_hash,cause it will slowly your collect.\n   */\n  async *collect(): AsyncGenerator<Cell, void, unknown> {\n    //TODO: fix return type\n    const withBlockHash =\n      this.otherQueryOptions &&\n      \"withBlockHash\" in this.otherQueryOptions &&\n      this.otherQueryOptions.withBlockHash;\n    let lastCursor: undefined | string = undefined;\n    const getCellWithCursor = async (): Promise<Cell[]> => {\n      const result: GetCellsResults = await (withBlockHash\n        ? this.getLiveCellWithBlockHash(lastCursor)\n        : this.getLiveCell(lastCursor));\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let cells: Cell[] = await getCellWithCursor();\n    if (cells.length === 0) {\n      return;\n    }\n    let buffer: Promise<Cell[]> = getCellWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (!this.shouldSkipped(cells[index], skippedCount)) {\n        yield cells[index];\n      } else {\n        skippedCount++;\n      }\n      index++;\n      //reset index and exchange `cells` and `buffer` after yield last cell\n      if (index === cells.length) {\n        index = 0;\n        cells = await buffer;\n        // break if can not get more cells\n        if (cells.length === 0) {\n          break;\n        }\n        buffer = getCellWithCursor();\n      }\n    }\n  }\n}\n"],"file":"collector.js"}