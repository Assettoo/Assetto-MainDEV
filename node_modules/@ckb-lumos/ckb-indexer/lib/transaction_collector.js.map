{"version":3,"sources":["../src/transaction_collector.ts"],"names":["CKBIndexerTransactionCollector","BaseIndexerModule","TransactionCollector","constructor","indexer","queries","CKBRpcUrl","options","indexerTransactionList","getDetailRequestData","objects","map","hashItem","index","id","jsonrpc","method","params","tx_hash","transactionList","services","requestBatch","then","response","item","filterOptions","skipMissing","result","Error","args","argsLen","getHexStringBytes","targetCell","lock","lockArgsLen","instanceOfScriptWrapper","isLockArgsLenMatched","type","typeArgsLen","inputResult","ioType","filter","io_type","filterByIoType","defaultOptions","includeStatus","asBaseTransactionCollector","fetchIndexerTransaction","lastCursor","searchKeyFilter","sizeLimit","bufferSize","order","getTransactionByLockAndTypeIndependent","getTransactions","generateSearchKey","filterByTypeIoTypeAndLockIoType","getResolvedTransactionRequestPayload","unresolvedTransactionList","requestPayload","resolvedTransactionRequestId","forEach","unresolvedTransaction","indexerTransaction","unresolvedOutPoint","transaction","inputs","Number","io_index","previous_output","push","fetchResolvedTransaction","txIoTypeInputOutPointList","resolvedTransaction","length","getResolvedCell","resolvedTransactionList","outputs","find","tx","hash","resolvedCell","filterTransaction","filteredTransactionList","isCellScriptArgsValid","tx_status","getTransactionListFromRpc","queryWithTypeAdditionOptions","queryWithLockAdditionOptions","lockLastCursor","typeLastCursor","split","queriesWithoutType","undefined","transactionByLock","queriesWithoutLock","transactionByType","intersection","transactionList1","transactionList2","tx1","tx2","targetTx","hashList","count","getTxWithCursor","counter","txs","buffer","skippedCount","skip","getTransactionHashes","transactionHashes","collect"],"mappings":"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","sourcesContent":["import {\n  TransactionCollectorOptions,\n  indexer as BaseIndexerModule,\n  Output,\n  OutPoint,\n  TransactionWithStatus,\n  TransactionCollector as BaseTransactionCollector,\n  QueryOptions,\n  Transaction,\n} from \"@ckb-lumos/base\";\nimport {\n  SearchKeyFilter,\n  CKBIndexerQueryOptions,\n  IndexerTransaction,\n  IndexerTransactionList,\n  IOType,\n  Order,\n  GetTransactionRPCResult,\n  JsonRprRequestBody,\n} from \"./type\";\nimport { CkbIndexer } from \"./indexer\";\nimport * as services from \"./services\";\n\ninterface GetTransactionDetailResult {\n  objects: TransactionWithStatus[];\n  lastCursor: string | undefined;\n}\n\nexport class CKBIndexerTransactionCollector extends BaseIndexerModule.TransactionCollector {\n  filterOptions: TransactionCollectorOptions;\n  constructor(\n    public indexer: CkbIndexer,\n    public queries: CKBIndexerQueryOptions,\n    public CKBRpcUrl: string,\n    public options?: TransactionCollectorOptions\n  ) {\n    super(indexer, queries, options);\n    const defaultOptions: TransactionCollectorOptions = {\n      skipMissing: false,\n      includeStatus: true,\n    };\n    this.filterOptions = { ...defaultOptions, ...this.options };\n  }\n\n  public static asBaseTransactionCollector(\n    CKBRpcUrl: string\n  ): typeof BaseTransactionCollector {\n    return class extends BaseIndexerModule.TransactionCollector {\n      constructor(\n        indexer: CkbIndexer,\n        queries: QueryOptions,\n        options?: TransactionCollectorOptions\n      ) {\n        super(indexer, queries, options);\n        return new CKBIndexerTransactionCollector(\n          indexer,\n          queries,\n          CKBRpcUrl,\n          options\n        );\n      }\n    };\n  }\n  public async fetchIndexerTransaction(\n    queries: CKBIndexerQueryOptions,\n    lastCursor?: string\n  ): Promise<IndexerTransactionList> {\n    const searchKeyFilter: SearchKeyFilter = {\n      sizeLimit: queries.bufferSize,\n      order: queries.order as Order,\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    let indexerTransactionList: IndexerTransactionList = {\n      objects: [],\n      lastCursor: \"\",\n    };\n    /*\n     * if both lock and type exist,we need search them in independent and then get intersection\n     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,\n     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'\n     */\n\n    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`\n    if (\n      services.instanceOfScriptWrapper(queries.lock) &&\n      services.instanceOfScriptWrapper(queries.type)\n    ) {\n      indexerTransactionList = await this.getTransactionByLockAndTypeIndependent(\n        searchKeyFilter\n      );\n      lastCursor = indexerTransactionList.lastCursor;\n    } else {\n      //query by ScriptWrapper.script,block_range,order\n      indexerTransactionList = await this.indexer.getTransactions(\n        services.generateSearchKey(queries),\n        searchKeyFilter\n      );\n      lastCursor = indexerTransactionList.lastCursor;\n    }\n    // filter by ScriptWrapper.io_type\n    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(\n      indexerTransactionList.objects,\n      queries\n    );\n    return indexerTransactionList;\n  }\n\n  public getResolvedTransactionRequestPayload(\n    unresolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): JsonRprRequestBody[] {\n    const requestPayload: JsonRprRequestBody[] = [];\n    let resolvedTransactionRequestId = 0;\n    unresolvedTransactionList.forEach(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const indexerTransaction = indexerTransactionList.objects[index];\n        if (indexerTransaction.io_type === \"input\") {\n          const unresolvedOutPoint: OutPoint =\n            unresolvedTransaction.transaction.inputs[\n              Number(indexerTransaction.io_index)\n            ].previous_output;\n          requestPayload.push({\n            id: resolvedTransactionRequestId++,\n            jsonrpc: \"2.0\",\n            method: \"get_transaction\",\n            params: [unresolvedOutPoint.tx_hash],\n          });\n        }\n      }\n    );\n    return requestPayload;\n  }\n\n  public async fetchResolvedTransaction(\n    txIoTypeInputOutPointList: JsonRprRequestBody[]\n  ): Promise<GetTransactionRPCResult[]> {\n    let resolvedTransaction: GetTransactionRPCResult[] = [];\n    if (txIoTypeInputOutPointList.length <= 0) {\n      return resolvedTransaction;\n    }\n    resolvedTransaction = await services.requestBatch(\n      this.CKBRpcUrl,\n      txIoTypeInputOutPointList\n    );\n    return resolvedTransaction;\n  }\n\n  public getResolvedCell(\n    unresolvedTransaction: TransactionWithStatus,\n    resolvedTransactionList: GetTransactionRPCResult[],\n    indexerTransaction: IndexerTransaction\n  ): Output {\n    if (indexerTransaction.io_type !== \"input\") {\n      return unresolvedTransaction.transaction.outputs[\n        Number(indexerTransaction.io_index)\n      ];\n    } else {\n      const unresolvedOutPoint =\n        unresolvedTransaction.transaction.inputs[\n          Number(indexerTransaction.io_index)\n        ].previous_output;\n      const resolvedTransaction = resolvedTransactionList.find((tx) => {\n        return tx.result.transaction.hash === unresolvedOutPoint.tx_hash;\n      });\n      if (!resolvedTransaction) {\n        throw new Error(`Impossible: can NOT find resolved transaction!`);\n      }\n      const resolvedCell =\n        resolvedTransaction.result.transaction.outputs[\n          Number(unresolvedOutPoint.index)\n        ];\n      return resolvedCell;\n    }\n  }\n\n  //filter by ScriptWrapper.argsLen\n  public filterTransaction(\n    unresolvedTransactionList: TransactionWithStatus[],\n    resolvedTransactionList: GetTransactionRPCResult[],\n    indexerTransactionList: IndexerTransactionList\n  ): TransactionWithStatus[] {\n    const filteredTransactionList = unresolvedTransactionList.filter(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const resolvedCell: Output = this.getResolvedCell(\n          unresolvedTransaction,\n          resolvedTransactionList,\n          indexerTransactionList.objects[index]\n        );\n        return this.isCellScriptArgsValid(resolvedCell);\n      }\n    );\n    const objects = filteredTransactionList.map((tx) => ({\n      transaction: tx.transaction,\n      tx_status: tx.tx_status,\n    }));\n    return objects;\n  }\n\n  /*\n   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *data?: will not filter\n   *argsLen?: filter after get transaction detail;\n   *fromBlock?: query by ckb-indexer;\n   *toBlock?: query by ckb-indexer;\n   *skip?: filter after get transaction from ckb-indexer;;\n   *order?: query by ckb-indexer;\n   */\n  public async getTransactions(\n    lastCursor?: string\n  ): Promise<GetTransactionDetailResult> {\n    const indexerTransactionList: IndexerTransactionList = await this.fetchIndexerTransaction(\n      this.queries,\n      lastCursor\n    );\n    lastCursor = indexerTransactionList.lastCursor;\n\n    // return if transaction hash list if empty\n    if (indexerTransactionList.objects.length === 0) {\n      return {\n        objects: [],\n        lastCursor: lastCursor,\n      };\n    }\n    const unresolvedTransactionList: TransactionWithStatus[] = await this.getTransactionListFromRpc(\n      indexerTransactionList\n    );\n\n    const requestPayload = this.getResolvedTransactionRequestPayload(\n      unresolvedTransactionList,\n      indexerTransactionList\n    );\n    const resolvedTransactionList = await this.fetchResolvedTransaction(\n      requestPayload\n    );\n    const objects = this.filterTransaction(\n      unresolvedTransactionList,\n      resolvedTransactionList,\n      indexerTransactionList\n    );\n    return {\n      objects: objects,\n      lastCursor: lastCursor,\n    };\n  }\n\n  private async getTransactionByLockAndTypeIndependent(\n    searchKeyFilter: SearchKeyFilter\n  ): Promise<IndexerTransactionList> {\n    const queryWithTypeAdditionOptions = { ...searchKeyFilter };\n    const queryWithLockAdditionOptions = { ...searchKeyFilter };\n    if (searchKeyFilter.lastCursor) {\n      const [lockLastCursor, typeLastCursor] = searchKeyFilter.lastCursor.split(\n        \"-\"\n      );\n      queryWithLockAdditionOptions.lastCursor = lockLastCursor;\n      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;\n    }\n    const queriesWithoutType = { ...this.queries, type: undefined };\n    const transactionByLock = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutType),\n      queryWithTypeAdditionOptions\n    );\n    const queriesWithoutLock = { ...this.queries, lock: undefined };\n    const transactionByType = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutLock),\n      queryWithLockAdditionOptions\n    );\n\n    const intersection = (\n      transactionList1: IndexerTransaction[],\n      transactionList2: IndexerTransaction[]\n    ) => {\n      const result: IndexerTransaction[] = [];\n      transactionList1.forEach((tx1) => {\n        const tx2 = transactionList2.find(\n          (item) => item.tx_hash === tx1.tx_hash\n        );\n        if (tx2) {\n          // put the output io_type to intersection result, cause output have cells\n          const targetTx = tx1.io_type === \"output\" ? tx1 : tx2;\n          // change io_type to both cause targetTx exist both input and output\n          result.push({ ...targetTx, io_type: \"both\" });\n        }\n      });\n      return result;\n    };\n    const hashList = intersection(\n      transactionByType.objects,\n      transactionByLock.objects\n    );\n    const lastCursor =\n      transactionByLock.lastCursor + \"-\" + transactionByType.lastCursor;\n    const objects = hashList;\n    return { objects, lastCursor };\n  }\n\n  private getTransactionListFromRpc = async (\n    indexerTransactionList: IndexerTransactionList\n  ) => {\n    const getDetailRequestData = indexerTransactionList.objects.map(\n      (hashItem: IndexerTransaction, index: number) => {\n        return {\n          id: index,\n          jsonrpc: \"2.0\",\n          method: \"get_transaction\",\n          params: [hashItem.tx_hash],\n        };\n      }\n    );\n    const transactionList: TransactionWithStatus[] = await services\n      .requestBatch(this.CKBRpcUrl, getDetailRequestData)\n      .then((response: GetTransactionRPCResult[]) => {\n        return response.map(\n          (item: GetTransactionRPCResult): TransactionWithStatus => {\n            if (!this.filterOptions.skipMissing && !item.result) {\n              throw new Error(\n                `Transaction ${\n                  indexerTransactionList.objects[item.id].tx_hash\n                } is missing!`\n              );\n            }\n            return { ...item.result };\n          }\n        );\n      });\n    return transactionList;\n  };\n\n  private isLockArgsLenMatched = (\n    args: string | undefined,\n    argsLen?: number | \"any\"\n  ) => {\n    if (!argsLen) return true;\n    if (argsLen === \"any\") return true;\n    if (argsLen === -1) return true;\n    return services.getHexStringBytes(args as string) === argsLen;\n  };\n\n  // only valid after pass flow three validate\n  private isCellScriptArgsValid = (targetCell: Output) => {\n    if (this.queries.lock) {\n      const lockArgsLen = services.instanceOfScriptWrapper(this.queries.lock)\n        ? this.queries.lock.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      const typeArgsLen = services.instanceOfScriptWrapper(this.queries.type)\n        ? this.queries.type.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.type?.args, typeArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type === \"empty\") {\n      if (targetCell.type) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  private filterByIoType = (\n    inputResult: IndexerTransaction[],\n    ioType: IOType\n  ) => {\n    if (ioType === \"both\") {\n      return inputResult;\n    }\n    if (ioType === \"input\" || ioType === \"output\") {\n      return inputResult.filter(\n        (item: IndexerTransaction) =>\n          item.io_type === ioType || item.io_type === \"both\"\n      );\n    }\n    return inputResult;\n  };\n\n  private filterByTypeIoTypeAndLockIoType = (\n    inputResult: IndexerTransaction[],\n    queries: CKBIndexerQueryOptions\n  ) => {\n    let result = inputResult;\n    if (services.instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {\n      result = this.filterByIoType(result, queries.lock.ioType);\n    }\n    if (services.instanceOfScriptWrapper(queries.type) && queries.type.ioType) {\n      result = this.filterByIoType(result, queries.type.ioType);\n    }\n    return result;\n  };\n\n  async count(): Promise<number> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return 0;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        counter += 1;\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return counter;\n  }\n  async getTransactionHashes(): Promise<string[]> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n\n    const transactionHashes: string[] = [];\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return [];\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (txs[index].transaction.hash) {\n          transactionHashes.push(txs[index].transaction.hash as string);\n        }\n      }\n\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return transactionHashes;\n  }\n  async *collect(): AsyncGenerator<\n    TransactionWithStatus | Transaction,\n    undefined,\n    unknown\n  > {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return undefined;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (this.filterOptions.includeStatus) {\n          yield txs[index];\n        } else {\n          yield txs[index].transaction;\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n  }\n}\n"],"file":"transaction_collector.js"}