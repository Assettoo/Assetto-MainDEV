"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CellCollector = void 0;
exports.injectCapacity = injectCapacity;
exports.payFee = payFee;
exports.prepareSigningEntries = prepareSigningEntries;
exports.setupInputCell = setupInputCell;
exports.transfer = transfer;
exports.transferCompatible = transferCompatible;

var _helpers = require("@ckb-lumos/helpers");

var _from_info = require("./from_info");

var _secp256k1_blake = _interopRequireDefault(require("./secp256k1_blake160"));

var _dao = require("./dao");

var _base = require("@ckb-lumos/base");

var _toolkit = require("@ckb-lumos/toolkit");

var _helper = require("./helper");

var _immutable = require("immutable");

var _configManager = require("@ckb-lumos/config-manager");

var _rpc = require("@ckb-lumos/rpc");

var _ = require(".");

var _since = require("@ckb-lumos/base/lib/since");

var _bi = require("@ckb-lumos/bi");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  toBigUInt64LE,
  readBigUInt64LECompatible,
  readBigUInt64LE
} = _base.utils;
const {
  ScriptValue
} = _base.values;
const {
  parseEpoch,
  maximumAbsoluteEpochSince,
  generateAbsoluteEpochSince,
  validateSince
} = _base.since;
const CellCollector = class CellCollector {
  constructor(fromInfo, cellProvider, {
    config = undefined,
    queryOptions = {},
    tipHeader = undefined,
    NodeRPC = _rpc.RPC
  } = {}) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }

    config = config || (0, _configManager.getConfig)();
    const result = (0, _from_info.parseFromInfo)(fromInfo, {
      config
    });
    const fromScript = result.fromScript;
    this.multisigScript = result.multisigScript;
    this.fromScript = fromScript;
    this.config = config;
    this.tipHeader = tipHeader;

    if (tipHeader) {
      // TODO: `median_timestamp` is not provided now!
      this.tipSinceValidationInfo = {
        block_number: tipHeader.number,
        epoch: tipHeader.epoch,
        median_timestamp: ""
      };
    }

    this.rpc = new NodeRPC(cellProvider.uri);
    queryOptions = { ...queryOptions,
      lock: this.fromScript
    };
    let cellCollectors = (0, _immutable.List)([]);

    if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {
      const lock = {
        code_hash: fromScript.code_hash,
        hash_type: fromScript.hash_type,
        args: fromScript.args.slice(0, 42)
      }; // multisig with locktime, not dao

      cellCollectors = cellCollectors.push(cellProvider.collector({
        lock,
        argsLen: queryOptions.argsLen || 28,
        type: queryOptions.type || "empty",
        data: queryOptions.data || "0x"
      })); // multisig without locktime, dao

      if (!queryOptions.type && (!queryOptions.data || queryOptions.data === "any")) {
        cellCollectors = cellCollectors.push(cellProvider.collector({
          lock,
          type: (0, _helper.generateDaoScript)(config),
          data: "any"
        })); // multisig with locktime, dao

        cellCollectors = cellCollectors.push(cellProvider.collector({
          lock,
          argsLen: 28,
          type: (0, _helper.generateDaoScript)(config),
          data: "any"
        }));
      }
    } else if ((0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {
      // secp256k1_blake160, dao
      if (!queryOptions.type && (!queryOptions.data || queryOptions.data === "any")) {
        cellCollectors = cellCollectors.push(cellProvider.collector({
          lock: fromScript,
          type: (0, _helper.generateDaoScript)(config),
          data: "any"
        }));
      }
    }

    this.cellCollectors = cellCollectors;
  }

  async *collect() {
    for (const cellCollector of this.cellCollectors) {
      for await (const inputCell of cellCollector.collect()) {
        const lock = inputCell.cell_output.lock;
        let since;
        let maximumCapacity;
        let depositBlockHash;
        let withdrawBlockHash;
        let sinceValidationInfo; // multisig

        if (lock.args.length === 58) {
          const header = await this.rpc.get_header(inputCell.block_hash);
          since = "0x" + _parseMultisigArgsSinceCompatible(lock.args).toString(16); // TODO: `median_timestamp` not provided now!

          sinceValidationInfo = {
            epoch: header.epoch,
            block_number: header.number,
            median_timestamp: ""
          };
        } // dao


        if ((0, _helper.isDaoScript)(inputCell.cell_output.type, this.config)) {
          if (inputCell.data === "0x0000000000000000") {
            continue;
          }

          const transactionWithStatus = await this.rpc.get_transaction(inputCell.out_point.tx_hash);
          withdrawBlockHash = transactionWithStatus.tx_status.block_hash;
          const transaction = transactionWithStatus.transaction;
          const depositOutPoint = transaction.inputs[+inputCell.out_point.index].previous_output;
          depositBlockHash = (await this.rpc.get_transaction(depositOutPoint.tx_hash)).tx_status.block_hash;
          const depositBlockHeader = await this.rpc.get_header(depositBlockHash);
          const withdrawBlockHeader = await this.rpc.get_header(withdrawBlockHash);
          let daoSince = "0x" + (0, _dao.calculateDaoEarliestSinceCompatible)(depositBlockHeader.epoch, withdrawBlockHeader.epoch).toString(16);
          maximumCapacity = (0, _dao.calculateMaximumWithdrawCompatible)(inputCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
          const withdrawEpochValue = parseEpoch(withdrawBlockHeader.epoch);
          const fourEpochsLater = {
            number: withdrawEpochValue.number + 4,
            length: withdrawEpochValue.length,
            index: withdrawEpochValue.index
          };
          daoSince = maximumAbsoluteEpochSince(daoSince, generateAbsoluteEpochSince(fourEpochsLater)); // if multisig with locktime

          if (since) {
            const multisigSince = (0, _since.parseSinceCompatible)(since);

            if (!(multisigSince.relative === false && multisigSince.type === "epochNumber")) {
              // throw new Error(
              //   "Multisig since not an absolute-epoch-number since format!"
              // );
              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it
              continue;
            }

            try {
              since = maximumAbsoluteEpochSince(daoSince, since);
            } catch {
              since = daoSince;
            }
          } else {
            since = daoSince;
          }
        }

        if ((0, _since.parseSinceCompatible)(since).type === "blockTimestamp" || this.tipHeader && !validateSince(since, this.tipSinceValidationInfo, sinceValidationInfo)) {
          continue;
        }

        const result = { ...inputCell,
          since: since,
          depositBlockHash: depositBlockHash,
          withdrawBlockHash: withdrawBlockHash,
          sinceValidationInfo
        };
        result.cell_output.capacity = "0x" + (maximumCapacity || _bi.BI.from(inputCell.cell_output.capacity)).toString(16);
        yield result;
      }
    }
  }

};
exports.CellCollector = CellCollector;

async function transfer(txSkeleton, fromInfos, toAddress, amount, tipHeader, {
  config = undefined,
  requireToAddress = true,
  assertAmountEnough = true,
  LocktimeCellCollector = CellCollector
} = {}) {
  const result = await transferCompatible(txSkeleton, fromInfos, toAddress, amount, tipHeader, {
    config,
    requireToAddress,
    assertAmountEnough: assertAmountEnough,
    LocktimeCellCollector
  });

  let _txSkeleton;

  let _amount;

  if (result instanceof Array) {
    _txSkeleton = result[0];
    _amount = BigInt(result[1].toString());
    return [_txSkeleton, _amount];
  } else {
    _txSkeleton = result;
    return _txSkeleton;
  }
}

async function transferCompatible(txSkeleton, fromInfos, toAddress, amount, tipHeader, {
  config = undefined,
  requireToAddress = true,
  assertAmountEnough = true,
  LocktimeCellCollector = CellCollector
} = {}) {
  let _amount = _bi.BI.from(amount);

  for (const [index, fromInfo] of fromInfos.entries()) {
    const value = await _transferCompatible(txSkeleton, fromInfo, index === 0 ? toAddress : undefined, _amount, tipHeader, {
      config,
      requireToAddress: index === 0 ? requireToAddress : false,
      assertAmountEnough: false,
      LocktimeCellCollector
    }); // [txSkeleton, amount] = value

    txSkeleton = value[0];
    _amount = value[1];

    if (_amount.eq(0)) {
      if (assertAmountEnough) {
        return txSkeleton;
      }

      return [txSkeleton, _bi.BI.from(_amount)];
    }
  }

  if (assertAmountEnough) {
    throw new Error("Not enough capacity in from addresses!");
  }

  return [txSkeleton, _bi.BI.from(_amount)];
}

async function _transferCompatible(txSkeleton, fromInfo, toAddress, amount, tipHeader, {
  config = undefined,
  requireToAddress = true,
  assertAmountEnough = true,
  LocktimeCellCollector = CellCollector,
  changeAddress = undefined
}) {
  config = config || (0, _configManager.getConfig)(); // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig

  const {
    fromScript
  } = (0, _from_info.parseFromInfo)(fromInfo, {
    config
  }); // validate fromScript

  if (!(0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) && !(0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {
    throw new Error("fromInfo not supported!");
  }

  if (requireToAddress && !toAddress) {
    throw new Error("You must provide a to address!");
  }

  let _amount = _bi.BI.from(amount || 0);

  if (toAddress) {
    const toScript = (0, _helpers.parseAddress)(toAddress, {
      config
    });
    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.push({
        cell_output: {
          capacity: "0x" + _amount.toString(16),
          lock: toScript,
          type: undefined
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined
      });
    });
  }

  const lastFreezedOutput = txSkeleton.get("fixedEntries").filter(({
    field
  }) => field === "outputs").maxBy(({
    index
  }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;

  for (; i < txSkeleton.get("outputs").size && _amount.gt(0); ++i) {
    const output = txSkeleton.get("outputs").get(i);

    if (new ScriptValue(output.cell_output.lock, {
      validate: false
    }).equals(new ScriptValue(fromScript, {
      validate: false
    }))) {
      const cellCapacity = _bi.BI.from(output.cell_output.capacity);

      let deductCapacity;

      if (_amount.gte(cellCapacity)) {
        deductCapacity = cellCapacity;
      } else {
        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output));

        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }
      }

      _amount = _amount.sub(deductCapacity);
      const clonedOutput = JSON.parse(JSON.stringify(output));
      clonedOutput.cell_output.capacity = "0x" + cellCapacity.sub(deductCapacity).toString(16);
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.update(i, () => clonedOutput);
      });
    }
  } // remove all output cells with capacity equal to 0


  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.filter(output => !_bi.BI.from(output.cell_output.capacity).eq(0));
  });
  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */

  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");

    if (!cellProvider) {
      throw new Error("cell provider is missing!");
    }

    const changeLockScript = changeAddress ? (0, _helpers.parseAddress)(changeAddress, {
      config
    }) : fromScript;
    const changeCell = {
      cell_output: {
        capacity: "0x0",
        lock: changeLockScript,
        type: undefined
      },
      data: "0x",
      out_point: undefined,
      block_hash: undefined
    };

    let changeCapacity = _bi.BI.from(0);

    let previousInputs = (0, _immutable.Set)();

    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
    }

    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
      config,
      tipHeader
    });

    for await (const cell of cellCollector.collect()) {
      const inputCell = cell; // skip inputs already exists in txSkeleton.inputs

      if (previousInputs.has(`${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`)) {
        continue;
      }

      let multisigSince;

      if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {
        const lockArgs = inputCell.cell_output.lock.args;
        multisigSince = lockArgs.length === 58 ? _bi.BI.from(_parseMultisigArgsSinceCompatible(lockArgs)) : undefined;
      }

      let witness = "0x";

      if ((0, _helper.isDaoScript)(inputCell.cell_output.type, config)) {
        const template = config.SCRIPTS.DAO;
        txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
          dep_type: template.DEP_TYPE,
          out_point: {
            tx_hash: template.TX_HASH,
            index: template.INDEX
          }
        });
        txSkeleton = txSkeleton.update("headerDeps", headerDeps => {
          return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);
        });
        const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;
        const witnessArgs = {
          input_type: toBigUInt64LE(depositHeaderDepIndex)
        };
        witness = new _toolkit.Reader(_base.core.SerializeWitnessArgs(_toolkit.normalizers.NormalizeWitnessArgs(witnessArgs))).serializeJson();
      }

      txSkeleton = await collectInput(txSkeleton, inputCell, (0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) ? Object.assign({}, fromInfo, {
        since: multisigSince
      }) : fromInfo, {
        config,
        defaultWitness: witness,
        since: inputCell.since
      });

      const inputCapacity = _bi.BI.from(inputCell.cell_output.capacity);

      let deductCapacity = inputCapacity;

      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }

      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);

      if ((0, _helper.isDaoScript)(inputCell.cell_output.type, config)) {
        // fix inputs / outputs / witnesses
        txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
          return fixedEntries.push({
            field: "inputs",
            index: txSkeleton.get("inputs").size - 1
          }, {
            field: "witnesses",
            index: txSkeleton.get("witnesses").size - 1
          }, {
            field: "headerDeps",
            index: txSkeleton.get("headerDeps").size - 2
          });
        });
      }

      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCell)))) {
        break;
      }
    }

    if (changeCapacity.gt(0)) {
      changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", outputs => outputs.push(changeCell));
    }
  }

  if (!assertAmountEnough) {
    return [txSkeleton, _amount];
  }

  if (_amount.gt(0)) {
    throw new Error("Not enough capacity in from address!");
  }

  return txSkeleton;
}

async function injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {
  config = undefined,
  LocktimeCellCollector = CellCollector,
  enableDeductCapacity = true
}) {
  config = config || (0, _configManager.getConfig)(); // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig

  let _amount = _bi.BI.from(amount);

  const _minimalChangeCapacity = _bi.BI.from(minimalChangeCapacity);

  if (enableDeductCapacity) {
    for (const fromInfo of fromInfos) {
      const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
        config
      }).fromScript; // validate fromScript

      if (!(0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config) && !(0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {
        // Skip if not support.
        continue;
      }

      const lastFreezedOutput = txSkeleton.get("fixedEntries").filter(({
        field
      }) => field === "outputs").maxBy(({
        index
      }) => index);
      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;

      for (; i < txSkeleton.get("outputs").size && _amount.gt(0); ++i) {
        const output = txSkeleton.get("outputs").get(i);

        if (new ScriptValue(output.cell_output.lock, {
          validate: false
        }).equals(new ScriptValue(fromScript, {
          validate: false
        }))) {
          const clonedOutput = JSON.parse(JSON.stringify(output));

          const cellCapacity = _bi.BI.from(clonedOutput.cell_output.capacity);

          let deductCapacity;

          if (_amount.gte(cellCapacity)) {
            deductCapacity = cellCapacity;
          } else {
            deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(clonedOutput));

            if (deductCapacity.gt(_amount)) {
              deductCapacity = _amount;
            }
          }

          _amount = _amount.sub(deductCapacity);
          clonedOutput.cell_output.capacity = "0x" + cellCapacity.sub(deductCapacity).toString(16);
          txSkeleton = txSkeleton.update("outputs", outputs => {
            return outputs.update(i, () => clonedOutput);
          });
        }
      } // remove all output cells with capacity equal to 0


      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.filter(output => !_bi.BI.from(output.cell_output.capacity).eq(0));
      });
    }
  }
  /*
   * Collect and add new input cells so as to prepare remaining capacities.
   */


  let changeCapacity = _bi.BI.from(0);

  if (_amount.gt(0)) {
    const cellProvider = txSkeleton.get("cellProvider");

    if (!cellProvider) {
      throw new Error("cell provider is missing!");
    }

    const getInputKey = input => `${input.out_point.tx_hash}_${input.out_point.index}`;

    let previousInputs = (0, _immutable.Set)();

    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(getInputKey(input));
    }

    for (const fromInfo of fromInfos) {
      const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
        config
      }).fromScript;
      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
        config,
        tipHeader
      });

      for await (const cell of cellCollector.collect()) {
        const inputCell = cell; // skip inputs already exists in txSkeleton.inputs

        if (previousInputs.has(getInputKey(inputCell))) {
          continue;
        }

        let witness = "0x";

        if ((0, _helper.isDaoScript)(inputCell.cell_output.type, config)) {
          const template = config.SCRIPTS.DAO;
          txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
            dep_type: template.DEP_TYPE,
            out_point: {
              tx_hash: template.TX_HASH,
              index: template.INDEX
            }
          });
          txSkeleton = txSkeleton.update("headerDeps", headerDeps => {
            return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);
          });
          const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;
          const witnessArgs = {
            input_type: toBigUInt64LE(_bi.BI.from(depositHeaderDepIndex).toString())
          };
          witness = new _toolkit.Reader(_base.core.SerializeWitnessArgs(_toolkit.normalizers.NormalizeWitnessArgs(witnessArgs))).serializeJson();
        }

        let multisigSince;

        if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {
          // multisig
          const lockArgs = inputCell.cell_output.lock.args;
          multisigSince = lockArgs.length === 58 ? _bi.BI.from(_parseMultisigArgsSinceCompatible(lockArgs)) : undefined;
        }

        txSkeleton = await collectInput(txSkeleton, inputCell, Object.assign({}, fromInfo, {
          since: multisigSince
        }), {
          config,
          defaultWitness: witness,
          since: inputCell.since
        });

        const inputCapacity = _bi.BI.from(inputCell.cell_output.capacity);

        let deductCapacity = inputCapacity;

        if (deductCapacity.gt(_amount)) {
          deductCapacity = _amount;
        }

        _amount = _amount.sub(deductCapacity);
        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);

        if ((0, _helper.isDaoScript)(inputCell.cell_output.type, config)) {
          // fix inputs / outputs / witnesses
          txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
            return fixedEntries.push({
              field: "inputs",
              index: txSkeleton.get("inputs").size - 1
            }, {
              field: "witnesses",
              index: txSkeleton.get("witnesses").size - 1
            }, {
              field: "headerDeps",
              index: txSkeleton.get("headerDeps").size - 2
            });
          });
        }

        if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))) {
          break;
        }
      }
    }
  }

  return {
    txSkeleton,
    capacity: _bi.BI.from(_amount.toString()),
    changeCapacity: _bi.BI.from(changeCapacity.toString())
  };
}

async function injectCapacityWithoutChange(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {
  config = undefined,
  LocktimeCellCollector = CellCollector,
  enableDeductCapacity = true
}) {
  const result = await injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, {
    config,
    LocktimeCellCollector,
    enableDeductCapacity
  });
  return {
    txSkeleton: result.txSkeleton,
    capacity: result.capacity.toBigInt(),
    changeCapacity: result.changeCapacity.toBigInt()
  };
}

async function payFee(txSkeleton, fromInfos, amount, tipHeader, {
  config = undefined,
  LocktimeCellCollector = CellCollector
} = {}) {
  return transferCompatible(txSkeleton, fromInfos, undefined, amount, tipHeader, {
    config,
    requireToAddress: false,
    LocktimeCellCollector
  });
}

function prepareSigningEntries(txSkeleton, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  txSkeleton = (0, _helper.prepareSigningEntries)(txSkeleton, config, "SECP256K1_BLAKE160");
  txSkeleton = (0, _helper.prepareSigningEntries)(txSkeleton, config, "SECP256K1_BLAKE160_MULTISIG");
  return txSkeleton;
}

async function injectCapacity(txSkeleton, outputIndex, fromInfos, tipHeader, {
  config = undefined,
  LocktimeCellCollector = CellCollector
} = {}) {
  config = config || (0, _configManager.getConfig)();

  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error("Invalid output index!");
  }

  const capacity = _bi.BI.from(txSkeleton.get("outputs").get(outputIndex).cell_output.capacity);

  return transferCompatible(txSkeleton, fromInfos, undefined, _bi.BI.from(capacity), tipHeader, {
    config,
    requireToAddress: false,
    LocktimeCellCollector
  });
}

async function collectInput(txSkeleton, inputCell, fromInfo, {
  config = undefined,
  since = undefined,
  defaultWitness = "0x"
} = {}) {
  config = config || (0, _configManager.getConfig)();
  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
    config,
    since,
    defaultWitness
  });
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.remove(outputs.size - 1);
  });
  return txSkeleton;
}

async function setupInputCell(txSkeleton, inputCell, fromInfo, {
  config = undefined,
  since = undefined,
  defaultWitness = "0x"
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const inputLock = inputCell.cell_output.lock;

  if ((0, _helper.isSecp256k1Blake160Script)(inputLock, config)) {
    return _secp256k1_blake.default.setupInputCell(txSkeleton, inputCell, fromInfo, {
      config,
      defaultWitness,
      since
    });
  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(inputLock, config)) {
    return _.secp256k1Blake160Multisig.setupInputCell(txSkeleton, inputCell, fromInfo, {
      config,
      defaultWitness,
      since
    });
  } else {
    throw new Error(`Not supported input lock!`);
  }
}

function _parseMultisigArgsSince(args) {
  if (args.length !== 58) {
    throw new Error("Invalid multisig with since args!");
  }

  return readBigUInt64LE("0x" + args.slice(42));
}

function _parseMultisigArgsSinceCompatible(args) {
  if (args.length !== 58) {
    throw new Error("Invalid multisig with since args!");
  }

  return readBigUInt64LECompatible("0x" + args.slice(42));
}

var _default = {
  CellCollector,
  transfer,
  transferCompatible,
  payFee,
  prepareSigningEntries,
  injectCapacity,
  setupInputCell,
  injectCapacityWithoutChange,
  injectCapacityWithoutChangeCompatible
};
exports.default = _default;
//# sourceMappingURL=locktime_pool.js.map