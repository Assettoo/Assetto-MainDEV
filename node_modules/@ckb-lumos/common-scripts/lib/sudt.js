"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.issueToken = issueToken;
exports.ownerForSudt = ownerForSudt;
exports.transfer = transfer;

var _helper = require("./helper");

var _base = require("@ckb-lumos/base");

var _secp256k1_blake160_multisig = _interopRequireDefault(require("./secp256k1_blake160_multisig"));

var _from_info = require("./from_info");

var _common = _interopRequireDefault(require("./common"));

var _helpers = require("@ckb-lumos/helpers");

var _immutable = require("immutable");

var _configManager = require("@ckb-lumos/config-manager");

var _locktime_pool = require("./locktime_pool");

var _anyone_can_pay = _interopRequireWildcard(require("./anyone_can_pay"));

var _secp256k1_blake = _interopRequireDefault(require("./secp256k1_blake160"));

var _utils = require("@ckb-lumos/base/lib/utils");

var _bi = require("@ckb-lumos/bi");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  toBigUInt128LE,
  computeScriptHash
} = _base.utils;
const {
  ScriptValue
} = _base.values;

/**
 * Issue an sUDT cell
 *
 * @param txSkeleton
 * @param fromInfo
 * @param amount
 * @param capacity
 * @param tipHeader
 * @param options
 */
async function issueToken(txSkeleton, fromInfo, amount, capacity, tipHeader, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const template = config.SCRIPTS.SUDT;

  if (!template) {
    throw new Error("Provided config does not have SUDT script setup!");
  }

  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    out_point: {
      tx_hash: template.TX_HASH,
      index: template.INDEX
    },
    dep_type: template.DEP_TYPE
  });
  const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
    config
  }).fromScript;
  const toScript = fromScript;
  const sudtTypeScript = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: computeScriptHash(fromScript)
  };
  const targetOutput = {
    cell_output: {
      capacity: "0x0",
      lock: toScript,
      type: sudtTypeScript
    },
    data: toBigUInt128LE(amount),
    out_point: undefined,
    block_hash: undefined
  };

  if (!capacity) {
    capacity = (0, _helpers.minimalCellCapacityCompatible)(targetOutput);
  }

  let _capacity = _bi.BI.from(capacity);

  targetOutput.cell_output.capacity = "0x" + _capacity.toString(16);
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(targetOutput);
  });
  const outputIndex = txSkeleton.get("outputs").size - 1; // fix entry

  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "outputs",
      index: outputIndex
    });
  });
  txSkeleton = await _common.default.injectCapacity(txSkeleton, [fromInfo], _bi.BI.from(_bi.BI.from(targetOutput.cell_output.capacity)), undefined, tipHeader, {
    config
  });
  return txSkeleton;
}
/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param sudtToken
 * @param toAddress
 * @param amount
 * @param changeAddress if not provided, will use first fromInfo
 * @param capacity
 * @param tipHeader
 * @param options When `splitChangeCell = true` && change amount > 0 && change capacity >= minimalCellCapacity(change cell with sudt) + minimalCellCapacity(change cell without sudt), change cell will split to two change cells, one with sudt and one without.
 */


async function transfer(txSkeleton, fromInfos, sudtToken, toAddress, amount, changeAddress, capacity, tipHeader, {
  config = undefined,
  LocktimePoolCellCollector = _locktime_pool.CellCollector,
  splitChangeCell = false
} = {}) {
  config = config || (0, _configManager.getConfig)();

  let _amount = _bi.BI.from(amount);

  let _capacity = capacity ? _bi.BI.from(capacity) : undefined;

  const SUDT_SCRIPT = config.SCRIPTS.SUDT;

  if (!SUDT_SCRIPT) {
    throw new Error("Provided config does not have SUDT script setup!");
  }

  if (fromInfos.length === 0) {
    throw new Error("`fromInfos` can't be empty!");
  }

  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }

  const toScript = (0, _helpers.parseAddress)(toAddress, {
    config
  });
  const fromScripts = fromInfos.map(fromInfo => (0, _from_info.parseFromInfo)(fromInfo, {
    config
  }).fromScript);
  const changeOutputLockScript = changeAddress ? (0, _helpers.parseAddress)(changeAddress, {
    config
  }) : fromScripts[0];

  if (_amount.lte(0)) {
    throw new Error("amount must be greater than 0");
  }

  const sudtType = _generateSudtScript(sudtToken, config);

  const cellProvider = txSkeleton.get("cellProvider");

  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  } // if toScript is an anyone-can-pay script


  let toAddressInputCapacity = _bi.BI.from(0);

  let toAddressInputAmount = _bi.BI.from(0);

  if ((0, _helper.isAcpScript)(toScript, config)) {
    const toAddressCellCollector = new _anyone_can_pay.CellCollector(toAddress, cellProvider, {
      config,
      queryOptions: {
        type: sudtType,
        data: "any"
      }
    });
    const toAddressInput = (await toAddressCellCollector.collect().next()).value;

    if (!toAddressInput) {
      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
    }

    txSkeleton = txSkeleton.update("inputs", inputs => {
      return inputs.push(toAddressInput);
    });
    txSkeleton = txSkeleton.update("witnesses", witnesses => {
      return witnesses.push("0x");
    });
    toAddressInputCapacity = _bi.BI.from(toAddressInput.cell_output.capacity);
    toAddressInputAmount = _bi.BI.from((0, _utils.readBigUInt128LECompatible)(toAddressInput.data));
  }

  const targetOutput = {
    cell_output: {
      capacity: "0x0",
      lock: toScript,
      type: sudtType
    },
    data: toBigUInt128LE(_amount.toString()),
    out_point: undefined,
    block_hash: undefined
  };

  if ((0, _helper.isAcpScript)(toScript, config)) {
    if (!_capacity) {
      _capacity = _bi.BI.from(0);
    }

    targetOutput.cell_output.capacity = "0x" + toAddressInputCapacity.add(_capacity).toString(16);
    targetOutput.data = toBigUInt128LE(toAddressInputAmount.add(_amount));
  } else {
    if (!_capacity) {
      _capacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(targetOutput));
    }

    targetOutput.cell_output.capacity = "0x" + _capacity.toString(16);
  } // collect cells with which includes sUDT info


  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(targetOutput);
  });
  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1
    });
  });
  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    out_point: {
      tx_hash: SUDT_SCRIPT.TX_HASH,
      index: SUDT_SCRIPT.INDEX
    },
    dep_type: SUDT_SCRIPT.DEP_TYPE
  }); // collect cells

  const changeCell = {
    cell_output: {
      capacity: "0x0",
      lock: changeOutputLockScript,
      type: sudtType
    },
    data: toBigUInt128LE(_bi.BI.from(0).toString()),
    out_point: undefined,
    block_hash: undefined
  };
  const changeCellWithoutSudt = {
    cell_output: {
      capacity: "0x0",
      lock: changeOutputLockScript,
      type: undefined
    },
    data: "0x",
    out_point: undefined,
    block_hash: undefined
  };

  let changeCapacity = _bi.BI.from(0);

  let changeAmount = _bi.BI.from(0);

  let previousInputs = (0, _immutable.Set)();

  for (const input of txSkeleton.get("inputs")) {
    previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
  }

  let cellCollectorInfos = (0, _immutable.List)();

  if (tipHeader) {
    fromInfos.forEach((fromInfo, index) => {
      const locktimePoolCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {
        config,
        tipHeader,
        queryOptions: {
          type: sudtType,
          data: "any"
        }
      });
      cellCollectorInfos = cellCollectorInfos.push({
        cellCollector: locktimePoolCellCollector,
        index
      });
    });
  }

  fromInfos.forEach((fromInfo, index) => {
    const secpCollector = new _secp256k1_blake.default.CellCollector(fromInfo, cellProvider, {
      config,
      queryOptions: {
        type: sudtType,
        data: "any"
      }
    });
    const multisigCollector = new _secp256k1_blake160_multisig.default.CellCollector(fromInfo, cellProvider, {
      config,
      queryOptions: {
        type: sudtType,
        data: "any"
      }
    });
    const acpCollector = new _anyone_can_pay.default.CellCollector(fromInfo, cellProvider, {
      config,
      queryOptions: {
        type: sudtType,
        data: "any"
      }
    });
    cellCollectorInfos = cellCollectorInfos.push({
      cellCollector: secpCollector,
      index
    }, {
      cellCollector: multisigCollector,
      index
    }, {
      cellCollector: acpCollector,
      index,
      isAnyoneCanPay: true,
      destroyable: (0, _from_info.parseFromInfo)(fromInfo, {
        config
      }).destroyable
    });
  });

  if (tipHeader) {
    fromInfos.forEach((fromInfo, index) => {
      const locktimeCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {
        config,
        tipHeader
      });
      cellCollectorInfos = cellCollectorInfos.push({
        cellCollector: locktimeCellCollector,
        index
      });
    });
  }

  fromInfos.forEach((fromInfo, index) => {
    const secpCollector = new _secp256k1_blake.default.CellCollector(fromInfo, cellProvider, {
      config
    });
    const multisigCollector = new _secp256k1_blake160_multisig.default.CellCollector(fromInfo, cellProvider, {
      config
    });
    const acpCollector = new _anyone_can_pay.default.CellCollector(fromInfo, cellProvider, {
      config
    });
    cellCollectorInfos = cellCollectorInfos.push({
      cellCollector: secpCollector,
      index
    }, {
      cellCollector: multisigCollector,
      index
    }, {
      cellCollector: acpCollector,
      index,
      isAnyoneCanPay: true,
      destroyable: (0, _from_info.parseFromInfo)(fromInfo, {
        config
      }).destroyable
    });
  });

  for (const {
    index,
    cellCollector,
    isAnyoneCanPay,
    destroyable
  } of cellCollectorInfos) {
    for await (const inputCell of cellCollector.collect()) {
      // skip inputs already exists in txSkeleton.inputs
      const key = `${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`;

      if (previousInputs.has(key)) {
        continue;
      }

      previousInputs = previousInputs.add(key);
      const fromInfo = fromInfos[index];
      txSkeleton = await _common.default.setupInputCell(txSkeleton, inputCell, fromInfo, {
        config
      }); // remove output which added by `setupInputCell`

      const lastOutputIndex = txSkeleton.get("outputs").size - 1;
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.remove(lastOutputIndex);
      }); // remove output fixedEntry

      const fixedEntryIndex = txSkeleton.get("fixedEntries").findIndex(fixedEntry => {
        return fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex;
      });

      if (fixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
          return fixedEntries.remove(fixedEntryIndex);
        });
      }

      const inputCapacity = _bi.BI.from(inputCell.cell_output.capacity);

      const inputAmount = inputCell.cell_output.type ? _bi.BI.from((0, _utils.readBigUInt128LECompatible)(inputCell.data)) : _bi.BI.from(0);
      let deductCapacity = isAnyoneCanPay && !destroyable ? inputCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(inputCell)) : inputCapacity;
      let deductAmount = inputAmount;

      if (deductCapacity.gt(_capacity)) {
        deductCapacity = _bi.BI.from(_capacity);
      }

      _capacity = _capacity.sub(deductCapacity);
      const currentChangeCapacity = inputCapacity.sub(deductCapacity);

      if (!isAnyoneCanPay || isAnyoneCanPay && destroyable) {
        changeCapacity = changeCapacity.add(currentChangeCapacity);
      }

      if (deductAmount.gt(_amount)) {
        deductAmount = _amount;
      }

      _amount = _amount.sub(deductAmount);
      const currentChangeAmount = inputAmount.sub(deductAmount);

      if (!isAnyoneCanPay || isAnyoneCanPay && destroyable) {
        changeAmount = changeAmount.add(currentChangeAmount);
      }

      if (isAnyoneCanPay && !destroyable) {
        const acpChangeCell = {
          cell_output: {
            capacity: "0x" + currentChangeCapacity.toString(16),
            lock: inputCell.cell_output.lock,
            type: inputCell.cell_output.type
          },
          data: inputCell.cell_output.type ? toBigUInt128LE(currentChangeAmount.toString()) : "0x"
        };
        txSkeleton = txSkeleton.update("outputs", outputs => {
          return outputs.push(acpChangeCell);
        });

        if (inputCell.cell_output.type) {
          txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
            return fixedEntries.push({
              field: "outputs",
              index: txSkeleton.get("outputs").size - 1
            });
          });
        }
      } // changeAmount = 0n, the change output no need to include sudt type script


      if (_capacity.eq(0) && _amount.eq(0) && (changeCapacity.eq(0) && changeAmount.eq(0) || changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt)) && changeAmount.eq(0))) {
        changeCell.cell_output.type = undefined;
        changeCell.data = "0x";
        break;
      }

      if (_capacity.eq(0) && _amount.eq(0) && changeCapacity.gt((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt)) && changeAmount.gt(0)) {
        break;
      }
    }
  } // if change cell is an anyone-can-pay cell and exists in txSkeleton.get("outputs") and not in fixedEntries
  // 1. change lock script is acp
  // 2. lock and type are equal to output OutputA in outputs
  // 3. OutputA is not fixed.


  let changeOutputIndex = -1;

  if ((0, _helper.isAcpScript)(changeCell.cell_output.lock, config) && (changeOutputIndex = txSkeleton.get("outputs").findIndex(output => {
    return new ScriptValue(changeCell.cell_output.lock, {
      validate: false
    }).equals(new ScriptValue(output.cell_output.lock, {
      validate: false
    })) && (changeAmount.eq(0) && !changeCell.cell_output.type && !output.cell_output.type || changeAmount.gte(0) && !!changeCell.cell_output.type && !!output.cell_output.type && new ScriptValue(changeCell.cell_output.type, {
      validate: false
    }).equals(new ScriptValue(output.cell_output.type, {
      validate: false
    })));
  })) !== -1 && txSkeleton.get("fixedEntries").findIndex(fixedEntry => {
    return fixedEntry.field === "output" && fixedEntry.index === changeOutputIndex;
  }) === -1) {
    const originOutput = txSkeleton.get("outputs").get(changeOutputIndex);
    const clonedOutput = JSON.parse(JSON.stringify(originOutput));
    clonedOutput.cell_output.capacity = "0x" + _bi.BI.from(originOutput.cell_output.capacity).add(changeCapacity).toString(16);

    if (changeAmount.gt(0)) {
      clonedOutput.data = toBigUInt128LE((0, _utils.readBigUInt128LECompatible)(originOutput.data).add(changeAmount));
    }

    const minimalChangeCellCapcaity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));

    const minimalChangeCellWithoutSudtCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt));

    let splitFlag = false;

    if (changeAmount.gt(0) && splitChangeCell && changeCapacity.gte(minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity))) {
      clonedOutput.cell_output.capacity = originOutput.cell_output.capacity;
      changeCellWithoutSudt.cell_output.capacity = "0x" + changeCapacity.toString(16);
      splitFlag = true;
    }

    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.set(changeOutputIndex, clonedOutput);
    });

    if (splitFlag) {
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.push(changeCellWithoutSudt);
      });
    }
  } else if (changeCapacity.gte((0, _helpers.minimalCellCapacityCompatible)(changeCell))) {
    changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);

    if (changeAmount.gt(0)) {
      changeCell.data = toBigUInt128LE(changeAmount.toString());
    }

    const minimalChangeCellCapcaity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));

    const minimalChangeCellWithoutSudtCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCellWithoutSudt));

    let splitFlag = false;

    if (changeAmount.gt(0) && splitChangeCell) {
      if (changeCapacity.gte(minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity))) {
        changeCell.cell_output.capacity = "0x" + minimalChangeCellCapcaity.toString(16);
        changeCellWithoutSudt.cell_output.capacity = "0x" + changeCapacity.sub(minimalChangeCellCapcaity).toString(16);
        splitFlag = true;
      }
    }

    txSkeleton = txSkeleton.update("outputs", outputs => outputs.push(changeCell));

    if (changeAmount.gt(0)) {
      txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
        return fixedEntries.push({
          field: "outputs",
          index: txSkeleton.get("outputs").size - 1
        });
      });
    }

    if (splitFlag) {
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.push(changeCellWithoutSudt);
      });
    }
  } else if (changeAmount.gt(0) && changeCapacity.lt((0, _helpers.minimalCellCapacityCompatible)(changeCell))) {
    throw new Error("Not enough capacity for change in from infos!");
  }

  if (_capacity.gt(0)) {
    throw new Error("Not enough capacity in from infos!");
  }

  if (_amount.gt(0)) {
    throw new Error("Not enough amount in from infos!");
  }

  return txSkeleton;
}

function _generateSudtScript(token, config) {
  const SUDT_SCRIPT = config.SCRIPTS.SUDT; // TODO: check token is a valid hash

  return {
    code_hash: SUDT_SCRIPT.CODE_HASH,
    hash_type: SUDT_SCRIPT.HASH_TYPE,
    args: token
  };
}
/**
 * Compute sudt token by owner from info.
 *
 * @param fromInfo
 * @param options
 */


function ownerForSudt(fromInfo, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const {
    fromScript
  } = (0, _from_info.parseFromInfo)(fromInfo, {
    config
  });
  const lockHash = computeScriptHash(fromScript);
  return lockHash;
}

var _default = {
  issueToken,
  transfer,
  ownerForSudt
};
exports.default = _default;
//# sourceMappingURL=sudt.js.map