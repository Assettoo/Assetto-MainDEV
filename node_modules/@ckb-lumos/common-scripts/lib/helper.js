"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECP_SIGNATURE_PLACEHOLDER = void 0;
exports.addCellDep = addCellDep;
exports.default = void 0;
exports.ensureScript = ensureScript;
exports.generateDaoScript = generateDaoScript;
exports.hashWitness = hashWitness;
exports.isAcpAddress = isAcpAddress;
exports.isAcpScript = isAcpScript;
exports.isDaoScript = isDaoScript;
exports.isSecp256k1Blake160Address = isSecp256k1Blake160Address;
exports.isSecp256k1Blake160MultisigAddress = isSecp256k1Blake160MultisigAddress;
exports.isSecp256k1Blake160MultisigScript = isSecp256k1Blake160MultisigScript;
exports.isSecp256k1Blake160Script = isSecp256k1Blake160Script;
exports.isSudtScript = isSudtScript;
exports.prepareSigningEntries = prepareSigningEntries;

var _immutable = require("immutable");

var _helpers = require("@ckb-lumos/helpers");

var _base = require("@ckb-lumos/base");

var _toolkit = require("@ckb-lumos/toolkit");

var _bi = require("@ckb-lumos/bi");

const {
  CKBHasher,
  ckbHash
} = _base.utils;

function addCellDep(txSkeleton, newCellDep) {
  const cellDep = txSkeleton.get("cellDeps").find(cellDep => {
    return cellDep.dep_type === newCellDep.dep_type && new _base.values.OutPointValue(cellDep.out_point, {
      validate: false
    }).equals(new _base.values.OutPointValue(newCellDep.out_point, {
      validate: false
    }));
  });

  if (!cellDep) {
    txSkeleton = txSkeleton.update("cellDeps", cellDeps => {
      return cellDeps.push({
        out_point: newCellDep.out_point,
        dep_type: newCellDep.dep_type
      });
    });
  }

  return txSkeleton;
}

function generateDaoScript(config) {
  const template = config.SCRIPTS.DAO;
  return {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args: "0x"
  };
}

function isSecp256k1Blake160Script(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160;
  return script.code_hash === template.CODE_HASH && script.hash_type === template.HASH_TYPE;
}

function isSecp256k1Blake160Address(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160Script(script, config);
}

function isSecp256k1Blake160MultisigScript(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  return script.code_hash === template.CODE_HASH && script.hash_type === template.HASH_TYPE;
}

function isSecp256k1Blake160MultisigAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160MultisigScript(script, config);
}

function isDaoScript(script, config) {
  const template = config.SCRIPTS.DAO;
  return !!script && script.code_hash === template.CODE_HASH && script.hash_type === template.HASH_TYPE;
}

function isSudtScript(script, config) {
  const template = config.SCRIPTS.SUDT;

  if (!template) {
    throw new Error(`SUDT script not defined in config!`);
  }

  return !!script && script.code_hash === template.CODE_HASH && script.hash_type === template.HASH_TYPE;
}

function isAcpScript(script, config) {
  const template = config.SCRIPTS.ANYONE_CAN_PAY;

  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }

  return !!script && script.code_hash === template.CODE_HASH && script.hash_type === template.HASH_TYPE;
}

function isAcpAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isAcpScript(script, config);
}

function hashWitness(hasher, witness) {
  const lengthBuffer = new ArrayBuffer(8);
  const view = new DataView(lengthBuffer);

  const witnessHexString = _bi.BI.from(new _toolkit.Reader(witness).length()).toString(16);

  if (witnessHexString.length <= 8) {
    view.setUint32(0, Number("0x" + witnessHexString), true);
    view.setUint32(4, Number("0x" + "00000000"), true);
  }

  if (witnessHexString.length > 8 && witnessHexString.length <= 16) {
    view.setUint32(0, Number("0x" + witnessHexString.slice(-8)), true);
    view.setUint32(4, Number("0x" + witnessHexString.slice(0, -8)), true);
  }

  hasher.update(lengthBuffer);
  hasher.update(witness);
}

function prepareSigningEntries(txSkeleton, config, scriptType) {
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }

  let processedArgs = (0, _immutable.Set)();
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  const txHash = ckbHash(_base.core.SerializeRawTransaction(_toolkit.normalizers.NormalizeRawTransaction(tx))).serializeJson();
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");

  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i);

    if (template.CODE_HASH === input.cell_output.lock.code_hash && template.HASH_TYPE === input.cell_output.lock.hash_type && !processedArgs.has(input.cell_output.lock.args)) {
      processedArgs = processedArgs.add(input.cell_output.lock.args);
      const lockValue = new _base.values.ScriptValue(input.cell_output.lock, {
        validate: false
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);

      if (i >= witnesses.size) {
        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
      }

      hashWitness(hasher, witnesses.get(i));

      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j);

        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cell_output.lock, {
          validate: false
        }))) {
          hashWitness(hasher, witnesses.get(j));
        }
      }

      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j));
      }

      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex()
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }

  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

function ensureScript(script, config, scriptType) {
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }

  if (template.CODE_HASH !== script.code_hash || template.HASH_TYPE !== script.hash_type) {
    throw new Error(`Provided script is not ${scriptType} script!`);
  }
}
/* 65-byte zeros in hex */


const SECP_SIGNATURE_PLACEHOLDER = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
exports.SECP_SIGNATURE_PLACEHOLDER = SECP_SIGNATURE_PLACEHOLDER;
var _default = {
  addCellDep,
  generateDaoScript,
  isSecp256k1Blake160Script,
  isSecp256k1Blake160MultisigScript,
  isDaoScript,
  isSudtScript,
  prepareSigningEntries,
  isSecp256k1Blake160Address,
  isSecp256k1Blake160MultisigAddress,
  ensureScript,
  isAcpScript,
  isAcpAddress
};
exports.default = _default;
//# sourceMappingURL=helper.js.map