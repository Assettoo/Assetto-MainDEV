{"version":3,"sources":["../src/secp256k1_blake160.ts"],"names":["ScriptValue","values","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","Error","fromScript","lock","type","cellCollector","collector","collect","inputCell","setupInputCell","txSkeleton","_fromInfo","defaultWitness","since","cell_output","update","inputs","push","output","capacity","data","outputs","inputSinces","set","get","size","witnesses","template","SCRIPTS","SECP256K1_BLAKE160","scriptOutPoint","tx_hash","TX_HASH","index","INDEX","out_point","dep_type","DEP_TYPE","firstIndex","findIndex","input","validate","equals","witness","newWitnessArgs","SECP_SIGNATURE_PLACEHOLDER","witnessArgs","core","WitnessArgs","Reader","getLock","hasValue","value","raw","serializeJson","inputType","getInputType","input_type","outputType","getOutputType","output_type","SerializeWitnessArgs","normalizers","NormalizeWitnessArgs","transfer","fromAddress","toAddress","amount","requireToAddress","assertAmountEnough","result","transferCompatible","_txSkeleton","_amount","Array","BigInt","toString","BI","from","toScript","block_hash","lastFreezedOutput","filter","field","maxBy","i","gt","cellCapacity","deductCapacity","gte","sub","eq","changeCell","changeCapacity","previousInputs","add","has","inputCapacity","payFee","injectCapacity","outputIndex","prepareSigningEntries"],"mappings":"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","sourcesContent":["import { Set } from \"immutable\";\nimport { normalizers, Reader } from \"@ckb-lumos/toolkit\";\nimport {\n  parseAddress,\n  minimalCellCapacityCompatible,\n  TransactionSkeletonType,\n  Options,\n} from \"@ckb-lumos/helpers\";\nimport {\n  core,\n  values,\n  Address,\n  Cell,\n  WitnessArgs,\n  CellCollector as CellCollectorType,\n  Script,\n  CellProvider,\n  QueryOptions,\n  OutPoint,\n  HexString,\n  PackedSince,\n} from \"@ckb-lumos/base\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport {\n  addCellDep,\n  ensureScript,\n  prepareSigningEntries as _prepareSigningEntries,\n  SECP_SIGNATURE_PLACEHOLDER,\n  isSecp256k1Blake160Script,\n} from \"./helper\";\nimport { FromInfo } from \".\";\nimport { parseFromInfo } from \"./from_info\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\nconst { ScriptValue } = values;\n\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType {\n  private cellCollector: CellCollectorType;\n  private config: Config;\n  public readonly fromScript: Script;\n\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n    }: Options & {\n      queryOptions?: QueryOptions;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    this.fromScript = parseFromInfo(fromInfo, { config }).fromScript;\n\n    this.config = config;\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\",\n    };\n\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    if (!isSecp256k1Blake160Script(this.fromScript, this.config)) {\n      return;\n    }\n\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param _fromInfo\n * @param options\n */\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  _fromInfo?: FromInfo,\n  {\n    config = undefined,\n    defaultWitness = \"0x\",\n    since = undefined,\n  }: Options & {\n    defaultWitness?: HexString;\n    since?: PackedSince;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  const fromScript = inputCell.cell_output.lock;\n  if (!isSecp256k1Blake160Script(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160 input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n    return inputs.push(inputCell);\n  });\n\n  const output: Cell = {\n    cell_output: {\n      capacity: inputCell.cell_output.capacity,\n      lock: inputCell.cell_output.lock,\n      type: inputCell.cell_output.type,\n    },\n    data: inputCell.data,\n  };\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(output);\n  });\n\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", (inputSinces) => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n\n  txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n    return witnesses.push(defaultWitness);\n  });\n\n  const template = config.SCRIPTS.SECP256K1_BLAKE160;\n  if (!template) {\n    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);\n  }\n\n  const scriptOutPoint: OutPoint = {\n    tx_hash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  // add cell dep\n  txSkeleton = addCellDep(txSkeleton, {\n    out_point: scriptOutPoint,\n    dep_type: template.DEP_TYPE,\n  });\n\n  // add witness\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 65-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n    let witness: string = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n    const newWitnessArgs: WitnessArgs = {\n      /* 65-byte zeros in hex */\n      lock: SECP_SIGNATURE_PLACEHOLDER,\n    };\n    if (witness !== \"0x\") {\n      const witnessArgs = new core.WitnessArgs(new Reader(witness));\n      const lock = witnessArgs.getLock();\n      if (\n        lock.hasValue() &&\n        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock\n      ) {\n        throw new Error(\n          \"Lock field in first witness is set aside for signature!\"\n        );\n      }\n      const inputType = witnessArgs.getInputType();\n      if (inputType.hasValue()) {\n        newWitnessArgs.input_type = new Reader(\n          inputType.value().raw()\n        ).serializeJson();\n      }\n      const outputType = witnessArgs.getOutputType();\n      if (outputType.hasValue()) {\n        newWitnessArgs.output_type = new Reader(\n          outputType.value().raw()\n        ).serializeJson();\n      }\n    }\n    witness = new Reader(\n      core.SerializeWitnessArgs(\n        normalizers.NormalizeWitnessArgs(newWitnessArgs)\n      )\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n      witnesses.set(firstIndex, witness)\n    );\n  }\n\n  return txSkeleton;\n}\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: bigint,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: bigint,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\n/**\n * transfer capacity from secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param toAddress\n * @param amount\n * @param options\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: bigint,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromAddress,\n    toAddress,\n    amount,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: BIish,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: BIish,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\n/**\n * transfer capacity from secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param toAddress\n * @param amount\n * @param options\n */\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  toAddress: Address | null | undefined,\n  amount: BIish,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n\n  const template = config.SCRIPTS.SECP256K1_BLAKE160;\n  if (!template) {\n    throw new Error(\n      \"Provided config does not have SECP256K1_BLAKE160 script setup!\"\n    );\n  }\n  const scriptOutPoint = {\n    tx_hash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  txSkeleton = addCellDep(txSkeleton, {\n    out_point: scriptOutPoint,\n    dep_type: template.DEP_TYPE,\n  });\n\n  const fromScript = parseAddress(fromAddress, { config });\n  ensureScript(fromScript, config, \"SECP256K1_BLAKE160\");\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = BI.from(amount);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cell_output: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        out_point: undefined,\n        block_hash: undefined,\n      });\n    });\n  }\n\n  /*\n   * First, check if there is any output cells that contains enough capacity\n   * for us to tinker with.\n   *\n   * TODO: the solution right now won't cover all cases, some outputs before the\n   * last output might still be tinkerable, right now we are working on the\n   * simple solution, later we can change this for more optimizations.\n   */\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); i++) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cell_output.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cell_output.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // Remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cell_output.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"Cell provider is missing!\");\n    }\n    const cellCollector = cellProvider.collector({\n      lock: fromScript,\n    });\n    const changeCell: Cell = {\n      cell_output: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      out_point: undefined,\n      block_hash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.out_point!.tx_hash}_${input.out_point!.index}`\n      );\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`\n        )\n      ) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", (inputs) =>\n        inputs.push(inputCell)\n      );\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n      const inputCapacity = BI.from(inputCell.cell_output.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cell_output.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n  /*\n   * Modify the skeleton, so the first witness of the fromAddress script group\n   * has a WitnessArgs construct with 65-byte zero filled values. While this\n   * is not required, it helps in transaction fee estimation.\n   */\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n    let witness: string = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n    const newWitnessArgs: WitnessArgs = {\n      /* 65-byte zeros in hex */\n      lock: SECP_SIGNATURE_PLACEHOLDER,\n    };\n    if (witness !== \"0x\") {\n      const witnessArgs = new core.WitnessArgs(new Reader(witness));\n      const lock = witnessArgs.getLock();\n      if (\n        lock.hasValue() &&\n        new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock\n      ) {\n        throw new Error(\n          \"Lock field in first witness is set aside for signature!\"\n        );\n      }\n      const inputType = witnessArgs.getInputType();\n      if (inputType.hasValue()) {\n        newWitnessArgs.input_type = new Reader(\n          inputType.value().raw()\n        ).serializeJson();\n      }\n      const outputType = witnessArgs.getOutputType();\n      if (outputType.hasValue()) {\n        newWitnessArgs.output_type = new Reader(\n          outputType.value().raw()\n        ).serializeJson();\n      }\n    }\n    witness = new Reader(\n      core.SerializeWitnessArgs(\n        normalizers.NormalizeWitnessArgs(newWitnessArgs)\n      )\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n      witnesses.set(firstIndex, witness)\n    );\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by secp256k1_blake160 script cells\n *\n * @param txSkeleton\n * @param fromAddress\n * @param amount fee in shannon\n * @param options\n */\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromAddress: Address,\n  amount: BIish,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  return await transferCompatible(txSkeleton, fromAddress, null, amount, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * Inject capacity from `fromAddress` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromAddress\n * @param options\n */\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromAddress: Address,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cell_output.capacity\n  );\n  return await transferCompatible(\n    txSkeleton,\n    fromAddress,\n    null,\n    BI.from(capacity),\n    {\n      config,\n      requireToAddress: false,\n    }\n  );\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n\n  return _prepareSigningEntries(txSkeleton, config, \"SECP256K1_BLAKE160\");\n}\n\nexport default {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  CellCollector,\n};\n"],"file":"secp256k1_blake160.js"}