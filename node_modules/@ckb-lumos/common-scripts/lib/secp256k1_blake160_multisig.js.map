{"version":3,"sources":["../src/secp256k1_blake160_multisig.ts"],"names":["ScriptValue","values","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","Error","result","fromScript","multisigScript","lock","type","cellCollector","collector","collect","inputCell","setupInputCell","txSkeleton","defaultWitness","since","requireMultisigScript","cell_output","parsedFromScript","validate","equals","update","inputs","push","inputSinces","set","get","size","witnesses","outputCell","capacity","data","outputs","template","SCRIPTS","SECP256K1_BLAKE160_MULTISIG","scriptOutPoint","tx_hash","TX_HASH","index","INDEX","out_point","dep_type","DEP_TYPE","firstIndex","findIndex","input","firstIndexWitness","witness","newWitnessArgs","slice","SECP_SIGNATURE_PLACEHOLDER","repeat","M","witnessArgs","core","WitnessArgs","Reader","getLock","hasValue","value","raw","serializeJson","inputType","getInputType","input_type","outputType","getOutputType","output_type","SerializeWitnessArgs","normalizers","NormalizeWitnessArgs","transfer","toAddress","amount","requireToAddress","assertAmountEnough","transferCompatible","_txSkeleton","_amount","Array","BigInt","toString","noMultisigBefore","find","i","BI","from","toScript","block_hash","lastFreezedOutput","filter","field","maxBy","gt","output","cellCapacity","deductCapacity","gte","sub","eq","changeCell","changeCapacity","previousInputs","add","has","inputCapacity","payFee","injectCapacity","outputIndex","prepareSigningEntries","serializeMultisigScript","multisigArgs"],"mappings":"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","sourcesContent":["import {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport {\n  core,\n  values,\n  HexString,\n  Script,\n  Address,\n  OutPoint,\n  Cell,\n  WitnessArgs,\n  CellCollector as CellCollectorType,\n  CellProvider,\n  QueryOptions,\n  PackedSince,\n} from \"@ckb-lumos/base\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nconst { ScriptValue } = values;\nimport { normalizers, Reader } from \"@ckb-lumos/toolkit\";\nimport { Set } from \"immutable\";\nimport {\n  addCellDep,\n  ensureScript,\n  SECP_SIGNATURE_PLACEHOLDER,\n  prepareSigningEntries as _prepareSigningEntries,\n  isSecp256k1Blake160MultisigScript,\n} from \"./helper\";\nimport {\n  FromInfo,\n  parseFromInfo,\n  MultisigScript,\n  serializeMultisigScript,\n  multisigArgs,\n} from \"./from_info\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\n\nexport { serializeMultisigScript, multisigArgs };\n\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType {\n  private cellCollector: CellCollectorType;\n  private config: Config;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n    }: Options & {\n      queryOptions?: QueryOptions;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    this.fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n\n    this.config = config;\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\",\n    };\n\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    if (!isSecp256k1Blake160MultisigScript(this.fromScript, this.config)) {\n      return;\n    }\n\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param fromInfo\n * @param options\n */\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    defaultWitness = \"0x\",\n    since = undefined,\n    requireMultisigScript = true,\n  }: Options & {\n    defaultWitness?: HexString;\n    requireMultisigScript?: boolean;\n    since?: PackedSince;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  if (requireMultisigScript && typeof fromInfo !== \"object\") {\n    throw new Error(\"`fromInfo` must be MultisigScript format!\");\n  }\n\n  const fromScript: Script = inputCell.cell_output.lock;\n\n  if (fromInfo) {\n    const parsedFromScript: Script = parseFromInfo(fromInfo, { config })\n      .fromScript;\n    if (\n      !new ScriptValue(parsedFromScript, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      throw new Error(\"`fromInfo` not match to input lock!\");\n    }\n  }\n\n  if (!isSecp256k1Blake160MultisigScript(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n    return inputs.push(inputCell);\n  });\n\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", (inputSinces) => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n\n  txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n    return witnesses.push(defaultWitness);\n  });\n\n  const outputCell: Cell = {\n    cell_output: {\n      capacity: inputCell.cell_output.capacity,\n      lock: inputCell.cell_output.lock,\n      type: inputCell.cell_output.type,\n    },\n    data: inputCell.data,\n  };\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(outputCell);\n  });\n\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      `SECP256K1_BLAKE160_MULTISIG script not defined in config!`\n    );\n  }\n\n  const scriptOutPoint: OutPoint = {\n    tx_hash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  // add cell dep\n  txSkeleton = addCellDep(txSkeleton, {\n    out_point: scriptOutPoint,\n    dep_type: template.DEP_TYPE,\n  });\n\n  // add witness\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    const firstIndexWitness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n    // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness\n    if (firstIndexWitness === \"0x\" && typeof fromInfo !== \"object\") {\n      throw new Error(\"`fromInfo` must be MultisigScript format!\");\n    }\n\n    // if using MultisigScript, check witnesses\n    if (typeof fromInfo === \"object\") {\n      const multisigScript: HexString = parseFromInfo(fromInfo, { config })\n        .multisigScript!;\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = new core.WitnessArgs(new Reader(witness));\n        const lock = witnessArgs.getLock();\n        if (\n          lock.hasValue() &&\n          new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.getInputType();\n        if (inputType.hasValue()) {\n          newWitnessArgs.input_type = new Reader(\n            inputType.value().raw()\n          ).serializeJson();\n        }\n        const outputType = witnessArgs.getOutputType();\n        if (outputType.hasValue()) {\n          newWitnessArgs.output_type = new Reader(\n            outputType.value().raw()\n          ).serializeJson();\n        }\n      }\n      witness = new Reader(\n        core.SerializeWitnessArgs(\n          normalizers.NormalizeWitnessArgs(newWitnessArgs)\n        )\n      ).serializeJson();\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n\n  return txSkeleton;\n}\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\n/**\n * transfer capacity from multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript\n * @param toAddress\n * @param amount transfer CKB capacity in shannon.\n * @param options\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfo,\n    toAddress,\n    amount,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      \"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\"\n    );\n  }\n  const scriptOutPoint: OutPoint = {\n    tx_hash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  txSkeleton = addCellDep(txSkeleton, {\n    out_point: scriptOutPoint,\n    dep_type: template.DEP_TYPE,\n  });\n\n  const { fromScript, multisigScript } = parseFromInfo(fromInfo, { config });\n\n  ensureScript(fromScript, config, \"SECP256K1_BLAKE160_MULTISIG\");\n\n  const noMultisigBefore = !txSkeleton.get(\"inputs\").find((i) => {\n    return new ScriptValue(i.cell_output.lock, { validate: false }).equals(\n      new ScriptValue(fromScript!, { validate: false })\n    );\n  });\n\n  if (noMultisigBefore && fromInfo === \"string\") {\n    throw new Error(\"MultisigScript is required for witness!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = amount ? BI.from(amount) : BI.from(0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cell_output: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        out_point: undefined,\n        block_hash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cell_output.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cell_output.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cell_output.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    // TODO: ignore locktime now.\n    const cellCollector = cellProvider.collector({\n      lock: fromScript,\n    });\n    const changeCell: Cell = {\n      cell_output: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      out_point: undefined,\n      block_hash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.out_point!.tx_hash}_${input.out_point!.index}`\n      );\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`\n        )\n      ) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", (inputs) =>\n        inputs.push(inputCell)\n      );\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n      const inputCapacity = BI.from(inputCell.cell_output.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cell_output.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (BI.from(firstIndex).gte(txSkeleton.get(\"witnesses\").size)) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    // if using MultisigScript, check witnesses\n    if (noMultisigBefore || typeof fromInfo !== \"string\") {\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript!.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = new core.WitnessArgs(new Reader(witness));\n        const lock = witnessArgs.getLock();\n        if (\n          lock.hasValue() &&\n          new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.getInputType();\n        if (inputType.hasValue()) {\n          newWitnessArgs.input_type = new Reader(\n            inputType.value().raw()\n          ).serializeJson();\n        }\n        const outputType = witnessArgs.getOutputType();\n        if (outputType.hasValue()) {\n          newWitnessArgs.output_type = new Reader(\n            outputType.value().raw()\n          ).serializeJson();\n        }\n      }\n      witness = new Reader(\n        core.SerializeWitnessArgs(\n          normalizers.NormalizeWitnessArgs(newWitnessArgs)\n        )\n      ).serializeJson();\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount fee in shannon\n * @param options\n */\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  amount: BIish,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  return transferCompatible(txSkeleton, fromInfo, undefined, amount, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * Inject capacity from `fromInfo` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromInfo\n * @param options\n */\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cell_output.capacity\n  );\n  return transferCompatible(txSkeleton, fromInfo, undefined, capacity, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n\n  return _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n}\n\nexport default {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  serializeMultisigScript,\n  multisigArgs,\n  injectCapacity,\n  setupInputCell,\n  CellCollector,\n};\n"],"file":"secp256k1_blake160_multisig.js"}