{"version":3,"sources":["../src/dao.ts"],"names":["toBigUInt64LE","readBigUInt64LE","utils","parseSince","sinceUtils","DEPOSIT_DAO_DATA","DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE","BI","from","CellCollector","constructor","fromInfo","cellProvider","cellType","config","undefined","Error","fromScript","daoTypeScript","data","cellCollector","collector","lock","type","collect","inputCell","listDaoCells","fromAddress","cell","deposit","txSkeleton","toAddress","amount","DAO_SCRIPT","SCRIPTS","DAO","_checkFromInfoSince","_addDaoCellDep","toScript","code_hash","CODE_HASH","hash_type","HASH_TYPE","args","update","outputs","push","cell_output","capacity","toString","out_point","block_hash","outputIndex","get","size","fixedEntries","field","index","secp256k1Blake160","injectCapacity","secp256k1Blake160Multisig","since","length","slice","relative","withdraw","fromInput","_checkDaoScript","typeScript","fromLockScript","setupInputCell","targetOutputIndex","targetOutput","clonedTargetOutput","JSON","parse","stringify","block_number","headerDeps","parseEpochCompatible","epoch","_epoch","shr","and","number","epochSinceCompatible","_length","_index","_number","shl","add","unlock","depositInput","withdrawInput","RpcClient","RPC","rpc","uri","withdrawTypeScript","depositBlockHeader","get_header","depositEpoch","withdrawBlockHeader","withdrawEpoch","withdrawFraction","mul","depositFraction","depositedEpochs","sub","gt","lockEpochs","div","minimalSinceEpoch","minimalSince","outputCapacity","calculateMaximumWithdrawCompatible","dao","witnesses","depositHeaderDepIndex","defaultWitnessArgs","input_type","defaultWitness","Reader","core","SerializeWitnessArgs","normalizers","NormalizeWitnessArgs","serializeJson","lastOutputIndex","remove","calculateDaoEarliestSince","depositBlockHeaderEpoch","withdrawBlockHeaderEpoch","result","calculateDaoEarliestSinceCompatible","BigInt","template","tx_hash","TX_HASH","INDEX","dep_type","DEP_TYPE","extractDaoDataCompatible","test","len","hex","startsWith","map","key","i","reduce","c","calculateMaximumWithdraw","withdrawCell","depositDao","withdrawDao","toBigInt","depositAR","ar","withdrawAR","occupiedCapacity","countedCapacity","withdrawCountedCapacity"],"mappings":";;;;;;;;;;;;;;;AAAA;;AAOA;;AAaA;;AAGA;;AACA;;AACA;;AACA;;AACA;;AAMA;;AACA;;AACA;;;;AAdA,MAAM;AAAEA,EAAAA,aAAF;AAAiBC,EAAAA;AAAjB,IAAqCC,WAA3C;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAiBC,WAAvB;AAeA,MAAMC,gBAA2B,GAAG,oBAApC;;AACA,MAAMC,iCAAiC,GAAGC,OAAGC,IAAH,CAAQ,GAAR,CAA1C;;AAEO,MAAMC,aAAN,CAAsD;AAI3DC,EAAAA,WAAW,CACTC,QADS,EAETC,YAFS,EAGTC,QAHS,EAIT;AAAEC,IAAAA,MAAM,GAAGC;AAAX,MAAkC,EAJzB,EAKT;AACA,QAAI,CAACH,YAAL,EAAmB;AACjB,YAAM,IAAII,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAEDF,IAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AAEA,UAAMG,UAAU,GAAG,8BAAcN,QAAd,EAAwB;AAAEG,MAAAA;AAAF,KAAxB,EAAoCG,UAAvD;AACA,UAAMC,aAAa,GAAG,+BAAkBJ,MAAlB,CAAtB;AACA,UAAMK,IAAwB,GAC5BN,QAAQ,KAAK,SAAb,GAAyBR,gBAAzB,GAA4C,KAD9C;AAEA,SAAKQ,QAAL,GAAgBA,QAAhB;AAEA,SAAKO,aAAL,GAAqBR,YAAY,CAACS,SAAb,CAAuB;AAC1CC,MAAAA,IAAI,EAAEL,UADoC;AAE1CM,MAAAA,IAAI,EAAEL,aAFoC;AAG1CC,MAAAA;AAH0C,KAAvB,CAArB;AAKD;;AAEa,SAAPK,OAAO,GAAyB;AACrC,eAAW,MAAMC,SAAjB,IAA8B,KAAKL,aAAL,CAAmBI,OAAnB,EAA9B,EAA4D;AAC1D,UAAI,KAAKX,QAAL,KAAkB,UAAlB,IAAgCY,SAAS,CAACN,IAAV,KAAmBd,gBAAvD,EAAyE;AACvE;AACD;;AAED,YAAMoB,SAAN;AACD;AACF;;AArC0D;AAwC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACO,gBAAgBC,YAAhB,CACLd,YADK,EAELe,WAFK,EAGLd,QAHK,EAIL;AAAEC,EAAAA,MAAM,GAAGC;AAAX,IAAkC,EAJ7B,EAKgB;AACrB,QAAMM,SAAS,GAAG,IAAIZ,aAAJ,CAAkBkB,WAAlB,EAA+Bf,YAA/B,EAA6CC,QAA7C,EAAuD;AACvEC,IAAAA;AADuE,GAAvD,CAAlB;;AAIA,aAAW,MAAMc,IAAjB,IAAyBP,SAAS,CAACG,OAAV,EAAzB,EAA8C;AAC5C,UAAMI,IAAN;AACD;AACF,C,CAED;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAeC,OAAf,CACLC,UADK,EAELnB,QAFK,EAGLoB,SAHK,EAILC,MAJK,EAKL;AAAElB,EAAAA,MAAM,GAAGC;AAAX,IAAkC,EAL7B,EAM6B;AAClCD,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AACA,QAAMmB,UAAU,GAAGnB,MAAM,CAACoB,OAAP,CAAeC,GAAlC;;AACA,MAAI,CAACF,UAAL,EAAiB;AACf,UAAM,IAAIjB,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAEDoB,EAAAA,mBAAmB,CAACzB,QAAD,EAAWG,MAAX,CAAnB,CAPkC,CASlC;;;AACAgB,EAAAA,UAAU,GAAGO,cAAc,CAACP,UAAD,EAAahB,MAAb,CAA3B;;AAEA,MAAI,CAACiB,SAAL,EAAgB;AACd,UAAM,IAAIf,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,QAAMsB,QAAQ,GAAG,2BAAaP,SAAb,EAAwB;AAAEjB,IAAAA;AAAF,GAAxB,CAAjB;AACA,QAAMI,aAAa,GAAG;AACpBqB,IAAAA,SAAS,EAAEN,UAAU,CAACO,SADF;AAEpBC,IAAAA,SAAS,EAAER,UAAU,CAACS,SAFF;AAGpBC,IAAAA,IAAI,EAAE;AAHc,GAAtB;AAMAb,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACC,IAAR,CAAa;AAClBC,MAAAA,WAAW,EAAE;AACXC,QAAAA,QAAQ,EAAE,OAAOzC,OAAGC,IAAH,CAAQwB,MAAR,EAAgBiB,QAAhB,CAAyB,EAAzB,CADN;AAEX3B,QAAAA,IAAI,EAAEgB,QAFK;AAGXf,QAAAA,IAAI,EAAEL;AAHK,OADK;AAMlBC,MAAAA,IAAI,EAAEd,gBANY;AAOlB6C,MAAAA,SAAS,EAAEnC,SAPO;AAQlBoC,MAAAA,UAAU,EAAEpC;AARM,KAAb,CAAP;AAUD,GAXY,CAAb;AAaA,QAAMqC,WAAW,GAAGtB,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAA1B,GAAiC,CAArD,CApCkC,CAsClC;;AACAxB,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,cAAlB,EAAmCW,YAAD,IAAkB;AAC/D,WAAOA,YAAY,CAACT,IAAb,CAAkB;AACvBU,MAAAA,KAAK,EAAE,SADgB;AAEvBC,MAAAA,KAAK,EAAEL;AAFgB,KAAlB,CAAP;AAID,GALY,CAAb;;AAOA,MAAI,OAAOzC,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAMM,UAAU,GAAG,2BAAaN,QAAb,EAAuB;AAAEG,MAAAA;AAAF,KAAvB,CAAnB,CADgC,CAEhC;;AACA,QAAI,uCAA0BG,UAA1B,EAAsCH,MAAtC,CAAJ,EAAmD;AACjDgB,MAAAA,UAAU,GAAG,MAAM4B,yBAAkBC,cAAlB,CACjB7B,UADiB,EAEjBsB,WAFiB,EAGjBzC,QAHiB,EAIjB;AAAEG,QAAAA;AAAF,OAJiB,CAAnB;AAMD,KAPD,MAOO,IAAI,+CAAkCG,UAAlC,EAA8CH,MAA9C,CAAJ,EAA2D;AAChEgB,MAAAA,UAAU,GAAG,MAAM8B,qCAA0BD,cAA1B,CACjB7B,UADiB,EAEjBsB,WAFiB,EAGjBzC,QAHiB,EAIjB;AAAEG,QAAAA;AAAF,OAJiB,CAAnB;AAMD;AACF,GAlBD,MAkBO,IAAIH,QAAJ,EAAc;AACnBmB,IAAAA,UAAU,GAAG,MAAM8B,qCAA0BD,cAA1B,CACjB7B,UADiB,EAEjBsB,WAFiB,EAGjBzC,QAHiB,EAIjB;AAAEG,MAAAA;AAAF,KAJiB,CAAnB;AAMD;;AAED,SAAOgB,UAAP;AACD;;AAED,SAASM,mBAAT,CAA6BzB,QAA7B,EAAiDG,MAAjD,EAAuE;AACrE,MAAI+C,KAAJ;;AACA,MAAI,OAAOlD,QAAP,KAAoB,QAAxB,EAAkC;AAChC;AACA,UAAMM,UAAU,GAAG,2BAAaN,QAAb,EAAuB;AAAEG,MAAAA;AAAF,KAAvB,CAAnB;AACA,UAAM6B,IAAI,GAAG1B,UAAU,CAAC0B,IAAxB;;AACA,QAAIA,IAAI,CAACmB,MAAL,KAAgB,EAApB,EAAwB;AACtBD,MAAAA,KAAK,GAAG,OAAO5D,eAAe,CAAC,OAAO0C,IAAI,CAACoB,KAAL,CAAW,EAAX,CAAR,CAAf,CAAuCd,QAAvC,CAAgD,EAAhD,CAAf;AACD;AACF,GAPD,MAOO,IAAI,OAAOtC,QAAX,EAAqB;AAC1BkD,IAAAA,KAAK,GAAGlD,QAAQ,CAACkD,KAAjB;AACD;;AAED,MAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,UAAM;AAAEG,MAAAA,QAAF;AAAYzC,MAAAA;AAAZ,QAAqBpB,UAAU,CAAC0D,KAAD,CAArC;;AACA,QAAI,EAAE,CAACG,QAAD,IAAazC,IAAI,KAAK,aAAxB,CAAJ,EAA4C;AAC1C,YAAM,IAAIP,KAAJ,CACJ,+FADI,CAAN;AAGD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeiD,QAAf,CACEnC,UADF,EAEEoC,SAFF,EAGEvD,QAHF,EAIE;AAAEG,EAAAA,MAAM,GAAGC;AAAX,IAAkC,EAJpC,EAKoC;AAClCD,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;;AACAqD,EAAAA,eAAe,CAACrD,MAAD,CAAf;;AACAgB,EAAAA,UAAU,GAAGO,cAAc,CAACP,UAAD,EAAahB,MAAb,CAA3B,CAHkC,CAKlC;;AACA,MAAIgB,UAAU,CAACuB,GAAX,CAAe,QAAf,EAAyBC,IAAzB,KAAkCxB,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAAhE,EAAsE;AACpE,UAAM,IAAItC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,MAAI,CAACF,MAAM,CAACoB,OAAP,CAAeC,GAApB,EAAyB;AACvB,UAAM,IAAInB,KAAJ,CAAU,iDAAV,CAAN;AACD,GAZiC,CAclC;;;AAEA,QAAMJ,YAAY,GAAGkB,UAAU,CAACuB,GAAX,CAAe,cAAf,CAArB;;AACA,MAAI,CAACzC,YAAL,EAAmB;AACjB,UAAM,IAAII,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,QAAMoD,UAAU,GAAGF,SAAS,CAACnB,WAAV,CAAsBxB,IAAzC;AACA,QAAMU,UAAU,GAAGnB,MAAM,CAACoB,OAAP,CAAeC,GAAlC;;AACA,MACE,CAACiC,UAAD,IACAA,UAAU,CAAC7B,SAAX,KAAyBN,UAAU,CAACO,SADpC,IAEA4B,UAAU,CAAC3B,SAAX,KAAyBR,UAAU,CAACS,SAFpC,IAGAwB,SAAS,CAAC/C,IAAV,KAAmBd,gBAJrB,EAKE;AACA,UAAM,IAAIW,KAAJ,CAAU,sCAAV,CAAN;AACD,GA7BiC,CA+BlC;;;AACA,QAAMqD,cAAc,GAAGH,SAAS,CAACnB,WAAV,CAAsBzB,IAA7C;;AACA,MAAI,uCAA0B+C,cAA1B,EAA0CvD,MAA1C,CAAJ,EAAuD;AACrDgB,IAAAA,UAAU,GAAG,MAAM4B,yBAAkBY,cAAlB,CACjBxC,UADiB,EAEjBoC,SAFiB,EAGjBnD,SAHiB,EAIjB;AACED,MAAAA;AADF,KAJiB,CAAnB;AAQD,GATD,MASO,IAAI,+CAAkCuD,cAAlC,EAAkDvD,MAAlD,CAAJ,EAA+D;AACpEgB,IAAAA,UAAU,GAAG,MAAM8B,qCAA0BU,cAA1B,CACjBxC,UADiB,EAEjBoC,SAFiB,EAGjBvD,QAAQ,IAAI,8BAAgB0D,cAAhB,EAAgC;AAAEvD,MAAAA;AAAF,KAAhC,CAHK,EAIjB;AAAEA,MAAAA;AAAF,KAJiB,CAAnB;AAMD;;AAED,QAAMyD,iBAAyB,GAAGzC,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAA1B,GAAiC,CAAnE;AACA,QAAMkB,YAAkB,GAAG1C,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BkB,iBAA9B,CAA3B;AACA,QAAME,kBAAwB,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeJ,YAAf,CAAX,CAAjC;AACAC,EAAAA,kBAAkB,CAACtD,IAAnB,GAA0BnB,aAAa,CAACO,OAAGC,IAAH,CAAQ0D,SAAS,CAACW,YAAlB,CAAD,CAAvC;AACA/C,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACD,MAAR,CAAe2B,iBAAf,EAAkC,MAAME,kBAAxC,CAAP;AACD,GAFY,CAAb,CAvDkC,CA2DlC;;AACA3C,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,YAAlB,EAAiCkC,UAAD,IAAgB;AAC3D,WAAOA,UAAU,CAAChC,IAAX,CAAgBoB,SAAS,CAACf,UAA1B,CAAP;AACD,GAFY,CAAb,CA5DkC,CAgElC;;AACArB,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,cAAlB,EAAmCW,YAAD,IAAkB;AAC/D,WAAOA,YAAY,CAACT,IAAb,CACL;AACEU,MAAAA,KAAK,EAAE,QADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,QAAf,EAAyBC,IAAzB,GAAgC;AAFzC,KADK,EAKL;AACEE,MAAAA,KAAK,EAAE,SADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAA1B,GAAiC;AAF1C,KALK,CAAP;AAUD,GAXY,CAAb;AAaA,SAAOxB,UAAP;AACD;;AAED,SAASiD,oBAAT,CACEC,KADF,EAME;AACA,QAAMC,MAAM,GAAG1E,OAAGC,IAAH,CAAQwE,KAAR,CAAf;;AACA,SAAO;AACLlB,IAAAA,MAAM,EAAEmB,MAAM,CAACC,GAAP,CAAW,EAAX,EAAeC,GAAf,CAAmB,KAAnB,CADH;AAEL1B,IAAAA,KAAK,EAAEwB,MAAM,CAACC,GAAP,CAAW,EAAX,EAAeC,GAAf,CAAmB,KAAnB,CAFF;AAGLC,IAAAA,MAAM,EAAEH,MAAM,CAACE,GAAP,CAAW,QAAX;AAHH,GAAP;AAKD;;AAED,SAASE,oBAAT,CAA8B;AAC5BvB,EAAAA,MAD4B;AAE5BL,EAAAA,KAF4B;AAG5B2B,EAAAA;AAH4B,CAA9B,EAQO;AACL,QAAME,OAAO,GAAG/E,OAAGC,IAAH,CAAQsD,MAAR,CAAhB;;AACA,QAAMyB,MAAM,GAAGhF,OAAGC,IAAH,CAAQiD,KAAR,CAAf;;AACA,QAAM+B,OAAO,GAAGjF,OAAGC,IAAH,CAAQ4E,MAAR,CAAhB;;AACA,SAAO7E,OAAGC,IAAH,CAAQ,IAAR,EACJiF,GADI,CACA,EADA,EAEJC,GAFI,CAEAJ,OAAO,CAACG,GAAR,CAAY,EAAZ,CAFA,EAGJC,GAHI,CAGAH,MAAM,CAACE,GAAP,CAAW,EAAX,CAHA,EAIJC,GAJI,CAIAF,OAJA,CAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAeG,MAAf,CACL7D,UADK,EAEL8D,YAFK,EAGLC,aAHK,EAIL9D,SAJK,EAKLpB,QALK,EAML;AACEG,EAAAA,MAAM,GAAGC,SADX;AAEE+E,EAAAA,SAAS,GAAGC;AAFd,IAG0C,EATrC,EAUL;AACAjF,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;;AACAqD,EAAAA,eAAe,CAACrD,MAAD,CAAf;;AACAgB,EAAAA,UAAU,GAAGO,cAAc,CAACP,UAAD,EAAahB,MAAb,CAA3B;;AAEA,MAAI,CAACA,MAAM,CAACoB,OAAP,CAAeC,GAApB,EAAyB;AACvB,UAAM,IAAInB,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAED,QAAMJ,YAAY,GAAGkB,UAAU,CAACuB,GAAX,CAAe,cAAf,CAArB;;AACA,MAAI,CAACzC,YAAL,EAAmB;AACjB,UAAM,IAAII,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,QAAMgF,GAAG,GAAG,IAAIF,SAAJ,CAAclF,YAAY,CAACqF,GAA3B,CAAZ;AAEA,QAAM7B,UAAU,GAAGwB,YAAY,CAAC7C,WAAb,CAAyBxB,IAA5C;AACA,QAAMU,UAAU,GAAGnB,MAAM,CAACoB,OAAP,CAAeC,GAAlC;;AACA,MACE,CAACiC,UAAD,IACAA,UAAU,CAAC7B,SAAX,KAAyBN,UAAU,CAACO,SADpC,IAEA4B,UAAU,CAAC3B,SAAX,KAAyBR,UAAU,CAACS,SAFpC,IAGAkD,YAAY,CAACzE,IAAb,KAAsBd,gBAJxB,EAKE;AACA,UAAM,IAAIW,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,QAAMkF,kBAAkB,GAAGL,aAAa,CAAC9C,WAAd,CAA0BxB,IAArD;;AACA,MACE,CAAC2E,kBAAD,IACAA,kBAAkB,CAAC3D,SAAnB,KAAiCN,UAAU,CAACO,SAD5C,IAEA0D,kBAAkB,CAACzD,SAAnB,KAAiCR,UAAU,CAACS,SAF5C,IAGAmD,aAAa,CAAC1E,IAAd,KAAuBd,gBAJzB,EAKE;AACA,UAAM,IAAIW,KAAJ,CAAU,2CAAV,CAAN;AACD,GAlCD,CAoCA;;;AACA,QAAMmF,kBAAkB,GAAG,MAAMH,GAAG,CAACI,UAAJ,CAAeR,YAAY,CAACzC,UAA5B,CAAjC;AACA,QAAMkD,YAAY,GAAGtB,oBAAoB,CAACoB,kBAAkB,CAAEnB,KAArB,CAAzC,CAtCA,CAuCA;;AAEA,QAAMsB,mBAAmB,GAAG,MAAMN,GAAG,CAACI,UAAJ,CAAeP,aAAa,CAAC1C,UAA7B,CAAlC;AACA,QAAMoD,aAAa,GAAGxB,oBAAoB,CAACuB,mBAAmB,CAAEtB,KAAtB,CAA1C;AAEA,QAAMwB,gBAAgB,GAAGD,aAAa,CAAC9C,KAAd,CAAoBgD,GAApB,CAAwBJ,YAAY,CAACvC,MAArC,CAAzB;AACA,QAAM4C,eAAe,GAAGL,YAAY,CAAC5C,KAAb,CAAmBgD,GAAnB,CAAuBF,aAAa,CAACzC,MAArC,CAAxB;AACA,MAAI6C,eAAe,GAAGJ,aAAa,CAACnB,MAAd,CAAqBwB,GAArB,CAAyBP,YAAY,CAACjB,MAAtC,CAAtB;;AAEA,MAAIoB,gBAAgB,CAACK,EAAjB,CAAoBH,eAApB,CAAJ,EAA0C;AACxCC,IAAAA,eAAe,GAAGA,eAAe,CAACjB,GAAhB,CAAoB,CAApB,CAAlB;AACD;;AAED,QAAMoB,UAAU,GAAGH,eAAe,CAC/BjB,GADgB,CACZpF,iCADY,EAEhBsG,GAFgB,CAEZ,CAFY,EAGhBG,GAHgB,CAGZzG,iCAHY,EAIhBmG,GAJgB,CAIZnG,iCAJY,CAAnB;AAKA,QAAM0G,iBAAiB,GAAG;AACxB5B,IAAAA,MAAM,EAAE7E,OAAGC,IAAH,CAAQ6F,YAAY,CAACjB,MAAb,CAAoBM,GAApB,CAAwBoB,UAAxB,CAAR,CADgB;AAExBrD,IAAAA,KAAK,EAAElD,OAAGC,IAAH,CAAQ6F,YAAY,CAAC5C,KAArB,CAFiB;AAGxBK,IAAAA,MAAM,EAAEvD,OAAGC,IAAH,CAAQ6F,YAAY,CAACvC,MAArB;AAHgB,GAA1B;AAKA,QAAMmD,YAAY,GAAG5B,oBAAoB,CAAC2B,iBAAD,CAAzC;AAEA,QAAME,cAAyB,GAC7B,OACAC,kCAAkC,CAChCtB,aADgC,EAEhCM,kBAAkB,CAAEiB,GAFY,EAGhCd,mBAAmB,CAAEc,GAHW,CAAlC,CAIEnE,QAJF,CAIW,EAJX,CAFF;AAQA,QAAMX,QAAQ,GAAG,2BAAaP,SAAb,EAAwB;AAAEjB,IAAAA;AAAF,GAAxB,CAAjB;AACAgB,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACC,IAAR,CAAa;AAClBC,MAAAA,WAAW,EAAE;AACXC,QAAAA,QAAQ,EAAEkE,cADC;AAEX5F,QAAAA,IAAI,EAAEgB,QAFK;AAGXf,QAAAA,IAAI,EAAER;AAHK,OADK;AAMlBI,MAAAA,IAAI,EAAE,IANY;AAOlB+B,MAAAA,SAAS,EAAEnC,SAPO;AAQlBoC,MAAAA,UAAU,EAAEpC;AARM,KAAb,CAAP;AAUD,GAXY,CAAb;AAaA,QAAM8C,KAAkB,GAAG,OAAOoD,YAAY,CAAChE,QAAb,CAAsB,EAAtB,CAAlC;;AAEA,SAAOnB,UAAU,CAACuB,GAAX,CAAe,WAAf,EAA4BC,IAA5B,GAAmCxB,UAAU,CAACuB,GAAX,CAAe,QAAf,EAAyBC,IAAzB,GAAgC,CAA1E,EAA6E;AAC3ExB,IAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,WAAlB,EAAgCyE,SAAD,IAC1CA,SAAS,CAACvE,IAAV,CAAe,IAAf,CADW,CAAb;AAGD,GA5FD,CA8FA;;;AACAhB,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,YAAlB,EAAiCkC,UAAD,IAAgB;AAC3D,WAAOA,UAAU,CAAChC,IAAX,CAAgB8C,YAAY,CAACzC,UAA7B,EAA0C0C,aAAa,CAAC1C,UAAxD,CAAP;AACD,GAFY,CAAb;AAIA,QAAMmE,qBAAqB,GAAGxF,UAAU,CAACuB,GAAX,CAAe,YAAf,EAA6BC,IAA7B,GAAoC,CAAlE,CAnGA,CAqGA;;AACA,QAAMiE,kBAA+B,GAAG;AACtCC,IAAAA,UAAU,EAAExH,aAAa,CAACsH,qBAAD;AADa,GAAxC;AAGA,QAAMG,cAAyB,GAAG,IAAIC,eAAJ,CAChCC,WAAKC,oBAAL,CACEC,qBAAYC,oBAAZ,CAAiCP,kBAAjC,CADF,CADgC,EAIhCQ,aAJgC,EAAlC;AAKA,QAAM1D,cAAc,GAAGwB,aAAa,CAAC9C,WAAd,CAA0BzB,IAAjD;;AACA,MAAI,uCAA0B+C,cAA1B,EAA0CvD,MAA1C,CAAJ,EAAuD;AACrDgB,IAAAA,UAAU,GAAG,MAAM4B,yBAAkBY,cAAlB,CACjBxC,UADiB,EAEjB+D,aAFiB,EAGjB9E,SAHiB,EAIjB;AAAED,MAAAA,MAAF;AAAU+C,MAAAA,KAAV;AAAiB4D,MAAAA;AAAjB,KAJiB,CAAnB;AAMD,GAPD,MAOO,IAAI,+CAAkCpD,cAAlC,EAAkDvD,MAAlD,CAAJ,EAA+D;AACpEgB,IAAAA,UAAU,GAAG,MAAM8B,qCAA0BU,cAA1B,CACjBxC,UADiB,EAEjB+D,aAFiB,EAGjBlF,QAAQ,IAAI,8BAAgB0D,cAAhB,EAAgC;AAAEvD,MAAAA;AAAF,KAAhC,CAHK,EAIjB;AAAEA,MAAAA,MAAF;AAAU+C,MAAAA,KAAV;AAAiB4D,MAAAA;AAAjB,KAJiB,CAAnB;AAMD,GA7HD,CA8HA;;;AACA,QAAMO,eAAuB,GAAGlG,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAA1B,GAAiC,CAAjE;AACAxB,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACoF,MAAR,CAAeD,eAAf,CAAP;AACD,GAFY,CAAb,CAhIA,CAoIA;;AACAlG,EAAAA,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkB,cAAlB,EAAmCW,YAAD,IAAkB;AAC/D,WAAOA,YAAY,CAACT,IAAb,CACL;AACEU,MAAAA,KAAK,EAAE,QADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,QAAf,EAAyBC,IAAzB,GAAgC;AAFzC,KADK,EAKL;AACEE,MAAAA,KAAK,EAAE,SADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,SAAf,EAA0BC,IAA1B,GAAiC;AAF1C,KALK,EASL;AACEE,MAAAA,KAAK,EAAE,WADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,WAAf,EAA4BC,IAA5B,GAAmC;AAF5C,KATK,EAaL;AACEE,MAAAA,KAAK,EAAE,YADT;AAEEC,MAAAA,KAAK,EAAE3B,UAAU,CAACuB,GAAX,CAAe,YAAf,EAA6BC,IAA7B,GAAoC;AAF7C,KAbK,CAAP;AAkBD,GAnBY,CAAb;AAqBA,SAAOxB,UAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASoG,yBAAT,CACLC,uBADK,EAELC,wBAFK,EAGG;AACR,QAAMC,MAAM,GAAGC,mCAAmC,CAChDH,uBADgD,EAEhDC,wBAFgD,CAAlD;AAIA,SAAOG,MAAM,CAACF,MAAM,CAACpF,QAAP,EAAD,CAAb;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASqF,mCAAT,CACLH,uBADK,EAELC,wBAFK,EAGD;AACJ,QAAM/B,YAAY,GAAGtB,oBAAoB,CAACoD,uBAAD,CAAzC;AACA,QAAM5B,aAAa,GAAGxB,oBAAoB,CAACqD,wBAAD,CAA1C;AACA,QAAM5B,gBAAgB,GAAGD,aAAa,CAAC9C,KAAd,CAAoBgD,GAApB,CAAwBJ,YAAY,CAACvC,MAArC,CAAzB;AACA,QAAM4C,eAAe,GAAGL,YAAY,CAAC5C,KAAb,CAAmBgD,GAAnB,CAAuBF,aAAa,CAACzC,MAArC,CAAxB;AACA,MAAI6C,eAAe,GAAGJ,aAAa,CAACnB,MAAd,CAAqBwB,GAArB,CAAyBP,YAAY,CAACjB,MAAtC,CAAtB;;AAEA,MAAIoB,gBAAgB,CAACK,EAAjB,CAAoBH,eAApB,CAAJ,EAA0C;AACxCC,IAAAA,eAAe,GAAGA,eAAe,CAACjB,GAAhB,CAAoB,CAApB,CAAlB;AACD;;AAED,QAAMoB,UAAU,GAAGH,eAAe,CAC/BjB,GADgB,CACZpF,iCADY,EAEhBsG,GAFgB,CAEZ,CAFY,EAGhBG,GAHgB,CAGZzG,iCAHY,EAIhBmG,GAJgB,CAIZnG,iCAJY,CAAnB;AAKA,QAAM0G,iBAAiB,GAAG;AACxB5B,IAAAA,MAAM,EAAE7E,OAAGC,IAAH,CAAQ6F,YAAY,CAACjB,MAAb,CAAoBM,GAApB,CAAwBoB,UAAxB,CAAR,CADgB;AAExBrD,IAAAA,KAAK,EAAElD,OAAGC,IAAH,CAAQ6F,YAAY,CAAC5C,KAArB,CAFiB;AAGxBK,IAAAA,MAAM,EAAEvD,OAAGC,IAAH,CAAQ6F,YAAY,CAACvC,MAArB;AAHgB,GAA1B;AAKA,SAAOuB,oBAAoB,CAAC2B,iBAAD,CAA3B;AACD;;AAED,SAAS7C,eAAT,CAAyBrD,MAAzB,EAA+C;AAC7C,QAAMmB,UAAU,GAAGnB,MAAM,CAACoB,OAAP,CAAeC,GAAlC;;AACA,MAAI,CAACF,UAAL,EAAiB;AACf,UAAM,IAAIjB,KAAJ,CAAU,iDAAV,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqB,cAAT,CACEP,UADF,EAEEhB,MAFF,EAG2B;AACzB,QAAM0H,QAAQ,GAAG1H,MAAM,CAACoB,OAAP,CAAeC,GAAhC;AACA,SAAO,wBAAWL,UAAX,EAAuB;AAC5BoB,IAAAA,SAAS,EAAE;AACTuF,MAAAA,OAAO,EAAED,QAAQ,CAACE,OADT;AAETjF,MAAAA,KAAK,EAAE+E,QAAQ,CAACG;AAFP,KADiB;AAK5BC,IAAAA,QAAQ,EAAEJ,QAAQ,CAACK;AALS,GAAvB,CAAP;AAOD;;AAED,SAASC,wBAAT,CACE1B,GADF,EAIE;AACA,MAAI,CAAC,2BAA2B2B,IAA3B,CAAgC3B,GAAhC,CAAL,EAA2C;AACzC,UAAM,IAAIpG,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,QAAMgI,GAAG,GAAG,IAAI,CAAhB;AACA,QAAMC,GAAG,GAAG7B,GAAG,CAAC8B,UAAJ,CAAe,IAAf,IAAuB9B,GAAG,CAACrD,KAAJ,CAAU,CAAV,CAAvB,GAAsCqD,GAAlD;AAEA,SAAO,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,GAAjB,EACJ+B,GADI,CACA,CAACC,GAAD,EAAMC,CAAN,KAAY;AACf,WAAO;AACL,OAACD,GAAD,GAAO7I,OAAGC,IAAH,CACL,sCAA0B,OAAOyI,GAAG,CAAClF,KAAJ,CAAUiF,GAAG,GAAGK,CAAhB,EAAmBL,GAAG,IAAIK,CAAC,GAAG,CAAR,CAAtB,CAAjC,CADK;AADF,KAAP;AAKD,GAPI,EAQJC,MARI,CAQG,CAACjB,MAAD,EAASkB,CAAT,MAAgB,EAAE,GAAGlB,MAAL;AAAa,OAAGkB;AAAhB,GAAhB,CARH,EAQyC,EARzC,CAAP;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,wBAAT,CACLC,YADK,EAELC,UAFK,EAGLC,WAHK,EAIG;AACR,SAAOxC,kCAAkC,CACvCsC,YADuC,EAEvCC,UAFuC,EAGvCC,WAHuC,CAAlC,CAILC,QAJK,EAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASzC,kCAAT,CACLsC,YADK,EAELC,UAFK,EAGLC,WAHK,EAID;AACJ,QAAME,SAAS,GAAGtJ,OAAGC,IAAH,CAAQsI,wBAAwB,CAACY,UAAD,CAAxB,CAAqCI,EAA7C,CAAlB;;AACA,QAAMC,UAAU,GAAGxJ,OAAGC,IAAH,CAAQsI,wBAAwB,CAACa,WAAD,CAAxB,CAAsCG,EAA9C,CAAnB;;AAEA,QAAME,gBAAgB,GAAGzJ,OAAGC,IAAH,CAAQ,4CAA8BiJ,YAA9B,CAAR,CAAzB;;AACA,QAAMvC,cAAc,GAAG3G,OAAGC,IAAH,CAAQiJ,YAAY,CAAC1G,WAAb,CAAyBC,QAAjC,CAAvB;;AACA,QAAMiH,eAAe,GAAG/C,cAAc,CAACN,GAAf,CAAmBoD,gBAAnB,CAAxB;AACA,QAAME,uBAAuB,GAAGD,eAAe,CAC5CxD,GAD6B,CACzBsD,UADyB,EAE7BhD,GAF6B,CAEzB8C,SAFyB,CAAhC;AAIA,SAAOK,uBAAuB,CAACxE,GAAxB,CAA4BsE,gBAA5B,CAAP;AACD;;eAEc;AACbnI,EAAAA,OADa;AAEboC,EAAAA,QAFa;AAGb0B,EAAAA,MAHa;AAIb6D,EAAAA,wBAJa;AAKbrC,EAAAA,kCALa;AAMbe,EAAAA,yBANa;AAObI,EAAAA,mCAPa;AAQb7H,EAAAA,aARa;AASbiB,EAAAA;AATa,C","sourcesContent":["import {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  generateAddress,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport {\n  core,\n  utils,\n  since as sinceUtils,\n  HexString,\n  Address,\n  CellProvider,\n  Cell,\n  WitnessArgs,\n  PackedDao,\n  PackedSince,\n  CellCollector as CellCollectorInterface,\n} from \"@ckb-lumos/base\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nconst { toBigUInt64LE, readBigUInt64LE } = utils;\nconst { parseSince } = sinceUtils;\nimport { normalizers, Reader } from \"@ckb-lumos/toolkit\";\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport secp256k1Blake160Multisig from \"./secp256k1_blake160_multisig\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport {\n  addCellDep,\n  isSecp256k1Blake160Script,\n  isSecp256k1Blake160MultisigScript,\n  generateDaoScript,\n} from \"./helper\";\nimport { RPC } from \"@ckb-lumos/rpc\";\nimport { readBigUInt64LECompatible } from \"@ckb-lumos/base/lib/utils\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\n\nconst DEPOSIT_DAO_DATA: HexString = \"0x0000000000000000\";\nconst DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE = BI.from(180);\n\nexport class CellCollector implements CellCollectorInterface {\n  private cellCollector: CellCollectorInterface;\n  private cellType: \"all\" | \"deposit\" | \"withdraw\";\n\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    cellType: \"all\" | \"deposit\" | \"withdraw\",\n    { config = undefined }: Options = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(\"Cell Provider is missing!\");\n    }\n\n    config = config || getConfig();\n\n    const fromScript = parseFromInfo(fromInfo, { config }).fromScript;\n    const daoTypeScript = generateDaoScript(config);\n    const data: HexString | string =\n      cellType === \"deposit\" ? DEPOSIT_DAO_DATA : \"any\";\n    this.cellType = cellType;\n\n    this.cellCollector = cellProvider.collector({\n      lock: fromScript,\n      type: daoTypeScript,\n      data,\n    });\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    for await (const inputCell of this.cellCollector.collect()) {\n      if (this.cellType === \"withdraw\" && inputCell.data === DEPOSIT_DAO_DATA) {\n        continue;\n      }\n\n      yield inputCell;\n    }\n  }\n}\n\n/**\n * list DAO cells,\n *\n * @param cellProvider\n * @param fromAddress\n * @param cellType\n * @param options\n */\nexport async function* listDaoCells(\n  cellProvider: CellProvider,\n  fromAddress: Address,\n  cellType: \"all\" | \"deposit\" | \"withdraw\",\n  { config = undefined }: Options = {}\n): AsyncIterator<Cell> {\n  const collector = new CellCollector(fromAddress, cellProvider, cellType, {\n    config,\n  });\n\n  for await (const cell of collector.collect()) {\n    yield cell;\n  }\n}\n\n// TODO: reject multisig with non absolute-epoch-number locktime lock\n/**\n * deposit a cell to DAO\n *\n * @param txSkeleton\n * @param fromInfo\n * @param toAddress deposit cell lock address\n * @param amount capacity in shannon\n * @param options\n */\nexport async function deposit(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address,\n  amount: BIish,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!DAO_SCRIPT) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n\n  _checkFromInfoSince(fromInfo, config);\n\n  // check and add cellDep if not exists\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  const toScript = parseAddress(toAddress, { config });\n  const daoTypeScript = {\n    code_hash: DAO_SCRIPT.CODE_HASH,\n    hash_type: DAO_SCRIPT.HASH_TYPE,\n    args: \"0x\",\n  };\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push({\n      cell_output: {\n        capacity: \"0x\" + BI.from(amount).toString(16),\n        lock: toScript,\n        type: daoTypeScript,\n      },\n      data: DEPOSIT_DAO_DATA,\n      out_point: undefined,\n      block_hash: undefined,\n    });\n  });\n\n  const outputIndex = txSkeleton.get(\"outputs\").size - 1;\n\n  // fix entry\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: outputIndex,\n    });\n  });\n\n  if (typeof fromInfo === \"string\") {\n    const fromScript = parseAddress(fromInfo, { config });\n    // address\n    if (isSecp256k1Blake160Script(fromScript, config)) {\n      txSkeleton = await secp256k1Blake160.injectCapacity(\n        txSkeleton,\n        outputIndex,\n        fromInfo,\n        { config }\n      );\n    } else if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n      txSkeleton = await secp256k1Blake160Multisig.injectCapacity(\n        txSkeleton,\n        outputIndex,\n        fromInfo,\n        { config }\n      );\n    }\n  } else if (fromInfo) {\n    txSkeleton = await secp256k1Blake160Multisig.injectCapacity(\n      txSkeleton,\n      outputIndex,\n      fromInfo,\n      { config }\n    );\n  }\n\n  return txSkeleton;\n}\n\nfunction _checkFromInfoSince(fromInfo: FromInfo, config: Config): void {\n  let since;\n  if (typeof fromInfo === \"string\") {\n    // fromInfo is an address\n    const fromScript = parseAddress(fromInfo, { config });\n    const args = fromScript.args;\n    if (args.length === 58) {\n      since = \"0x\" + readBigUInt64LE(\"0x\" + args.slice(42)).toString(16);\n    }\n  } else if (\"R\" in fromInfo) {\n    since = fromInfo.since;\n  }\n\n  if (since != null) {\n    const { relative, type } = parseSince(since);\n    if (!(!relative && type === \"epochNumber\")) {\n      throw new Error(\n        \"Can't deposit a dao cell with multisig locktime which not using absolute-epoch-number format!\"\n      );\n    }\n  }\n}\n\n/**\n * withdraw an deposited DAO cell\n *\n * @param txSkeleton\n * @param fromInput deposited DAO cell\n * @param fromInfo\n * @param options\n */\nasync function withdraw(\n  txSkeleton: TransactionSkeletonType,\n  fromInput: Cell,\n  fromInfo?: FromInfo,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  _checkDaoScript(config);\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n\n  // check inputs.size == outputs.size\n  if (txSkeleton.get(\"inputs\").size !== txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Input size must equals to output size in txSkeleton!\");\n  }\n\n  if (!config.SCRIPTS.DAO) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n\n  // TODO: check fromInput\n\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n  const typeScript = fromInput.cell_output.type;\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (\n    !typeScript ||\n    typeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||\n    typeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||\n    fromInput.data !== DEPOSIT_DAO_DATA\n  ) {\n    throw new Error(\"fromInput is not a DAO deposit cell.\");\n  }\n\n  // setup input cell\n  const fromLockScript = fromInput.cell_output.lock;\n  if (isSecp256k1Blake160Script(fromLockScript, config)) {\n    txSkeleton = await secp256k1Blake160.setupInputCell(\n      txSkeleton,\n      fromInput,\n      undefined,\n      {\n        config,\n      }\n    );\n  } else if (isSecp256k1Blake160MultisigScript(fromLockScript, config)) {\n    txSkeleton = await secp256k1Blake160Multisig.setupInputCell(\n      txSkeleton,\n      fromInput,\n      fromInfo || generateAddress(fromLockScript, { config }),\n      { config }\n    );\n  }\n\n  const targetOutputIndex: number = txSkeleton.get(\"outputs\").size - 1;\n  const targetOutput: Cell = txSkeleton.get(\"outputs\").get(targetOutputIndex)!;\n  const clonedTargetOutput: Cell = JSON.parse(JSON.stringify(targetOutput));\n  clonedTargetOutput.data = toBigUInt64LE(BI.from(fromInput.block_number));\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.update(targetOutputIndex, () => clonedTargetOutput);\n  });\n\n  // add header deps\n  txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n    return headerDeps.push(fromInput.block_hash!);\n  });\n\n  // fix inputs / outputs / witnesses\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: \"inputs\",\n        index: txSkeleton.get(\"inputs\").size - 1,\n      },\n      {\n        field: \"outputs\",\n        index: txSkeleton.get(\"outputs\").size - 1,\n      }\n    );\n  });\n\n  return txSkeleton;\n}\n\nfunction parseEpochCompatible(\n  epoch: BIish\n): {\n  length: BI;\n  index: BI;\n  number: BI;\n} {\n  const _epoch = BI.from(epoch);\n  return {\n    length: _epoch.shr(40).and(0xfff),\n    index: _epoch.shr(24).and(0xfff),\n    number: _epoch.and(0xffffff),\n  };\n}\n\nfunction epochSinceCompatible({\n  length,\n  index,\n  number,\n}: {\n  length: BIish;\n  index: BIish;\n  number: BIish;\n}): BI {\n  const _length = BI.from(length);\n  const _index = BI.from(index);\n  const _number = BI.from(number);\n  return BI.from(0x20)\n    .shl(56)\n    .add(_length.shl(40))\n    .add(_index.shl(24))\n    .add(_number);\n}\n\n/**\n * Unlock a withdrew DAO cell\n *\n * @param txSkeleton\n * @param depositInput deposited DAO cell\n * @param withdrawInput withdrew DAO cell\n * @param toAddress\n * @param fromInfo\n * @param options\n */\nexport async function unlock(\n  txSkeleton: TransactionSkeletonType,\n  depositInput: Cell,\n  withdrawInput: Cell,\n  toAddress: Address,\n  fromInfo: FromInfo,\n  {\n    config = undefined,\n    RpcClient = RPC,\n  }: Options & { RpcClient?: typeof RPC } = {}\n) {\n  config = config || getConfig();\n  _checkDaoScript(config);\n  txSkeleton = _addDaoCellDep(txSkeleton, config);\n\n  if (!config.SCRIPTS.DAO) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n  const rpc = new RpcClient(cellProvider.uri!);\n\n  const typeScript = depositInput.cell_output.type;\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (\n    !typeScript ||\n    typeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||\n    typeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||\n    depositInput.data !== DEPOSIT_DAO_DATA\n  ) {\n    throw new Error(\"depositInput is not a DAO deposit cell.\");\n  }\n\n  const withdrawTypeScript = withdrawInput.cell_output.type;\n  if (\n    !withdrawTypeScript ||\n    withdrawTypeScript.code_hash !== DAO_SCRIPT.CODE_HASH ||\n    withdrawTypeScript.hash_type !== DAO_SCRIPT.HASH_TYPE ||\n    withdrawInput.data === DEPOSIT_DAO_DATA\n  ) {\n    throw new Error(\"withdrawInput is not a DAO withdraw cell.\");\n  }\n\n  // calculate since & capacity (interest)\n  const depositBlockHeader = await rpc.get_header(depositInput.block_hash!);\n  const depositEpoch = parseEpochCompatible(depositBlockHeader!.epoch);\n  // const depositCapacity = BigInt(depositInput.cell_output.capacity)\n\n  const withdrawBlockHeader = await rpc.get_header(withdrawInput.block_hash!);\n  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeader!.epoch);\n\n  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);\n  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);\n  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);\n\n  if (withdrawFraction.gt(depositFraction)) {\n    depositedEpochs = depositedEpochs.add(1);\n  }\n\n  const lockEpochs = depositedEpochs\n    .add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)\n    .sub(1)\n    .div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)\n    .mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);\n  const minimalSinceEpoch = {\n    number: BI.from(depositEpoch.number.add(lockEpochs)),\n    index: BI.from(depositEpoch.index),\n    length: BI.from(depositEpoch.length),\n  };\n  const minimalSince = epochSinceCompatible(minimalSinceEpoch);\n\n  const outputCapacity: HexString =\n    \"0x\" +\n    calculateMaximumWithdrawCompatible(\n      withdrawInput,\n      depositBlockHeader!.dao,\n      withdrawBlockHeader!.dao\n    ).toString(16);\n\n  const toScript = parseAddress(toAddress, { config });\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push({\n      cell_output: {\n        capacity: outputCapacity,\n        lock: toScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      out_point: undefined,\n      block_hash: undefined,\n    });\n  });\n\n  const since: PackedSince = \"0x\" + minimalSince.toString(16);\n\n  while (txSkeleton.get(\"witnesses\").size < txSkeleton.get(\"inputs\").size - 1) {\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n      witnesses.push(\"0x\")\n    );\n  }\n\n  // add header deps\n  txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n    return headerDeps.push(depositInput.block_hash!, withdrawInput.block_hash!);\n  });\n\n  const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n\n  // setup input cell\n  const defaultWitnessArgs: WitnessArgs = {\n    input_type: toBigUInt64LE(depositHeaderDepIndex),\n  };\n  const defaultWitness: HexString = new Reader(\n    core.SerializeWitnessArgs(\n      normalizers.NormalizeWitnessArgs(defaultWitnessArgs)\n    )\n  ).serializeJson();\n  const fromLockScript = withdrawInput.cell_output.lock;\n  if (isSecp256k1Blake160Script(fromLockScript, config)) {\n    txSkeleton = await secp256k1Blake160.setupInputCell(\n      txSkeleton,\n      withdrawInput,\n      undefined,\n      { config, since, defaultWitness }\n    );\n  } else if (isSecp256k1Blake160MultisigScript(fromLockScript, config)) {\n    txSkeleton = await secp256k1Blake160Multisig.setupInputCell(\n      txSkeleton,\n      withdrawInput,\n      fromInfo || generateAddress(fromLockScript, { config }),\n      { config, since, defaultWitness }\n    );\n  }\n  // remove change output by setupInputCell\n  const lastOutputIndex: number = txSkeleton.get(\"outputs\").size - 1;\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.remove(lastOutputIndex);\n  });\n\n  // fix inputs / outputs / witnesses\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push(\n      {\n        field: \"inputs\",\n        index: txSkeleton.get(\"inputs\").size - 1,\n      },\n      {\n        field: \"outputs\",\n        index: txSkeleton.get(\"outputs\").size - 1,\n      },\n      {\n        field: \"witnesses\",\n        index: txSkeleton.get(\"witnesses\").size - 1,\n      },\n      {\n        field: \"headerDeps\",\n        index: txSkeleton.get(\"headerDeps\").size - 2,\n      }\n    );\n  });\n\n  return txSkeleton;\n}\n\n/**\n * calculate a withdraw dao cell minimal unlock since\n *\n * @param depositBlockHeaderEpoch depositBlockHeader.epoch\n * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch\n */\nexport function calculateDaoEarliestSince(\n  depositBlockHeaderEpoch: HexString,\n  withdrawBlockHeaderEpoch: HexString\n): bigint {\n  const result = calculateDaoEarliestSinceCompatible(\n    depositBlockHeaderEpoch,\n    withdrawBlockHeaderEpoch\n  );\n  return BigInt(result.toString());\n}\n\n/**\n * calculate a withdraw dao cell minimal unlock since\n *\n * @param depositBlockHeaderEpoch depositBlockHeader.epoch\n * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch\n */\nexport function calculateDaoEarliestSinceCompatible(\n  depositBlockHeaderEpoch: HexString,\n  withdrawBlockHeaderEpoch: HexString\n): BI {\n  const depositEpoch = parseEpochCompatible(depositBlockHeaderEpoch);\n  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeaderEpoch);\n  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);\n  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);\n  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);\n\n  if (withdrawFraction.gt(depositFraction)) {\n    depositedEpochs = depositedEpochs.add(1);\n  }\n\n  const lockEpochs = depositedEpochs\n    .add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)\n    .sub(1)\n    .div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE)\n    .mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);\n  const minimalSinceEpoch = {\n    number: BI.from(depositEpoch.number.add(lockEpochs)),\n    index: BI.from(depositEpoch.index),\n    length: BI.from(depositEpoch.length),\n  };\n  return epochSinceCompatible(minimalSinceEpoch);\n}\n\nfunction _checkDaoScript(config: Config): void {\n  const DAO_SCRIPT = config.SCRIPTS.DAO;\n  if (!DAO_SCRIPT) {\n    throw new Error(\"Provided config does not have DAO script setup!\");\n  }\n}\n\n/**\n *\n * @param {TransactionSkeleton} txSkeleton\n * @param {any} config\n * @returns {TransactionSkeleton} txSkeleton\n */\nfunction _addDaoCellDep(\n  txSkeleton: TransactionSkeletonType,\n  config: Config\n): TransactionSkeletonType {\n  const template = config.SCRIPTS.DAO!;\n  return addCellDep(txSkeleton, {\n    out_point: {\n      tx_hash: template.TX_HASH,\n      index: template.INDEX,\n    },\n    dep_type: template.DEP_TYPE,\n  });\n}\n\nfunction extractDaoDataCompatible(\n  dao: PackedDao\n): {\n  [key: string]: BI;\n} {\n  if (!/^(0x)?([0-9a-fA-F]){64}$/.test(dao)) {\n    throw new Error(\"Invalid dao format!\");\n  }\n\n  const len = 8 * 2;\n  const hex = dao.startsWith(\"0x\") ? dao.slice(2) : dao;\n\n  return [\"c\", \"ar\", \"s\", \"u\"]\n    .map((key, i) => {\n      return {\n        [key]: BI.from(\n          readBigUInt64LECompatible(\"0x\" + hex.slice(len * i, len * (i + 1)))\n        ),\n      };\n    })\n    .reduce((result, c) => ({ ...result, ...c }), {});\n}\n\n/**\n * calculate maximum withdraw capacity when unlock\n *\n * @param withdrawCell withdrawCell or depositCell\n * @param depositDao depositBlockHeader.dao\n * @param withdrawDao withdrawBlockHeader.dao\n */\nexport function calculateMaximumWithdraw(\n  withdrawCell: Cell,\n  depositDao: PackedDao,\n  withdrawDao: PackedDao\n): bigint {\n  return calculateMaximumWithdrawCompatible(\n    withdrawCell,\n    depositDao,\n    withdrawDao\n  ).toBigInt();\n}\n\n/**\n * calculate maximum withdraw capacity when unlock\n *\n * @param withdrawCell withdrawCell or depositCell\n * @param depositDao depositBlockHeader.dao\n * @param withdrawDao withdrawBlockHeader.dao\n */\nexport function calculateMaximumWithdrawCompatible(\n  withdrawCell: Cell,\n  depositDao: PackedDao,\n  withdrawDao: PackedDao\n): BI {\n  const depositAR = BI.from(extractDaoDataCompatible(depositDao).ar);\n  const withdrawAR = BI.from(extractDaoDataCompatible(withdrawDao).ar);\n\n  const occupiedCapacity = BI.from(minimalCellCapacityCompatible(withdrawCell));\n  const outputCapacity = BI.from(withdrawCell.cell_output.capacity);\n  const countedCapacity = outputCapacity.sub(occupiedCapacity);\n  const withdrawCountedCapacity = countedCapacity\n    .mul(withdrawAR)\n    .div(depositAR);\n\n  return withdrawCountedCapacity.add(occupiedCapacity);\n}\n\nexport default {\n  deposit,\n  withdraw,\n  unlock,\n  calculateMaximumWithdraw,\n  calculateMaximumWithdrawCompatible,\n  calculateDaoEarliestSince,\n  calculateDaoEarliestSinceCompatible,\n  CellCollector,\n  listDaoCells,\n};\n"],"file":"dao.js"}