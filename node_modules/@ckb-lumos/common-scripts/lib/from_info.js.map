{"version":3,"sources":["../src/from_info.ts"],"names":["CKBHasher","toBigUInt64LE","utils","serializeMultisigScript","R","M","publicKeyHashes","Error","toString","slice","length","map","h","join","multisigArgs","serializedMultisigScript","since","sinceLE","BI","from","update","digestHex","parseFromInfo","fromInfo","config","undefined","fromScript","multisigScript","destroyable","customData","template","SCRIPTS","SECP256K1_BLAKE160_MULTISIG","fromScriptArgs","code_hash","CODE_HASH","hash_type","HASH_TYPE","args","ANYONE_CAN_PAY","address","script"],"mappings":"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","sourcesContent":["import {\n  PackedSince,\n  Hash,\n  Address,\n  Script,\n  HexString,\n  utils,\n} from \"@ckb-lumos/base\";\nimport { Options, parseAddress } from \"@ckb-lumos/helpers\";\nimport { getConfig } from \"@ckb-lumos/config-manager\";\nimport { BI } from \"@ckb-lumos/bi\";\n\nconst { CKBHasher, toBigUInt64LE } = utils;\n\n/**\n * secp256k1_blake160_multisig script requires S, R, M, N and public key hashes\n * S must be zero now\n * and N equals to publicKeyHashes size\n * so only need to provide R, M and public key hashes\n */\nexport interface MultisigScript {\n  /** first nth public keys must match, 1 byte */\n  R: number;\n  /** threshold, 1 byte */\n  M: number;\n  /** blake160 hashes of compressed public keys */\n  publicKeyHashes: Hash[];\n  /** locktime in since format */\n  since?: PackedSince;\n}\n\nexport interface ACP {\n  address: Address;\n  destroyable?: boolean; // default to false\n}\n\nexport interface CustomScript {\n  script: Script;\n  customData: HexString;\n}\n\nexport type FromInfo = MultisigScript | Address | ACP | CustomScript;\n\n/**\n *\n * @param params multisig script params\n * @returns serialized multisig script\n */\nexport function serializeMultisigScript({\n  R,\n  M,\n  publicKeyHashes,\n}: MultisigScript): HexString {\n  if (R < 0 || R > 255) {\n    throw new Error(\"`R` should be less than 256!\");\n  }\n  if (M < 0 || M > 255) {\n    throw new Error(\"`M` should be less than 256!\");\n  }\n  // TODO: validate publicKeyHashes\n  return (\n    \"0x00\" +\n    (\"00\" + R.toString(16)).slice(-2) +\n    (\"00\" + M.toString(16)).slice(-2) +\n    (\"00\" + publicKeyHashes.length.toString(16)).slice(-2) +\n    publicKeyHashes.map((h) => h.slice(2)).join(\"\")\n  );\n}\n\n/**\n *\n * @param serializedMultisigScript\n * @param since\n * @returns lock script args\n */\nexport function multisigArgs(\n  serializedMultisigScript: HexString,\n  since?: PackedSince\n): HexString {\n  let sinceLE = \"0x\";\n  if (since != null) {\n    sinceLE = toBigUInt64LE(BI.from(since));\n  }\n  return (\n    new CKBHasher().update(serializedMultisigScript).digestHex().slice(0, 42) +\n    sinceLE.slice(2)\n  );\n}\n\nexport function parseFromInfo(\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): {\n  fromScript: Script;\n  multisigScript?: HexString;\n  destroyable?: boolean;\n  customData?: HexString;\n} {\n  config = config || getConfig();\n\n  let fromScript: Script | undefined;\n  let multisigScript: HexString | undefined;\n  let destroyable: boolean | undefined;\n  let customData: HexString | undefined;\n\n  if (typeof fromInfo === \"string\") {\n    // fromInfo is an address\n    fromScript = parseAddress(fromInfo, { config });\n  } else {\n    if (\"R\" in fromInfo) {\n      const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n      if (!template) {\n        throw new Error(\n          \"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\"\n        );\n      }\n\n      multisigScript = serializeMultisigScript(fromInfo);\n      const fromScriptArgs = multisigArgs(multisigScript, fromInfo.since);\n      fromScript = {\n        code_hash: template.CODE_HASH,\n        hash_type: template.HASH_TYPE,\n        args: fromScriptArgs,\n      };\n    } else if (\"address\" in fromInfo) {\n      const template = config.SCRIPTS.ANYONE_CAN_PAY;\n      if (!template) {\n        throw new Error(\n          \"Provided config does not have ANYONE_CAN_PAY script setup!\"\n        );\n      }\n\n      const address = fromInfo.address;\n      fromScript = parseAddress(address, { config });\n      destroyable = fromInfo.destroyable;\n\n      if (\n        fromScript.code_hash !== template.CODE_HASH ||\n        fromScript.hash_type !== template.HASH_TYPE\n      ) {\n        throw new Error(`fromInfo.address is not ANYONE_CAN_PAY address!`);\n      }\n    } else if (\"script\" in fromInfo) {\n      fromScript = fromInfo.script;\n      customData = fromInfo.customData;\n    } else {\n      throw new Error(\"Invalid fromInfo format!\");\n    }\n  }\n\n  return {\n    fromScript,\n    multisigScript,\n    destroyable,\n    customData,\n  };\n}\n"],"file":"from_info.js"}