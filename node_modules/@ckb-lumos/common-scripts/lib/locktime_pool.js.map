{"version":3,"sources":["../src/locktime_pool.ts"],"names":["toBigUInt64LE","readBigUInt64LECompatible","readBigUInt64LE","utils","ScriptValue","values","parseEpoch","maximumAbsoluteEpochSince","generateAbsoluteEpochSince","validateSince","sinceUtils","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","tipHeader","NodeRPC","RPC","Error","result","fromScript","multisigScript","tipSinceValidationInfo","block_number","number","epoch","median_timestamp","rpc","uri","lock","cellCollectors","code_hash","hash_type","args","slice","push","collector","argsLen","type","data","collect","cellCollector","inputCell","cell_output","since","maximumCapacity","depositBlockHash","withdrawBlockHash","sinceValidationInfo","length","header","get_header","block_hash","_parseMultisigArgsSinceCompatible","toString","transactionWithStatus","get_transaction","out_point","tx_hash","tx_status","transaction","depositOutPoint","inputs","index","previous_output","depositBlockHeader","withdrawBlockHeader","daoSince","dao","withdrawEpochValue","fourEpochsLater","multisigSince","relative","capacity","BI","from","transfer","txSkeleton","fromInfos","toAddress","amount","requireToAddress","assertAmountEnough","LocktimeCellCollector","transferCompatible","_txSkeleton","_amount","Array","BigInt","entries","value","_transferCompatible","eq","changeAddress","toScript","update","outputs","lastFreezedOutput","get","filter","field","maxBy","i","size","gt","output","validate","equals","cellCapacity","deductCapacity","gte","sub","clonedOutput","JSON","parse","stringify","changeLockScript","changeCell","changeCapacity","previousInputs","input","add","cell","has","lockArgs","witness","template","SCRIPTS","DAO","dep_type","DEP_TYPE","TX_HASH","INDEX","headerDeps","depositHeaderDepIndex","witnessArgs","input_type","Reader","core","SerializeWitnessArgs","normalizers","NormalizeWitnessArgs","serializeJson","collectInput","Object","assign","defaultWitness","inputCapacity","fixedEntries","injectCapacityWithoutChangeCompatible","minimalChangeCapacity","enableDeductCapacity","_minimalChangeCapacity","getInputKey","injectCapacityWithoutChange","toBigInt","payFee","prepareSigningEntries","injectCapacity","outputIndex","setupInputCell","remove","inputLock","secp256k1Blake160","secp256k1Blake160Multisig","_parseMultisigArgsSince"],"mappings":";;;;;;;;;;;;;AAAA;;AAMA;;AACA;;AACA;;AAIA;;AAmBA;;AACA;;AAcA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAtBA,MAAM;AAAEA,EAAAA,aAAF;AAAiBC,EAAAA,yBAAjB;AAA4CC,EAAAA;AAA5C,IAAgEC,WAAtE;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAkBC,YAAxB;AAUA,MAAM;AACJC,EAAAA,UADI;AAEJC,EAAAA,yBAFI;AAGJC,EAAAA,0BAHI;AAIJC,EAAAA;AAJI,IAKFC,WALJ;AAqBO,MAAMC,aAAuC,GAAG,MAAMA,aAAN,CACxB;AAQ7BC,EAAAA,WAAW,CACTC,QADS,EAETC,YAFS,EAGT;AACEC,IAAAA,MAAM,GAAGC,SADX;AAEEC,IAAAA,YAAY,GAAG,EAFjB;AAGEC,IAAAA,SAAS,GAAGF,SAHd;AAIEG,IAAAA,OAAO,GAAGC;AAJZ,MASI,EAZK,EAaT;AACA,QAAI,CAACN,YAAL,EAAmB;AACjB,YAAM,IAAIO,KAAJ,CAAW,2BAAX,CAAN;AACD;;AACDN,IAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AACA,UAAMO,MAAM,GAAG,8BAAcT,QAAd,EAAwB;AAAEE,MAAAA;AAAF,KAAxB,CAAf;AACA,UAAMQ,UAAU,GAAGD,MAAM,CAACC,UAA1B;AACA,SAAKC,cAAL,GAAsBF,MAAM,CAACE,cAA7B;AACA,SAAKD,UAAL,GAAkBA,UAAlB;AAEA,SAAKR,MAAL,GAAcA,MAAd;AACA,SAAKG,SAAL,GAAiBA,SAAjB;;AAEA,QAAIA,SAAJ,EAAe;AACb;AACA,WAAKO,sBAAL,GAA8B;AAC5BC,QAAAA,YAAY,EAAER,SAAS,CAACS,MADI;AAE5BC,QAAAA,KAAK,EAAEV,SAAS,CAACU,KAFW;AAG5BC,QAAAA,gBAAgB,EAAE;AAHU,OAA9B;AAKD;;AAED,SAAKC,GAAL,GAAW,IAAIX,OAAJ,CAAYL,YAAY,CAACiB,GAAzB,CAAX;AAEAd,IAAAA,YAAY,GAAG,EACb,GAAGA,YADU;AAEbe,MAAAA,IAAI,EAAE,KAAKT;AAFE,KAAf;AAKA,QAAIU,cAAc,GAAG,qBAAwB,EAAxB,CAArB;;AACA,QAAI,+CAAkCV,UAAlC,EAA8CR,MAA9C,CAAJ,EAA2D;AACzD,YAAMiB,IAAY,GAAG;AACnBE,QAAAA,SAAS,EAAEX,UAAU,CAACW,SADH;AAEnBC,QAAAA,SAAS,EAAEZ,UAAU,CAACY,SAFH;AAGnBC,QAAAA,IAAI,EAAEb,UAAU,CAACa,IAAX,CAAgBC,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB;AAHa,OAArB,CADyD,CAMzD;;AACAJ,MAAAA,cAAc,GAAGA,cAAc,CAACK,IAAf,CACfxB,YAAY,CAACyB,SAAb,CAAuB;AACrBP,QAAAA,IADqB;AAErBQ,QAAAA,OAAO,EAAEvB,YAAY,CAACuB,OAAb,IAAwB,EAFZ;AAGrBC,QAAAA,IAAI,EAAExB,YAAY,CAACwB,IAAb,IAAqB,OAHN;AAIrBC,QAAAA,IAAI,EAAEzB,YAAY,CAACyB,IAAb,IAAqB;AAJN,OAAvB,CADe,CAAjB,CAPyD,CAezD;;AACA,UACE,CAACzB,YAAY,CAACwB,IAAd,KACC,CAACxB,YAAY,CAACyB,IAAd,IAAsBzB,YAAY,CAACyB,IAAb,KAAsB,KAD7C,CADF,EAGE;AACAT,QAAAA,cAAc,GAAGA,cAAc,CAACK,IAAf,CACfxB,YAAY,CAACyB,SAAb,CAAuB;AACrBP,UAAAA,IADqB;AAErBS,UAAAA,IAAI,EAAE,+BAAkB1B,MAAlB,CAFe;AAGrB2B,UAAAA,IAAI,EAAE;AAHe,SAAvB,CADe,CAAjB,CADA,CAQA;;AACAT,QAAAA,cAAc,GAAGA,cAAc,CAACK,IAAf,CACfxB,YAAY,CAACyB,SAAb,CAAuB;AACrBP,UAAAA,IADqB;AAErBQ,UAAAA,OAAO,EAAE,EAFY;AAGrBC,UAAAA,IAAI,EAAE,+BAAkB1B,MAAlB,CAHe;AAIrB2B,UAAAA,IAAI,EAAE;AAJe,SAAvB,CADe,CAAjB;AAQD;AACF,KArCD,MAqCO,IAAI,uCAA0BnB,UAA1B,EAAsCR,MAAtC,CAAJ,EAAmD;AACxD;AACA,UACE,CAACE,YAAY,CAACwB,IAAd,KACC,CAACxB,YAAY,CAACyB,IAAd,IAAsBzB,YAAY,CAACyB,IAAb,KAAsB,KAD7C,CADF,EAGE;AACAT,QAAAA,cAAc,GAAGA,cAAc,CAACK,IAAf,CACfxB,YAAY,CAACyB,SAAb,CAAuB;AACrBP,UAAAA,IAAI,EAAET,UADe;AAErBkB,UAAAA,IAAI,EAAE,+BAAkB1B,MAAlB,CAFe;AAGrB2B,UAAAA,IAAI,EAAE;AAHe,SAAvB,CADe,CAAjB;AAOD;AACF;;AAED,SAAKT,cAAL,GAAsBA,cAAtB;AACD;;AAEa,SAAPU,OAAO,GAAiC;AAC7C,SAAK,MAAMC,aAAX,IAA4B,KAAKX,cAAjC,EAAiD;AAC/C,iBAAW,MAAMY,SAAjB,IAA8BD,aAAa,CAACD,OAAd,EAA9B,EAAuD;AACrD,cAAMX,IAAI,GAAGa,SAAS,CAACC,WAAV,CAAsBd,IAAnC;AAEA,YAAIe,KAAJ;AACA,YAAIC,eAAJ;AACA,YAAIC,gBAAJ;AACA,YAAIC,iBAAJ;AACA,YAAIC,mBAAJ,CAPqD,CASrD;;AACA,YAAInB,IAAI,CAACI,IAAL,CAAUgB,MAAV,KAAqB,EAAzB,EAA6B;AAC3B,gBAAMC,MAAM,GAAI,MAAM,KAAKvB,GAAL,CAASwB,UAAT,CAAoBT,SAAS,CAACU,UAA9B,CAAtB;AACAR,UAAAA,KAAK,GACH,OAAOS,iCAAiC,CAACxB,IAAI,CAACI,IAAN,CAAjC,CAA6CqB,QAA7C,CAAsD,EAAtD,CADT,CAF2B,CAI3B;;AACAN,UAAAA,mBAAmB,GAAG;AACpBvB,YAAAA,KAAK,EAAEyB,MAAM,CAACzB,KADM;AAEpBF,YAAAA,YAAY,EAAE2B,MAAM,CAAC1B,MAFD;AAGpBE,YAAAA,gBAAgB,EAAE;AAHE,WAAtB;AAKD,SApBoD,CAsBrD;;;AACA,YAAI,yBAAYgB,SAAS,CAACC,WAAV,CAAsBL,IAAlC,EAAwC,KAAK1B,MAA7C,CAAJ,EAA0D;AACxD,cAAI8B,SAAS,CAACH,IAAV,KAAmB,oBAAvB,EAA6C;AAC3C;AACD;;AACD,gBAAMgB,qBAAqB,GAAI,MAAM,KAAK5B,GAAL,CAAS6B,eAAT,CACnCd,SAAS,CAACe,SAAV,CAAqBC,OADc,CAArC;AAGAX,UAAAA,iBAAiB,GAAGQ,qBAAqB,CAACI,SAAtB,CAAgCP,UAApD;AACA,gBAAMQ,WAAW,GAAGL,qBAAqB,CAACK,WAA1C;AACA,gBAAMC,eAAe,GACnBD,WAAW,CAACE,MAAZ,CAAmB,CAACpB,SAAS,CAACe,SAAV,CAAqBM,KAAzC,EAAgDC,eADlD;AAEAlB,UAAAA,gBAAgB,GAAG,CAAC,MAAM,KAAKnB,GAAL,CAAS6B,eAAT,CACxBK,eAAe,CAACH,OADQ,CAAP,EAEfC,SAFe,CAELP,UAFd;AAGA,gBAAMa,kBAAkB,GAAG,MAAM,KAAKtC,GAAL,CAASwB,UAAT,CAC/BL,gBAD+B,CAAjC;AAGA,gBAAMoB,mBAAmB,GAAG,MAAM,KAAKvC,GAAL,CAASwB,UAAT,CAChCJ,iBADgC,CAAlC;AAGA,cAAIoB,QAAqB,GACvB,OACA,8CACEF,kBAAkB,CAAExC,KADtB,EAEEyC,mBAAmB,CAAEzC,KAFvB,EAGE6B,QAHF,CAGW,EAHX,CAFF;AAMAT,UAAAA,eAAe,GAAG,6CAChBH,SADgB,EAEhBuB,kBAAkB,CAAEG,GAFJ,EAGhBF,mBAAmB,CAAEE,GAHL,CAAlB;AAKA,gBAAMC,kBAAkB,GAAGlE,UAAU,CAAC+D,mBAAmB,CAAEzC,KAAtB,CAArC;AACA,gBAAM6C,eAAe,GAAG;AACtB9C,YAAAA,MAAM,EAAE6C,kBAAkB,CAAC7C,MAAnB,GAA4B,CADd;AAEtByB,YAAAA,MAAM,EAAEoB,kBAAkB,CAACpB,MAFL;AAGtBc,YAAAA,KAAK,EAAEM,kBAAkB,CAACN;AAHJ,WAAxB;AAKAI,UAAAA,QAAQ,GAAG/D,yBAAyB,CAClC+D,QADkC,EAElC9D,0BAA0B,CAACiE,eAAD,CAFQ,CAApC,CArCwD,CA0CxD;;AACA,cAAI1B,KAAJ,EAAW;AACT,kBAAM2B,aAAa,GAAG,iCAAqB3B,KAArB,CAAtB;;AACA,gBACE,EACE2B,aAAa,CAACC,QAAd,KAA2B,KAA3B,IACAD,aAAa,CAACjC,IAAd,KAAuB,aAFzB,CADF,EAKE;AACA;AACA;AACA;AACA;AACA;AACD;;AAED,gBAAI;AACFM,cAAAA,KAAK,GAAGxC,yBAAyB,CAAC+D,QAAD,EAAWvB,KAAX,CAAjC;AACD,aAFD,CAEE,MAAM;AACNA,cAAAA,KAAK,GAAGuB,QAAR;AACD;AACF,WApBD,MAoBO;AACLvB,YAAAA,KAAK,GAAGuB,QAAR;AACD;AACF;;AAED,YACE,iCAAqBvB,KAArB,EAA6BN,IAA7B,KAAsC,gBAAtC,IACC,KAAKvB,SAAL,IACC,CAACT,aAAa,CACZsC,KADY,EAEZ,KAAKtB,sBAFO,EAGZ0B,mBAHY,CAHlB,EAQE;AACA;AACD;;AAED,cAAM7B,MAAM,GAAG,EACb,GAAGuB,SADU;AAEbE,UAAAA,KAAK,EAAEA,KAFM;AAGbE,UAAAA,gBAAgB,EAAEA,gBAHL;AAIbC,UAAAA,iBAAiB,EAAEA,iBAJN;AAKbC,UAAAA;AALa,SAAf;AAOA7B,QAAAA,MAAM,CAACwB,WAAP,CAAmB8B,QAAnB,GACE,OACA,CAAC5B,eAAe,IAAI6B,OAAGC,IAAH,CAAQjC,SAAS,CAACC,WAAV,CAAsB8B,QAA9B,CAApB,EAA6DnB,QAA7D,CACE,EADF,CAFF;AAMA,cAAMnC,MAAN;AACD;AACF;AACF;;AApO4B,CADxB;;;AA8QA,eAAeyD,QAAf,CACLC,UADK,EAELC,SAFK,EAGLC,SAHK,EAILC,MAJK,EAKLjE,SALK,EAML;AACEH,EAAAA,MAAM,GAAGC,SADX;AAEEoE,EAAAA,gBAAgB,GAAG,IAFrB;AAGEC,EAAAA,kBAAkB,GAAG,IAHvB;AAIEC,EAAAA,qBAAqB,GAAG3E;AAJ1B,IAUI,EAhBC,EAiBiE;AACtE,QAAMW,MAAM,GAAG,MAAMiE,kBAAkB,CACrCP,UADqC,EAErCC,SAFqC,EAGrCC,SAHqC,EAIrCC,MAJqC,EAKrCjE,SALqC,EAMrC;AACEH,IAAAA,MADF;AAEEqE,IAAAA,gBAFF;AAGEC,IAAAA,kBAAkB,EAAEA,kBAHtB;AAIEC,IAAAA;AAJF,GANqC,CAAvC;;AAaA,MAAIE,WAAJ;;AACA,MAAIC,OAAJ;;AACA,MAAInE,MAAM,YAAYoE,KAAtB,EAA6B;AAC3BF,IAAAA,WAAW,GAAGlE,MAAM,CAAC,CAAD,CAApB;AACAmE,IAAAA,OAAO,GAAGE,MAAM,CAACrE,MAAM,CAAC,CAAD,CAAN,CAAUmC,QAAV,EAAD,CAAhB;AACA,WAAO,CAAC+B,WAAD,EAAcC,OAAd,CAAP;AACD,GAJD,MAIO;AACLD,IAAAA,WAAW,GAAGlE,MAAd;AACA,WAAOkE,WAAP;AACD;AACF;;AAuCM,eAAeD,kBAAf,CACLP,UADK,EAELC,SAFK,EAGLC,SAHK,EAILC,MAJK,EAKLjE,SALK,EAML;AACEH,EAAAA,MAAM,GAAGC,SADX;AAEEoE,EAAAA,gBAAgB,GAAG,IAFrB;AAGEC,EAAAA,kBAAkB,GAAG,IAHvB;AAIEC,EAAAA,qBAAqB,GAAG3E;AAJ1B,IAUI,EAhBC,EAiB6D;AAClE,MAAI8E,OAAO,GAAGZ,OAAGC,IAAH,CAAQK,MAAR,CAAd;;AACA,OAAK,MAAM,CAACjB,KAAD,EAAQrD,QAAR,CAAX,IAAgCoE,SAAS,CAACW,OAAV,EAAhC,EAAqD;AACnD,UAAMC,KAAK,GAAI,MAAMC,mBAAmB,CACtCd,UADsC,EAEtCnE,QAFsC,EAGtCqD,KAAK,KAAK,CAAV,GAAcgB,SAAd,GAA0BlE,SAHY,EAItCyE,OAJsC,EAKtCvE,SALsC,EAMtC;AACEH,MAAAA,MADF;AAEEqE,MAAAA,gBAAgB,EAAElB,KAAK,KAAK,CAAV,GAAckB,gBAAd,GAAiC,KAFrD;AAGEC,MAAAA,kBAAkB,EAAE,KAHtB;AAIEC,MAAAA;AAJF,KANsC,CAAxC,CADmD,CAcnD;;AACAN,IAAAA,UAAU,GAAGa,KAAK,CAAC,CAAD,CAAlB;AACAJ,IAAAA,OAAO,GAAGI,KAAK,CAAC,CAAD,CAAf;;AAEA,QAAIJ,OAAO,CAACM,EAAR,CAAW,CAAX,CAAJ,EAAmB;AACjB,UAAIV,kBAAJ,EAAwB;AACtB,eAAOL,UAAP;AACD;;AACD,aAAO,CAACA,UAAD,EAAaH,OAAGC,IAAH,CAAQW,OAAR,CAAb,CAAP;AACD;AACF;;AAED,MAAIJ,kBAAJ,EAAwB;AACtB,UAAM,IAAIhE,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,SAAO,CAAC2D,UAAD,EAAaH,OAAGC,IAAH,CAAQW,OAAR,CAAb,CAAP;AACD;;AAED,eAAeK,mBAAf,CACEd,UADF,EAEEnE,QAFF,EAGEqE,SAHF,EAIEC,MAJF,EAKEjE,SALF,EAME;AACEH,EAAAA,MAAM,GAAGC,SADX;AAEEoE,EAAAA,gBAAgB,GAAG,IAFrB;AAGEC,EAAAA,kBAAkB,GAAG,IAHvB;AAIEC,EAAAA,qBAAqB,GAAG3E,aAJ1B;AAKEqF,EAAAA,aAAa,GAAGhF;AALlB,CANF,EAmBoE;AAClED,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB,CADkE,CAElE;;AACA,QAAM;AAAEQ,IAAAA;AAAF,MAAiB,8BAAcV,QAAd,EAAwB;AAAEE,IAAAA;AAAF,GAAxB,CAAvB,CAHkE,CAKlE;;AACA,MACE,CAAC,+CAAkCQ,UAAlC,EAA8CR,MAA9C,CAAD,IACA,CAAC,uCAA0BQ,UAA1B,EAAsCR,MAAtC,CAFH,EAGE;AACA,UAAM,IAAIM,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,MAAI+D,gBAAgB,IAAI,CAACF,SAAzB,EAAoC;AAClC,UAAM,IAAI7D,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,MAAIoE,OAAO,GAAGZ,OAAGC,IAAH,CAAQK,MAAM,IAAI,CAAlB,CAAd;;AACA,MAAID,SAAJ,EAAe;AACb,UAAMe,QAAQ,GAAG,2BAAaf,SAAb,EAAwB;AAAEnE,MAAAA;AAAF,KAAxB,CAAjB;AAEAiE,IAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,aAAOA,OAAO,CAAC7D,IAAR,CAAa;AAClBQ,QAAAA,WAAW,EAAE;AACX8B,UAAAA,QAAQ,EAAE,OAAOa,OAAO,CAAChC,QAAR,CAAiB,EAAjB,CADN;AAEXzB,UAAAA,IAAI,EAAEiE,QAFK;AAGXxD,UAAAA,IAAI,EAAEzB;AAHK,SADK;AAMlB0B,QAAAA,IAAI,EAAE,IANY;AAOlBkB,QAAAA,SAAS,EAAE5C,SAPO;AAQlBuC,QAAAA,UAAU,EAAEvC;AARM,OAAb,CAAP;AAUD,KAXY,CAAb;AAYD;;AAED,QAAMoF,iBAAiB,GAAGpB,UAAU,CACjCqB,GADuB,CACnB,cADmB,EAEvBC,MAFuB,CAEhB,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAeA,KAAK,KAAK,SAFT,EAGvBC,KAHuB,CAGjB,CAAC;AAAEtC,IAAAA;AAAF,GAAD,KAAeA,KAHE,CAA1B;AAIA,MAAIuC,CAAC,GAAGL,iBAAiB,GAAGA,iBAAiB,CAAClC,KAAlB,GAA0B,CAA7B,GAAiC,CAA1D;;AACA,SAAOuC,CAAC,GAAGzB,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BK,IAA9B,IAAsCjB,OAAO,CAACkB,EAAR,CAAW,CAAX,CAA7C,EAA4D,EAAEF,CAA9D,EAAiE;AAC/D,UAAMG,MAAM,GAAG5B,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BI,CAA9B,CAAf;;AACA,QACE,IAAIrG,WAAJ,CAAgBwG,MAAM,CAAC9D,WAAP,CAAmBd,IAAnC,EAAyC;AAAE6E,MAAAA,QAAQ,EAAE;AAAZ,KAAzC,EAA8DC,MAA9D,CACE,IAAI1G,WAAJ,CAAgBmB,UAAhB,EAA4B;AAAEsF,MAAAA,QAAQ,EAAE;AAAZ,KAA5B,CADF,CADF,EAIE;AACA,YAAME,YAAY,GAAGlC,OAAGC,IAAH,CAAQ8B,MAAM,CAAC9D,WAAP,CAAmB8B,QAA3B,CAArB;;AACA,UAAIoC,cAAJ;;AACA,UAAIvB,OAAO,CAACwB,GAAR,CAAYF,YAAZ,CAAJ,EAA+B;AAC7BC,QAAAA,cAAc,GAAGD,YAAjB;AACD,OAFD,MAEO;AACLC,QAAAA,cAAc,GAAGD,YAAY,CAACG,GAAb,CACf,4CAA8BN,MAA9B,CADe,CAAjB;;AAGA,YAAII,cAAc,CAACL,EAAf,CAAkBlB,OAAlB,CAAJ,EAAgC;AAC9BuB,UAAAA,cAAc,GAAGvB,OAAjB;AACD;AACF;;AACDA,MAAAA,OAAO,GAAGA,OAAO,CAACyB,GAAR,CAAYF,cAAZ,CAAV;AAEA,YAAMG,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeV,MAAf,CAAX,CAArB;AACAO,MAAAA,YAAY,CAACrE,WAAb,CAAyB8B,QAAzB,GACE,OAAOmC,YAAY,CAACG,GAAb,CAAiBF,cAAjB,EAAiCvD,QAAjC,CAA0C,EAA1C,CADT;AAEAuB,MAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,eAAOA,OAAO,CAACD,MAAR,CAAeO,CAAf,EAAkB,MAAMU,YAAxB,CAAP;AACD,OAFY,CAAb;AAGD;AACF,GApEiE,CAqElE;;;AACAnC,EAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACG,MAAR,CACJM,MAAD,IAAY,CAAC/B,OAAGC,IAAH,CAAQ8B,MAAM,CAAC9D,WAAP,CAAmB8B,QAA3B,EAAqCmB,EAArC,CAAwC,CAAxC,CADR,CAAP;AAGD,GAJY,CAAb;AAKA;AACF;AACA;;AACE,MAAIN,OAAO,CAACkB,EAAR,CAAW,CAAX,CAAJ,EAAmB;AACjB,UAAM7F,YAAY,GAAGkE,UAAU,CAACqB,GAAX,CAAe,cAAf,CAArB;;AACA,QAAI,CAACvF,YAAL,EAAmB;AACjB,YAAM,IAAIO,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,UAAMkG,gBAAwB,GAAGvB,aAAa,GAC1C,2BAAaA,aAAb,EAA4B;AAAEjF,MAAAA;AAAF,KAA5B,CAD0C,GAE1CQ,UAFJ;AAGA,UAAMiG,UAAgB,GAAG;AACvB1E,MAAAA,WAAW,EAAE;AACX8B,QAAAA,QAAQ,EAAE,KADC;AAEX5C,QAAAA,IAAI,EAAEuF,gBAFK;AAGX9E,QAAAA,IAAI,EAAEzB;AAHK,OADU;AAMvB0B,MAAAA,IAAI,EAAE,IANiB;AAOvBkB,MAAAA,SAAS,EAAE5C,SAPY;AAQvBuC,MAAAA,UAAU,EAAEvC;AARW,KAAzB;;AAUA,QAAIyG,cAAc,GAAG5C,OAAGC,IAAH,CAAQ,CAAR,CAArB;;AAEA,QAAI4C,cAAc,GAAG,qBAArB;;AACA,SAAK,MAAMC,KAAX,IAAoB3C,UAAU,CAACqB,GAAX,CAAe,QAAf,CAApB,EAA8C;AAC5CqB,MAAAA,cAAc,GAAGA,cAAc,CAACE,GAAf,CACd,GAAED,KAAK,CAAC/D,SAAN,CAAiBC,OAAQ,IAAG8D,KAAK,CAAC/D,SAAN,CAAiBM,KAAM,EADvC,CAAjB;AAGD;;AACD,UAAMtB,aAAa,GAAG,IAAI0C,qBAAJ,CAA0BzE,QAA1B,EAAoCC,YAApC,EAAkD;AACtEC,MAAAA,MADsE;AAEtEG,MAAAA;AAFsE,KAAlD,CAAtB;;AAIA,eAAW,MAAM2G,IAAjB,IAAyBjF,aAAa,CAACD,OAAd,EAAzB,EAAkD;AAChD,YAAME,SAAS,GAAGgF,IAAlB,CADgD,CAEhD;;AACA,UACEH,cAAc,CAACI,GAAf,CACG,GAAEjF,SAAS,CAACe,SAAV,CAAqBC,OAAQ,IAAGhB,SAAS,CAACe,SAAV,CAAqBM,KAAM,EADhE,CADF,EAIE;AACA;AACD;;AAED,UAAIQ,aAAJ;;AACA,UAAI,+CAAkCnD,UAAlC,EAA8CR,MAA9C,CAAJ,EAA2D;AACzD,cAAMgH,QAAQ,GAAGlF,SAAS,CAACC,WAAV,CAAsBd,IAAtB,CAA2BI,IAA5C;AACAsC,QAAAA,aAAa,GACXqD,QAAQ,CAAC3E,MAAT,KAAoB,EAApB,GACIyB,OAAGC,IAAH,CAAQtB,iCAAiC,CAACuE,QAAD,CAAzC,CADJ,GAEI/G,SAHN;AAID;;AACD,UAAIgH,OAAkB,GAAG,IAAzB;;AACA,UAAI,yBAAYnF,SAAS,CAACC,WAAV,CAAsBL,IAAlC,EAAwC1B,MAAxC,CAAJ,EAAqD;AACnD,cAAMkH,QAAQ,GAAGlH,MAAM,CAACmH,OAAP,CAAeC,GAAhC;AACAnD,QAAAA,UAAU,GAAG,wBAAWA,UAAX,EAAuB;AAClCoD,UAAAA,QAAQ,EAAEH,QAAQ,CAACI,QADe;AAElCzE,UAAAA,SAAS,EAAE;AACTC,YAAAA,OAAO,EAAEoE,QAAQ,CAACK,OADT;AAETpE,YAAAA,KAAK,EAAE+D,QAAQ,CAACM;AAFP;AAFuB,SAAvB,CAAb;AAQAvD,QAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,YAAlB,EAAiCsC,UAAD,IAAgB;AAC3D,iBAAOA,UAAU,CAAClG,IAAX,CACLO,SAAS,CAACI,gBADL,EAELJ,SAAS,CAACK,iBAFL,CAAP;AAID,SALY,CAAb;AAOA,cAAMuF,qBAAqB,GAAGzD,UAAU,CAACqB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC,CAAlE;AAEA,cAAMgC,WAAW,GAAG;AAClBC,UAAAA,UAAU,EAAE3I,aAAa,CAACyI,qBAAD;AADP,SAApB;AAGAT,QAAAA,OAAO,GAAG,IAAIY,eAAJ,CACRC,WAAKC,oBAAL,CACEC,qBAAYC,oBAAZ,CAAiCN,WAAjC,CADF,CADQ,EAIRO,aAJQ,EAAV;AAKD;;AAEDjE,MAAAA,UAAU,GAAG,MAAMkE,YAAY,CAC7BlE,UAD6B,EAE7BnC,SAF6B,EAG7B,+CAAkCtB,UAAlC,EAA8CR,MAA9C,IACIoI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBvI,QAAlB,EAA4B;AAAEkC,QAAAA,KAAK,EAAE2B;AAAT,OAA5B,CADJ,GAEI7D,QALyB,EAM7B;AAAEE,QAAAA,MAAF;AAAUsI,QAAAA,cAAc,EAAErB,OAA1B;AAAmCjF,QAAAA,KAAK,EAAEF,SAAS,CAACE;AAApD,OAN6B,CAA/B;;AASA,YAAMuG,aAAa,GAAGzE,OAAGC,IAAH,CAAQjC,SAAS,CAACC,WAAV,CAAsB8B,QAA9B,CAAtB;;AACA,UAAIoC,cAAc,GAAGsC,aAArB;;AACA,UAAItC,cAAc,CAACL,EAAf,CAAkBlB,OAAlB,CAAJ,EAAgC;AAC9BuB,QAAAA,cAAc,GAAGvB,OAAjB;AACD;;AACDA,MAAAA,OAAO,GAAGA,OAAO,CAACyB,GAAR,CAAYF,cAAZ,CAAV;AACAS,MAAAA,cAAc,GAAGA,cAAc,CAACG,GAAf,CAAmB0B,aAAnB,EAAkCpC,GAAlC,CAAsCF,cAAtC,CAAjB;;AACA,UAAI,yBAAYnE,SAAS,CAACC,WAAV,CAAsBL,IAAlC,EAAwC1B,MAAxC,CAAJ,EAAqD;AACnD;AACAiE,QAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,cAAlB,EAAmCqD,YAAD,IAAkB;AAC/D,iBAAOA,YAAY,CAACjH,IAAb,CACL;AACEiE,YAAAA,KAAK,EAAE,QADT;AAEErC,YAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,QAAf,EAAyBK,IAAzB,GAAgC;AAFzC,WADK,EAKL;AACEH,YAAAA,KAAK,EAAE,WADT;AAEErC,YAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,WAAf,EAA4BK,IAA5B,GAAmC;AAF5C,WALK,EASL;AACEH,YAAAA,KAAK,EAAE,YADT;AAEErC,YAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC;AAF7C,WATK,CAAP;AAcD,SAfY,CAAb;AAgBD;;AACD,UACEjB,OAAO,CAACM,EAAR,CAAW,CAAX,MACC0B,cAAc,CAAC1B,EAAf,CAAkB,CAAlB,KACC0B,cAAc,CAACd,EAAf,CAAkB,4CAA8Ba,UAA9B,CAAlB,CAFF,CADF,EAIE;AACA;AACD;AACF;;AACD,QAAIC,cAAc,CAACd,EAAf,CAAkB,CAAlB,CAAJ,EAA0B;AACxBa,MAAAA,UAAU,CAAC1E,WAAX,CAAuB8B,QAAvB,GAAkC,OAAO6C,cAAc,CAAChE,QAAf,CAAwB,EAAxB,CAAzC;AACAuB,MAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IACxCA,OAAO,CAAC7D,IAAR,CAAakF,UAAb,CADW,CAAb;AAGD;AACF;;AAED,MAAI,CAACnC,kBAAL,EAAyB;AACvB,WAAO,CAACL,UAAD,EAAaS,OAAb,CAAP;AACD;;AAED,MAAIA,OAAO,CAACkB,EAAR,CAAW,CAAX,CAAJ,EAAmB;AACjB,UAAM,IAAItF,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,SAAO2D,UAAP;AACD;;AAED,eAAewE,qCAAf,CACExE,UADF,EAEEC,SAFF,EAGEE,MAHF,EAIEjE,SAJF,EAKEuI,qBALF,EAME;AACE1I,EAAAA,MAAM,GAAGC,SADX;AAEEsE,EAAAA,qBAAqB,GAAG3E,aAF1B;AAGE+I,EAAAA,oBAAoB,GAAG;AAHzB,CANF,EAmBG;AACD3I,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB,CADC,CAED;;AAEA,MAAI0E,OAAO,GAAGZ,OAAGC,IAAH,CAAQK,MAAR,CAAd;;AACA,QAAMwE,sBAAsB,GAAG9E,OAAGC,IAAH,CAAQ2E,qBAAR,CAA/B;;AACA,MAAIC,oBAAJ,EAA0B;AACxB,SAAK,MAAM7I,QAAX,IAAuBoE,SAAvB,EAAkC;AAChC,YAAM1D,UAAkB,GAAG,8BAAcV,QAAd,EAAwB;AAAEE,QAAAA;AAAF,OAAxB,EAAoCQ,UAA/D,CADgC,CAEhC;;AACA,UACE,CAAC,+CAAkCA,UAAlC,EAA8CR,MAA9C,CAAD,IACA,CAAC,uCAA0BQ,UAA1B,EAAsCR,MAAtC,CAFH,EAGE;AACA;AACA;AACD;;AACD,YAAMqF,iBAAiB,GAAGpB,UAAU,CACjCqB,GADuB,CACnB,cADmB,EAEvBC,MAFuB,CAEhB,CAAC;AAAEC,QAAAA;AAAF,OAAD,KAAeA,KAAK,KAAK,SAFT,EAGvBC,KAHuB,CAGjB,CAAC;AAAEtC,QAAAA;AAAF,OAAD,KAAeA,KAHE,CAA1B;AAIA,UAAIuC,CAAC,GAAGL,iBAAiB,GAAGA,iBAAiB,CAAClC,KAAlB,GAA0B,CAA7B,GAAiC,CAA1D;;AACA,aAAOuC,CAAC,GAAGzB,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BK,IAA9B,IAAsCjB,OAAO,CAACkB,EAAR,CAAW,CAAX,CAA7C,EAA4D,EAAEF,CAA9D,EAAiE;AAC/D,cAAMG,MAAM,GAAG5B,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BI,CAA9B,CAAf;;AACA,YACE,IAAIrG,WAAJ,CAAgBwG,MAAM,CAAC9D,WAAP,CAAmBd,IAAnC,EAAyC;AAAE6E,UAAAA,QAAQ,EAAE;AAAZ,SAAzC,EAA8DC,MAA9D,CACE,IAAI1G,WAAJ,CAAgBmB,UAAhB,EAA4B;AAAEsF,UAAAA,QAAQ,EAAE;AAAZ,SAA5B,CADF,CADF,EAIE;AACA,gBAAMM,YAAkB,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeV,MAAf,CAAX,CAA3B;;AACA,gBAAMG,YAAY,GAAGlC,OAAGC,IAAH,CAAQqC,YAAY,CAACrE,WAAb,CAAyB8B,QAAjC,CAArB;;AACA,cAAIoC,cAAJ;;AACA,cAAIvB,OAAO,CAACwB,GAAR,CAAYF,YAAZ,CAAJ,EAA+B;AAC7BC,YAAAA,cAAc,GAAGD,YAAjB;AACD,WAFD,MAEO;AACLC,YAAAA,cAAc,GAAGD,YAAY,CAACG,GAAb,CACf,4CAA8BC,YAA9B,CADe,CAAjB;;AAGA,gBAAIH,cAAc,CAACL,EAAf,CAAkBlB,OAAlB,CAAJ,EAAgC;AAC9BuB,cAAAA,cAAc,GAAGvB,OAAjB;AACD;AACF;;AACDA,UAAAA,OAAO,GAAGA,OAAO,CAACyB,GAAR,CAAYF,cAAZ,CAAV;AACAG,UAAAA,YAAY,CAACrE,WAAb,CAAyB8B,QAAzB,GACE,OAAOmC,YAAY,CAACG,GAAb,CAAiBF,cAAjB,EAAiCvD,QAAjC,CAA0C,EAA1C,CADT;AAGAuB,UAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,mBAAOA,OAAO,CAACD,MAAR,CAAeO,CAAf,EAAkB,MAAMU,YAAxB,CAAP;AACD,WAFY,CAAb;AAGD;AACF,OA3C+B,CA4ChC;;;AACAnC,MAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,eAAOA,OAAO,CAACG,MAAR,CACJM,MAAD,IAAY,CAAC/B,OAAGC,IAAH,CAAQ8B,MAAM,CAAC9D,WAAP,CAAmB8B,QAA3B,EAAqCmB,EAArC,CAAwC,CAAxC,CADR,CAAP;AAGD,OAJY,CAAb;AAKD;AACF;AAED;AACF;AACA;;;AACE,MAAI0B,cAAc,GAAG5C,OAAGC,IAAH,CAAQ,CAAR,CAArB;;AACA,MAAIW,OAAO,CAACkB,EAAR,CAAW,CAAX,CAAJ,EAAmB;AACjB,UAAM7F,YAAY,GAAGkE,UAAU,CAACqB,GAAX,CAAe,cAAf,CAArB;;AACA,QAAI,CAACvF,YAAL,EAAmB;AACjB,YAAM,IAAIO,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,UAAMuI,WAAW,GAAIjC,KAAD,IACjB,GAAEA,KAAK,CAAC/D,SAAN,CAAiBC,OAAQ,IAAG8D,KAAK,CAAC/D,SAAN,CAAiBM,KAAM,EADxD;;AAEA,QAAIwD,cAAc,GAAG,qBAArB;;AACA,SAAK,MAAMC,KAAX,IAAoB3C,UAAU,CAACqB,GAAX,CAAe,QAAf,CAApB,EAA8C;AAC5CqB,MAAAA,cAAc,GAAGA,cAAc,CAACE,GAAf,CAAmBgC,WAAW,CAACjC,KAAD,CAA9B,CAAjB;AACD;;AAED,SAAK,MAAM9G,QAAX,IAAuBoE,SAAvB,EAAkC;AAChC,YAAM1D,UAAkB,GAAG,8BAAcV,QAAd,EAAwB;AAAEE,QAAAA;AAAF,OAAxB,EAAoCQ,UAA/D;AACA,YAAMqB,aAAa,GAAG,IAAI0C,qBAAJ,CAA0BzE,QAA1B,EAAoCC,YAApC,EAAkD;AACtEC,QAAAA,MADsE;AAEtEG,QAAAA;AAFsE,OAAlD,CAAtB;;AAIA,iBAAW,MAAM2G,IAAjB,IAAyBjF,aAAa,CAACD,OAAd,EAAzB,EAAkD;AAChD,cAAME,SAAS,GAAGgF,IAAlB,CADgD,CAEhD;;AACA,YAAIH,cAAc,CAACI,GAAf,CAAmB8B,WAAW,CAAC/G,SAAD,CAA9B,CAAJ,EAAgD;AAC9C;AACD;;AAED,YAAImF,OAAkB,GAAG,IAAzB;;AACA,YAAI,yBAAYnF,SAAS,CAACC,WAAV,CAAsBL,IAAlC,EAAwC1B,MAAxC,CAAJ,EAAqD;AACnD,gBAAMkH,QAAQ,GAAGlH,MAAM,CAACmH,OAAP,CAAeC,GAAhC;AACAnD,UAAAA,UAAU,GAAG,wBAAWA,UAAX,EAAuB;AAClCoD,YAAAA,QAAQ,EAAEH,QAAQ,CAACI,QADe;AAElCzE,YAAAA,SAAS,EAAE;AACTC,cAAAA,OAAO,EAAEoE,QAAQ,CAACK,OADT;AAETpE,cAAAA,KAAK,EAAE+D,QAAQ,CAACM;AAFP;AAFuB,WAAvB,CAAb;AAQAvD,UAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,YAAlB,EAAiCsC,UAAD,IAAgB;AAC3D,mBAAOA,UAAU,CAAClG,IAAX,CACLO,SAAS,CAACI,gBADL,EAELJ,SAAS,CAACK,iBAFL,CAAP;AAID,WALY,CAAb;AAOA,gBAAMuF,qBAAqB,GAAGzD,UAAU,CAACqB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC,CAAlE;AACA,gBAAMgC,WAAW,GAAG;AAClBC,YAAAA,UAAU,EAAE3I,aAAa,CACvB6E,OAAGC,IAAH,CAAQ2D,qBAAR,EAA+BhF,QAA/B,EADuB;AADP,WAApB;AAKAuE,UAAAA,OAAO,GAAG,IAAIY,eAAJ,CACRC,WAAKC,oBAAL,CACEC,qBAAYC,oBAAZ,CAAiCN,WAAjC,CADF,CADQ,EAIRO,aAJQ,EAAV;AAKD;;AACD,YAAIvE,aAAJ;;AACA,YAAI,+CAAkCnD,UAAlC,EAA8CR,MAA9C,CAAJ,EAA2D;AACzD;AACA,gBAAMgH,QAAQ,GAAGlF,SAAS,CAACC,WAAV,CAAsBd,IAAtB,CAA2BI,IAA5C;AACAsC,UAAAA,aAAa,GACXqD,QAAQ,CAAC3E,MAAT,KAAoB,EAApB,GACIyB,OAAGC,IAAH,CAAQtB,iCAAiC,CAACuE,QAAD,CAAzC,CADJ,GAEI/G,SAHN;AAID;;AACDgE,QAAAA,UAAU,GAAG,MAAMkE,YAAY,CAC7BlE,UAD6B,EAE7BnC,SAF6B,EAG7BsG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBvI,QAAlB,EAA4B;AAAEkC,UAAAA,KAAK,EAAE2B;AAAT,SAA5B,CAH6B,EAI7B;AAAE3D,UAAAA,MAAF;AAAUsI,UAAAA,cAAc,EAAErB,OAA1B;AAAmCjF,UAAAA,KAAK,EAAEF,SAAS,CAACE;AAApD,SAJ6B,CAA/B;;AAOA,cAAMuG,aAAa,GAAGzE,OAAGC,IAAH,CAAQjC,SAAS,CAACC,WAAV,CAAsB8B,QAA9B,CAAtB;;AACA,YAAIoC,cAAc,GAAGsC,aAArB;;AACA,YAAItC,cAAc,CAACL,EAAf,CAAkBlB,OAAlB,CAAJ,EAAgC;AAC9BuB,UAAAA,cAAc,GAAGvB,OAAjB;AACD;;AACDA,QAAAA,OAAO,GAAGA,OAAO,CAACyB,GAAR,CAAYF,cAAZ,CAAV;AACAS,QAAAA,cAAc,GAAGA,cAAc,CAACG,GAAf,CAAmB0B,aAAnB,EAAkCpC,GAAlC,CAAsCF,cAAtC,CAAjB;;AAEA,YAAI,yBAAYnE,SAAS,CAACC,WAAV,CAAsBL,IAAlC,EAAwC1B,MAAxC,CAAJ,EAAqD;AACnD;AACAiE,UAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,cAAlB,EAAmCqD,YAAD,IAAkB;AAC/D,mBAAOA,YAAY,CAACjH,IAAb,CACL;AACEiE,cAAAA,KAAK,EAAE,QADT;AAEErC,cAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,QAAf,EAAyBK,IAAzB,GAAgC;AAFzC,aADK,EAKL;AACEH,cAAAA,KAAK,EAAE,WADT;AAEErC,cAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,WAAf,EAA4BK,IAA5B,GAAmC;AAF5C,aALK,EASL;AACEH,cAAAA,KAAK,EAAE,YADT;AAEErC,cAAAA,KAAK,EAAEc,UAAU,CAACqB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC;AAF7C,aATK,CAAP;AAcD,WAfY,CAAb;AAgBD;;AAED,YACEjB,OAAO,CAACM,EAAR,CAAW,CAAX,MACC0B,cAAc,CAAC1B,EAAf,CAAkB,CAAlB,KAAwB0B,cAAc,CAACd,EAAf,CAAkBgD,sBAAlB,CADzB,CADF,EAGE;AACA;AACD;AACF;AACF;AACF;;AAED,SAAO;AACL3E,IAAAA,UADK;AAELJ,IAAAA,QAAQ,EAAEC,OAAGC,IAAH,CAAQW,OAAO,CAAChC,QAAR,EAAR,CAFL;AAGLgE,IAAAA,cAAc,EAAE5C,OAAGC,IAAH,CAAQ2C,cAAc,CAAChE,QAAf,EAAR;AAHX,GAAP;AAKD;;AAED,eAAeoG,2BAAf,CACE7E,UADF,EAEEC,SAFF,EAGEE,MAHF,EAIEjE,SAJF,EAKEuI,qBALF,EAME;AACE1I,EAAAA,MAAM,GAAGC,SADX;AAEEsE,EAAAA,qBAAqB,GAAG3E,aAF1B;AAGE+I,EAAAA,oBAAoB,GAAG;AAHzB,CANF,EAmBG;AACD,QAAMpI,MAAM,GAAG,MAAMkI,qCAAqC,CACxDxE,UADwD,EAExDC,SAFwD,EAGxDE,MAHwD,EAIxDjE,SAJwD,EAKxDuI,qBALwD,EAMxD;AACE1I,IAAAA,MADF;AAEEuE,IAAAA,qBAFF;AAGEoE,IAAAA;AAHF,GANwD,CAA1D;AAaA,SAAO;AACL1E,IAAAA,UAAU,EAAE1D,MAAM,CAAC0D,UADd;AAELJ,IAAAA,QAAQ,EAAEtD,MAAM,CAACsD,QAAP,CAAgBkF,QAAhB,EAFL;AAGLrC,IAAAA,cAAc,EAAEnG,MAAM,CAACmG,cAAP,CAAsBqC,QAAtB;AAHX,GAAP;AAKD;;AAEM,eAAeC,MAAf,CACL/E,UADK,EAELC,SAFK,EAGLE,MAHK,EAILjE,SAJK,EAKL;AACEH,EAAAA,MAAM,GAAGC,SADX;AAEEsE,EAAAA,qBAAqB,GAAG3E;AAF1B,IAMI,EAXC,EAY6B;AAClC,SAAO4E,kBAAkB,CACvBP,UADuB,EAEvBC,SAFuB,EAGvBjE,SAHuB,EAIvBmE,MAJuB,EAKvBjE,SALuB,EAMvB;AACEH,IAAAA,MADF;AAEEqE,IAAAA,gBAAgB,EAAE,KAFpB;AAGEE,IAAAA;AAHF,GANuB,CAAzB;AAYD;;AAEM,SAAS0E,qBAAT,CACLhF,UADK,EAEL;AAAEjE,EAAAA,MAAM,GAAGC;AAAX,IAAkC,EAF7B,EAGoB;AACzBD,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AACAiE,EAAAA,UAAU,GAAG,mCAAuBA,UAAvB,EAAmCjE,MAAnC,EAA2C,oBAA3C,CAAb;AACAiE,EAAAA,UAAU,GAAG,mCACXA,UADW,EAEXjE,MAFW,EAGX,6BAHW,CAAb;AAKA,SAAOiE,UAAP;AACD;;AAEM,eAAeiF,cAAf,CACLjF,UADK,EAELkF,WAFK,EAGLjF,SAHK,EAIL/D,SAJK,EAKL;AACEH,EAAAA,MAAM,GAAGC,SADX;AAEEsE,EAAAA,qBAAqB,GAAG3E;AAF1B,IAOI,EAZC,EAa6B;AAClCI,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;;AACA,MAAImJ,WAAW,IAAIlF,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BK,IAA7C,EAAmD;AACjD,UAAM,IAAIrF,KAAJ,CAAU,uBAAV,CAAN;AACD;;AACD,QAAMuD,QAAQ,GAAGC,OAAGC,IAAH,CACfE,UAAU,CAACqB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8B6D,WAA9B,EAA4CpH,WAA5C,CAAwD8B,QADzC,CAAjB;;AAGA,SAAOW,kBAAkB,CACvBP,UADuB,EAEvBC,SAFuB,EAGvBjE,SAHuB,EAIvB6D,OAAGC,IAAH,CAAQF,QAAR,CAJuB,EAKvB1D,SALuB,EAMvB;AACEH,IAAAA,MADF;AAEEqE,IAAAA,gBAAgB,EAAE,KAFpB;AAGEE,IAAAA;AAHF,GANuB,CAAzB;AAYD;;AAED,eAAe4D,YAAf,CACElE,UADF,EAEEnC,SAFF,EAGEhC,QAHF,EAIE;AACEE,EAAAA,MAAM,GAAGC,SADX;AAEE+B,EAAAA,KAAK,GAAG/B,SAFV;AAGEqI,EAAAA,cAAc,GAAG;AAHnB,IAImE,EARrE,EASoC;AAClCtI,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AAEAiE,EAAAA,UAAU,GAAG,MAAMmF,cAAc,CAACnF,UAAD,EAAanC,SAAb,EAAwBhC,QAAxB,EAAkC;AACjEE,IAAAA,MADiE;AAEjEgC,IAAAA,KAFiE;AAGjEsG,IAAAA;AAHiE,GAAlC,CAAjC;AAMArE,EAAAA,UAAU,GAAGA,UAAU,CAACkB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;AACrD,WAAOA,OAAO,CAACiE,MAAR,CAAejE,OAAO,CAACO,IAAR,GAAe,CAA9B,CAAP;AACD,GAFY,CAAb;AAIA,SAAO1B,UAAP;AACD;;AAEM,eAAemF,cAAf,CACLnF,UADK,EAELnC,SAFK,EAGLhC,QAHK,EAIL;AACEE,EAAAA,MAAM,GAAGC,SADX;AAEE+B,EAAAA,KAAK,GAAG/B,SAFV;AAGEqI,EAAAA,cAAc,GAAG;AAHnB,IAImE,EAR9D,EAS6B;AAClCtI,EAAAA,MAAM,GAAGA,MAAM,IAAI,+BAAnB;AACA,QAAMsJ,SAAS,GAAGxH,SAAS,CAACC,WAAV,CAAsBd,IAAxC;;AAEA,MAAI,uCAA0BqI,SAA1B,EAAqCtJ,MAArC,CAAJ,EAAkD;AAChD,WAAOuJ,yBAAkBH,cAAlB,CAAiCnF,UAAjC,EAA6CnC,SAA7C,EAAwDhC,QAAxD,EAAkE;AACvEE,MAAAA,MADuE;AAEvEsI,MAAAA,cAFuE;AAGvEtG,MAAAA;AAHuE,KAAlE,CAAP;AAKD,GAND,MAMO,IAAI,+CAAkCsH,SAAlC,EAA6CtJ,MAA7C,CAAJ,EAA0D;AAC/D,WAAOwJ,4BAA0BJ,cAA1B,CACLnF,UADK,EAELnC,SAFK,EAGLhC,QAHK,EAIL;AAAEE,MAAAA,MAAF;AAAUsI,MAAAA,cAAV;AAA0BtG,MAAAA;AAA1B,KAJK,CAAP;AAMD,GAPM,MAOA;AACL,UAAM,IAAI1B,KAAJ,CAAW,2BAAX,CAAN;AACD;AACF;;AAED,SAASmJ,uBAAT,CAAiCpI,IAAjC,EAA0D;AACxD,MAAIA,IAAI,CAACgB,MAAL,KAAgB,EAApB,EAAwB;AACtB,UAAM,IAAI/B,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,SAAOnB,eAAe,CAAC,OAAOkC,IAAI,CAACC,KAAL,CAAW,EAAX,CAAR,CAAtB;AACD;;AAED,SAASmB,iCAAT,CAA2CpB,IAA3C,EAAgE;AAC9D,MAAIA,IAAI,CAACgB,MAAL,KAAgB,EAApB,EAAwB;AACtB,UAAM,IAAI/B,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,SAAOpB,yBAAyB,CAAC,OAAOmC,IAAI,CAACC,KAAL,CAAW,EAAX,CAAR,CAAhC;AACD;;eAEc;AACb1B,EAAAA,aADa;AAEboE,EAAAA,QAFa;AAGbQ,EAAAA,kBAHa;AAIbwE,EAAAA,MAJa;AAKbC,EAAAA,qBALa;AAMbC,EAAAA,cANa;AAObE,EAAAA,cAPa;AAQbN,EAAAA,2BARa;AASbL,EAAAA;AATa,C","sourcesContent":["import {\n  parseAddress,\n  Options,\n  TransactionSkeletonType,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport {\n  calculateMaximumWithdrawCompatible,\n  calculateDaoEarliestSinceCompatible,\n} from \"./dao\";\nimport {\n  core,\n  values,\n  utils,\n  since as sinceUtils,\n  CellProvider,\n  Script,\n  PackedSince,\n  Cell,\n  Hash,\n  HexString,\n  Address,\n  Header,\n  QueryOptions,\n  CellCollector as CellCollectorType,\n  SinceValidationInfo,\n} from \"@ckb-lumos/base\";\nconst { toBigUInt64LE, readBigUInt64LECompatible, readBigUInt64LE } = utils;\nconst { ScriptValue } = values;\nimport { normalizers, Reader } from \"@ckb-lumos/toolkit\";\nimport {\n  generateDaoScript,\n  isSecp256k1Blake160MultisigScript,\n  isSecp256k1Blake160Script,\n  isDaoScript,\n  prepareSigningEntries as _prepareSigningEntries,\n  addCellDep,\n} from \"./helper\";\nconst {\n  parseEpoch,\n  maximumAbsoluteEpochSince,\n  generateAbsoluteEpochSince,\n  validateSince,\n} = sinceUtils;\nimport { List, Set } from \"immutable\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport { RPC } from \"@ckb-lumos/rpc\";\nimport { secp256k1Blake160Multisig } from \".\";\nimport { parseSinceCompatible } from \"@ckb-lumos/base/lib/since\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\n\nexport interface LocktimeCell extends Cell {\n  since: PackedSince;\n  depositBlockHash?: Hash;\n  withdrawBlockHash?: Hash;\n  sinceValidationInfo?: SinceValidationInfo;\n}\n\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType {\n  private cellCollectors: List<CellCollectorType>;\n  private config: Config;\n  private rpc: RPC;\n  private tipHeader?: Header;\n  private tipSinceValidationInfo?: SinceValidationInfo;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n      tipHeader = undefined,\n      NodeRPC = RPC,\n    }: Options & {\n      queryOptions?: QueryOptions;\n      tipHeader?: Header;\n      NodeRPC?: typeof RPC;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    const fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n    this.fromScript = fromScript;\n\n    this.config = config;\n    this.tipHeader = tipHeader;\n\n    if (tipHeader) {\n      // TODO: `median_timestamp` is not provided now!\n      this.tipSinceValidationInfo = {\n        block_number: tipHeader.number,\n        epoch: tipHeader.epoch,\n        median_timestamp: \"\",\n      };\n    }\n\n    this.rpc = new NodeRPC(cellProvider.uri!);\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n    };\n\n    let cellCollectors = List<CellCollectorType>([]);\n    if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n      const lock: Script = {\n        code_hash: fromScript.code_hash,\n        hash_type: fromScript.hash_type,\n        args: fromScript.args.slice(0, 42),\n      };\n      // multisig with locktime, not dao\n      cellCollectors = cellCollectors.push(\n        cellProvider.collector({\n          lock,\n          argsLen: queryOptions.argsLen || 28,\n          type: queryOptions.type || \"empty\",\n          data: queryOptions.data || \"0x\",\n        })\n      );\n      // multisig without locktime, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n        // multisig with locktime, dao\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            argsLen: 28,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    } else if (isSecp256k1Blake160Script(fromScript, config)) {\n      // secp256k1_blake160, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock: fromScript,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    }\n\n    this.cellCollectors = cellCollectors;\n  }\n\n  async *collect(): AsyncGenerator<LocktimeCell> {\n    for (const cellCollector of this.cellCollectors) {\n      for await (const inputCell of cellCollector.collect()) {\n        const lock = inputCell.cell_output.lock;\n\n        let since: PackedSince | undefined;\n        let maximumCapacity: BI | undefined;\n        let depositBlockHash: Hash | undefined;\n        let withdrawBlockHash: Hash | undefined;\n        let sinceValidationInfo: SinceValidationInfo | undefined;\n\n        // multisig\n        if (lock.args.length === 58) {\n          const header = (await this.rpc.get_header(inputCell.block_hash!))!;\n          since =\n            \"0x\" + _parseMultisigArgsSinceCompatible(lock.args).toString(16);\n          // TODO: `median_timestamp` not provided now!\n          sinceValidationInfo = {\n            epoch: header.epoch,\n            block_number: header.number,\n            median_timestamp: \"\",\n          };\n        }\n\n        // dao\n        if (isDaoScript(inputCell.cell_output.type, this.config)) {\n          if (inputCell.data === \"0x0000000000000000\") {\n            continue;\n          }\n          const transactionWithStatus = (await this.rpc.get_transaction(\n            inputCell.out_point!.tx_hash\n          ))!;\n          withdrawBlockHash = transactionWithStatus.tx_status.block_hash;\n          const transaction = transactionWithStatus.transaction;\n          const depositOutPoint =\n            transaction.inputs[+inputCell.out_point!.index].previous_output;\n          depositBlockHash = (await this.rpc.get_transaction(\n            depositOutPoint.tx_hash\n          ))!.tx_status.block_hash!;\n          const depositBlockHeader = await this.rpc.get_header(\n            depositBlockHash\n          );\n          const withdrawBlockHeader = await this.rpc.get_header(\n            withdrawBlockHash!\n          );\n          let daoSince: PackedSince =\n            \"0x\" +\n            calculateDaoEarliestSinceCompatible(\n              depositBlockHeader!.epoch,\n              withdrawBlockHeader!.epoch\n            ).toString(16);\n          maximumCapacity = calculateMaximumWithdrawCompatible(\n            inputCell,\n            depositBlockHeader!.dao,\n            withdrawBlockHeader!.dao\n          );\n          const withdrawEpochValue = parseEpoch(withdrawBlockHeader!.epoch);\n          const fourEpochsLater = {\n            number: withdrawEpochValue.number + 4,\n            length: withdrawEpochValue.length,\n            index: withdrawEpochValue.index,\n          };\n          daoSince = maximumAbsoluteEpochSince(\n            daoSince,\n            generateAbsoluteEpochSince(fourEpochsLater)\n          );\n\n          // if multisig with locktime\n          if (since) {\n            const multisigSince = parseSinceCompatible(since);\n            if (\n              !(\n                multisigSince.relative === false &&\n                multisigSince.type === \"epochNumber\"\n              )\n            ) {\n              // throw new Error(\n              //   \"Multisig since not an absolute-epoch-number since format!\"\n              // );\n              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it\n              continue;\n            }\n\n            try {\n              since = maximumAbsoluteEpochSince(daoSince, since);\n            } catch {\n              since = daoSince;\n            }\n          } else {\n            since = daoSince;\n          }\n        }\n\n        if (\n          parseSinceCompatible(since!).type === \"blockTimestamp\" ||\n          (this.tipHeader &&\n            !validateSince(\n              since!,\n              this.tipSinceValidationInfo!,\n              sinceValidationInfo\n            ))\n        ) {\n          continue;\n        }\n\n        const result = {\n          ...inputCell,\n          since: since!,\n          depositBlockHash: depositBlockHash,\n          withdrawBlockHash: withdrawBlockHash,\n          sinceValidationInfo,\n        };\n        result.cell_output.capacity =\n          \"0x\" +\n          (maximumCapacity || BI.from(inputCell.cell_output.capacity)).toString(\n            16\n          );\n\n        yield result;\n      }\n    }\n  }\n};\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfos,\n    toAddress,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n      LocktimeCellCollector,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  let _amount = BI.from(amount);\n  for (const [index, fromInfo] of fromInfos.entries()) {\n    const value = (await _transferCompatible(\n      txSkeleton,\n      fromInfo,\n      index === 0 ? toAddress : undefined,\n      _amount,\n      tipHeader,\n      {\n        config,\n        requireToAddress: index === 0 ? requireToAddress : false,\n        assertAmountEnough: false,\n        LocktimeCellCollector,\n      }\n    )) as [TransactionSkeletonType, BI];\n    // [txSkeleton, amount] = value\n    txSkeleton = value[0];\n    _amount = value[1];\n\n    if (_amount.eq(0)) {\n      if (assertAmountEnough) {\n        return txSkeleton;\n      }\n      return [txSkeleton, BI.from(_amount)];\n    }\n  }\n\n  if (assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from addresses!\");\n  }\n  return [txSkeleton, BI.from(_amount)];\n}\n\nasync function _transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n    changeAddress = undefined,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector: CellCollectorConstructor;\n    changeAddress?: Address;\n  }\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n  const { fromScript } = parseFromInfo(fromInfo, { config });\n\n  // validate fromScript\n  if (\n    !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n    !isSecp256k1Blake160Script(fromScript, config)\n  ) {\n    throw new Error(\"fromInfo not supported!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = BI.from(amount || 0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cell_output: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        out_point: undefined,\n        block_hash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cell_output.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cell_output.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n\n      const clonedOutput = JSON.parse(JSON.stringify(output));\n      clonedOutput.cell_output.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.update(i, () => clonedOutput);\n      });\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cell_output.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const changeLockScript: Script = changeAddress\n      ? parseAddress(changeAddress, { config })\n      : fromScript;\n    const changeCell: Cell = {\n      cell_output: {\n        capacity: \"0x0\",\n        lock: changeLockScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      out_point: undefined,\n      block_hash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.out_point!.tx_hash}_${input.out_point!.index}`\n      );\n    }\n    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n      config,\n      tipHeader,\n    });\n    for await (const cell of cellCollector.collect()) {\n      const inputCell = cell as LocktimeCell;\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.out_point!.tx_hash}_${inputCell.out_point!.index}`\n        )\n      ) {\n        continue;\n      }\n\n      let multisigSince: BI | undefined;\n      if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n        const lockArgs = inputCell.cell_output.lock.args;\n        multisigSince =\n          lockArgs.length === 58\n            ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n            : undefined;\n      }\n      let witness: HexString = \"0x\";\n      if (isDaoScript(inputCell.cell_output.type, config)) {\n        const template = config.SCRIPTS.DAO!;\n        txSkeleton = addCellDep(txSkeleton, {\n          dep_type: template.DEP_TYPE,\n          out_point: {\n            tx_hash: template.TX_HASH,\n            index: template.INDEX,\n          },\n        });\n\n        txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n          return headerDeps.push(\n            inputCell.depositBlockHash!,\n            inputCell.withdrawBlockHash!\n          );\n        });\n\n        const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n\n        const witnessArgs = {\n          input_type: toBigUInt64LE(depositHeaderDepIndex),\n        };\n        witness = new Reader(\n          core.SerializeWitnessArgs(\n            normalizers.NormalizeWitnessArgs(witnessArgs)\n          )\n        ).serializeJson();\n      }\n\n      txSkeleton = await collectInput(\n        txSkeleton,\n        inputCell,\n        isSecp256k1Blake160MultisigScript(fromScript, config)\n          ? Object.assign({}, fromInfo, { since: multisigSince })\n          : fromInfo,\n        { config, defaultWitness: witness, since: inputCell.since }\n      );\n\n      const inputCapacity = BI.from(inputCell.cell_output.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (isDaoScript(inputCell.cell_output.type, config)) {\n        // fix inputs / outputs / witnesses\n        txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n          return fixedEntries.push(\n            {\n              field: \"inputs\",\n              index: txSkeleton.get(\"inputs\").size - 1,\n            },\n            {\n              field: \"witnesses\",\n              index: txSkeleton.get(\"witnesses\").size - 1,\n            },\n            {\n              field: \"headerDeps\",\n              index: txSkeleton.get(\"headerDeps\").size - 2,\n            }\n          );\n        });\n      }\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cell_output.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n\n  if (!assertAmountEnough) {\n    return [txSkeleton, _amount];\n  }\n\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  return txSkeleton;\n}\n\nasync function injectCapacityWithoutChangeCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  minimalChangeCapacity: BIish,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: BI;\n  changeCapacity: BI;\n}> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n\n  let _amount = BI.from(amount);\n  const _minimalChangeCapacity = BI.from(minimalChangeCapacity);\n  if (enableDeductCapacity) {\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      // validate fromScript\n      if (\n        !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n        !isSecp256k1Blake160Script(fromScript, config)\n      ) {\n        // Skip if not support.\n        continue;\n      }\n      const lastFreezedOutput = txSkeleton\n        .get(\"fixedEntries\")\n        .filter(({ field }) => field === \"outputs\")\n        .maxBy(({ index }) => index);\n      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n      for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n        const output = txSkeleton.get(\"outputs\").get(i)!;\n        if (\n          new ScriptValue(output.cell_output.lock, { validate: false }).equals(\n            new ScriptValue(fromScript, { validate: false })\n          )\n        ) {\n          const clonedOutput: Cell = JSON.parse(JSON.stringify(output));\n          const cellCapacity = BI.from(clonedOutput.cell_output.capacity);\n          let deductCapacity;\n          if (_amount.gte(cellCapacity)) {\n            deductCapacity = cellCapacity;\n          } else {\n            deductCapacity = cellCapacity.sub(\n              minimalCellCapacityCompatible(clonedOutput)\n            );\n            if (deductCapacity.gt(_amount)) {\n              deductCapacity = _amount;\n            }\n          }\n          _amount = _amount.sub(deductCapacity);\n          clonedOutput.cell_output.capacity =\n            \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n\n          txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n            return outputs.update(i, () => clonedOutput);\n          });\n        }\n      }\n      // remove all output cells with capacity equal to 0\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.filter(\n          (output) => !BI.from(output.cell_output.capacity).eq(0)\n        );\n      });\n    }\n  }\n\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  let changeCapacity = BI.from(0);\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const getInputKey = (input: Cell) =>\n      `${input.out_point!.tx_hash}_${input.out_point!.index}`;\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(getInputKey(input));\n    }\n\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader,\n      });\n      for await (const cell of cellCollector.collect()) {\n        const inputCell = cell as LocktimeCell;\n        // skip inputs already exists in txSkeleton.inputs\n        if (previousInputs.has(getInputKey(inputCell))) {\n          continue;\n        }\n\n        let witness: HexString = \"0x\";\n        if (isDaoScript(inputCell.cell_output.type, config)) {\n          const template = config.SCRIPTS.DAO!;\n          txSkeleton = addCellDep(txSkeleton, {\n            dep_type: template.DEP_TYPE,\n            out_point: {\n              tx_hash: template.TX_HASH,\n              index: template.INDEX,\n            },\n          });\n\n          txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n            return headerDeps.push(\n              inputCell.depositBlockHash!,\n              inputCell.withdrawBlockHash!\n            );\n          });\n\n          const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n          const witnessArgs = {\n            input_type: toBigUInt64LE(\n              BI.from(depositHeaderDepIndex).toString()\n            ),\n          };\n          witness = new Reader(\n            core.SerializeWitnessArgs(\n              normalizers.NormalizeWitnessArgs(witnessArgs)\n            )\n          ).serializeJson();\n        }\n        let multisigSince: BI | undefined;\n        if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n          // multisig\n          const lockArgs = inputCell.cell_output.lock.args;\n          multisigSince =\n            lockArgs.length === 58\n              ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n              : undefined;\n        }\n        txSkeleton = await collectInput(\n          txSkeleton,\n          inputCell,\n          Object.assign({}, fromInfo, { since: multisigSince }),\n          { config, defaultWitness: witness, since: inputCell.since }\n        );\n\n        const inputCapacity = BI.from(inputCell.cell_output.capacity);\n        let deductCapacity = inputCapacity;\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n        _amount = _amount.sub(deductCapacity);\n        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n\n        if (isDaoScript(inputCell.cell_output.type, config)) {\n          // fix inputs / outputs / witnesses\n          txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n            return fixedEntries.push(\n              {\n                field: \"inputs\",\n                index: txSkeleton.get(\"inputs\").size - 1,\n              },\n              {\n                field: \"witnesses\",\n                index: txSkeleton.get(\"witnesses\").size - 1,\n              },\n              {\n                field: \"headerDeps\",\n                index: txSkeleton.get(\"headerDeps\").size - 2,\n              }\n            );\n          });\n        }\n\n        if (\n          _amount.eq(0) &&\n          (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))\n        ) {\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    txSkeleton,\n    capacity: BI.from(_amount.toString()),\n    changeCapacity: BI.from(changeCapacity.toString()),\n  };\n}\n\nasync function injectCapacityWithoutChange(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: bigint,\n  tipHeader: Header,\n  minimalChangeCapacity: bigint,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: bigint;\n  changeCapacity: bigint;\n}> {\n  const result = await injectCapacityWithoutChangeCompatible(\n    txSkeleton,\n    fromInfos,\n    amount,\n    tipHeader,\n    minimalChangeCapacity,\n    {\n      config,\n      LocktimeCellCollector,\n      enableDeductCapacity,\n    }\n  );\n\n  return {\n    txSkeleton: result.txSkeleton,\n    capacity: result.capacity.toBigInt(),\n    changeCapacity: result.changeCapacity.toBigInt(),\n  };\n}\n\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n  txSkeleton = _prepareSigningEntries(txSkeleton, config, \"SECP256K1_BLAKE160\");\n  txSkeleton = _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n  return txSkeleton;\n}\n\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfos: FromInfo[],\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: Options & {\n    // eslint-disable-next-line\n    cellCollector?: (...params: any[]) => AsyncIterable<LocktimeCell>;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cell_output.capacity\n  );\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    BI.from(capacity),\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nasync function collectInput(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness,\n  });\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.remove(outputs.size - 1);\n  });\n\n  return txSkeleton;\n}\n\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const inputLock = inputCell.cell_output.lock;\n\n  if (isSecp256k1Blake160Script(inputLock, config)) {\n    return secp256k1Blake160.setupInputCell(txSkeleton, inputCell, fromInfo, {\n      config,\n      defaultWitness,\n      since,\n    });\n  } else if (isSecp256k1Blake160MultisigScript(inputLock, config)) {\n    return secp256k1Blake160Multisig.setupInputCell(\n      txSkeleton,\n      inputCell,\n      fromInfo,\n      { config, defaultWitness, since }\n    );\n  } else {\n    throw new Error(`Not supported input lock!`);\n  }\n}\n\nfunction _parseMultisigArgsSince(args: HexString): bigint {\n  if (args.length !== 58) {\n    throw new Error(\"Invalid multisig with since args!\");\n  }\n  return readBigUInt64LE(\"0x\" + args.slice(42));\n}\n\nfunction _parseMultisigArgsSinceCompatible(args: HexString): BI {\n  if (args.length !== 58) {\n    throw new Error(\"Invalid multisig with since args!\");\n  }\n  return readBigUInt64LECompatible(\"0x\" + args.slice(42));\n}\n\nexport default {\n  CellCollector,\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  injectCapacityWithoutChange,\n  injectCapacityWithoutChangeCompatible,\n};\n"],"file":"locktime_pool.js"}