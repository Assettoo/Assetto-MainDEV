"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createP2PKHMessageGroup = createP2PKHMessageGroup;

var _base = require("@ckb-lumos/base");

var _helpers = require("@ckb-lumos/helpers");

var _toolkit = require("@ckb-lumos/toolkit");

var _bi = require("@ckb-lumos/bi");

function groupInputs(inputs, locks) {
  const lockSet = new Set();

  for (const lock of locks) {
    const scriptHash = _base.utils.ckbHash(_base.core.SerializeScript(_toolkit.normalizers.NormalizeScript(lock))).serializeJson();

    lockSet.add(scriptHash);
  }

  const groups = new Map();

  for (let i = 0; i < inputs.length; i++) {
    const scriptHash = _base.utils.ckbHash(_base.core.SerializeScript(_toolkit.normalizers.NormalizeScript(inputs[i].cell_output.lock))).serializeJson();

    if (lockSet.has(scriptHash)) {
      if (groups.get(scriptHash) === undefined) groups.set(scriptHash, []);
      groups.get(scriptHash).push(i);
    }
  }

  return groups;
}

function calcRawTxHash(tx) {
  return _base.utils.ckbHash(_base.core.SerializeRawTransaction(_toolkit.normalizers.NormalizeRawTransaction((0, _helpers.createTransactionFromSkeleton)(tx))));
}

/**
 * Return an array of messages as well as their corresponding position indexes and locks for signing a P2PKH transaction.
 * For more details, please see:
 * https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction
 *
 * @param tx TxSkeleton with all input cells' witnessArgs.lock filled with 0.
 * @param locks Locks you want to sign, e.g. you don't need to sign ACP cells.
 * @param hasher Message hasher, defaults to CKB blake2b hasher. Check
 * https://github.com/nervosnetwork/ckb-system-scripts/blob/e975e8b7d5231fdb1c537b830dd934b305492417/c/secp256k1_blake160_sighash_all.c#L22-L28 for more.
 * @returns An array of Group containing: lock of the input cell you need to sign, message for signing, witness index of this message (first index of the input cell with this lock).
 */
function createP2PKHMessageGroup(tx, locks, {
  hasher = undefined
} = {}) {
  const groups = groupInputs(tx.inputs.toArray(), locks);
  const rawTxHash = calcRawTxHash(tx);
  const defaultHasher = new _base.utils.CKBHasher();
  hasher = hasher || {
    update: message => defaultHasher.update(message.buffer),
    digest: () => new Uint8Array(defaultHasher.digestReader().toArrayBuffer())
  };
  const messageGroup = [];

  for (const group of groups.keys()) {
    const indexes = groups.get(group);
    const firstIndex = indexes[0];
    const firstWitness = tx.witnesses.get(firstIndex);

    if (firstWitness === undefined) {
      throw new Error("Please fill witnesses with 0 first!");
    }

    hasher.update(new Uint8Array(rawTxHash.toArrayBuffer()));
    const lengthBuffer = new ArrayBuffer(8);
    const view = new DataView(lengthBuffer);

    const witnessHexString = _bi.BI.from(new _toolkit.Reader(firstWitness).length()).toString(16);

    if (witnessHexString.length <= 8) {
      view.setUint32(0, Number("0x" + witnessHexString), true);
      view.setUint32(4, Number("0x" + "00000000"), true);
    }

    if (witnessHexString.length > 8 && witnessHexString.length <= 16) {
      view.setUint32(0, Number("0x" + witnessHexString.slice(-8)), true);
      view.setUint32(4, Number("0x" + witnessHexString.slice(0, -8)), true);
    }

    hasher.update(new Uint8Array(lengthBuffer));
    hasher.update(new Uint8Array(new _toolkit.Reader(firstWitness).toArrayBuffer()));

    for (let i = 1; i < indexes.length; i++) {
      const witness = tx.witnesses.get(indexes[i]);
      hasher.update(new Uint8Array(lengthBuffer));
      hasher.update(new Uint8Array(new _toolkit.Reader(witness).toArrayBuffer()));
    }

    for (let i = tx.inputs.toArray().length; i < tx.witnesses.toArray().length; i++) {
      const witness = tx.witnesses.get(i);
      hasher.update(new Uint8Array(lengthBuffer));
      hasher.update(new Uint8Array(new _toolkit.Reader(witness).toArrayBuffer()));
    }

    const g = {
      index: firstIndex,
      lock: tx.inputs.get(firstIndex).cell_output.lock,
      message: "0x" + Array.prototype.map.call(hasher.digest(), x => ("00" + x.toString(16)).slice(-2)).join("")
    };
    messageGroup.push(g);
  }

  return messageGroup;
}
//# sourceMappingURL=p2pkh.js.map