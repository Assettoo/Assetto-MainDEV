"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RPC = void 0;

var _toolkit = require("@ckb-lumos/toolkit");

var _bi = require("@ckb-lumos/bi");

function asyncSleep(ms = 0) {
  return new Promise(r => setTimeout(r, ms));
}

const handler = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get: (target, method) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return async (...params) => {
      const result = await target.rpc[method](...params);

      if (target.indexer) {
        await target.waitForBlockSync();
      }

      return result;
    };
  }
};

class RpcProxy {
  constructor(uri, indexer, {
    waitForSyncCheckIntervalSeconds = 1,
    blockDifference = 3,
    rpcOptions = {}
  } = {}) {
    this.rpc = new _toolkit.RPC(uri, rpcOptions);
    this.indexer = indexer;
    this.waitForSyncCheckIntervalSeconds = waitForSyncCheckIntervalSeconds;
    this.blockDifference = blockDifference;
  }

  resetIndexer(indexer) {
    this.indexer = indexer;
  }

  getProxy() {
    return new Proxy(this, handler);
  }

  async waitForBlockSync() {
    if (!this.indexer) {
      return;
    }

    const header = await this.rpc.get_tip_header();

    const blockNumber = _bi.BI.from(header.number);

    while (true) {
      const tip = await this.indexer.tip();

      if (tip) {
        if (blockNumber.sub(tip.block_number).lte(this.blockDifference)) {
          // TODO: do we need to handle forks?
          break;
        }
      }

      await asyncSleep(this.waitForSyncCheckIntervalSeconds * 1000);
    }
  }

}

class RPC {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any

  /**
   *
   * @param uri
   * @param indexer Will `waitForSync` after rpc call if provided.
   * @param options
   */
  constructor(uri, indexer, {
    waitForSyncCheckIntervalSeconds = 1,
    blockDifference = 3,
    rpcOptions = {}
  } = {}) {
    this.rpcProxy = new RpcProxy(uri, indexer, {
      waitForSyncCheckIntervalSeconds,
      blockDifference,
      rpcOptions
    }).getProxy();
  }
  /**
   *
   * @param indexer If not provided or be undefined, will disable `waitForSync`, and if provided, will enable `waitForSync` with provided indexer.
   */


  resetIndexer(indexer) {
    this.rpcProxy.resetIndexer(indexer);
  } // Module Chain


  async get_block(block_hash, verbosity) {
    return this.rpcProxy.get_block(block_hash, verbosity || null);
  }

  async get_block_by_number(block_number, verbosity) {
    return this.rpcProxy.get_block_by_number(block_number, verbosity || null);
  }

  async get_header(block_hash, verbosity) {
    return this.rpcProxy.get_header(block_hash, verbosity || null);
  }

  async get_header_by_number(block_number, verbosity) {
    return this.rpcProxy.get_header_by_number(block_number, verbosity || null);
  }

  async get_transaction(hash) {
    return this.rpcProxy.get_transaction(hash);
  }

  async get_block_hash(block_number) {
    return this.rpcProxy.get_block_hash(block_number);
  }

  async get_tip_header(verbosity) {
    return this.rpcProxy.get_tip_header(verbosity);
  }

  async get_live_cell(out_point, with_data) {
    return this.rpcProxy.get_live_cell(out_point, with_data);
  }

  async get_tip_block_number() {
    return this.rpcProxy.get_tip_block_number();
  }

  async get_current_epoch() {
    return this.rpcProxy.get_current_epoch();
  }

  async get_epoch_by_number(epoch_number) {
    return this.rpcProxy.get_epoch_by_number(epoch_number);
  }

  async get_block_economic_state(block_hash) {
    return this.rpcProxy.get_block_economic_state(block_hash);
  }

  async get_transaction_proof(tx_hashes, block_hash) {
    return this.rpcProxy.get_transaction_proof(tx_hashes, block_hash || null);
  }

  async verify_transaction_proof(tx_proof) {
    return this.rpcProxy.verify_transaction_proof(tx_proof);
  }

  async get_fork_block(block_hash, verbosity) {
    return this.rpcProxy.get_fork_block(block_hash, verbosity ? verbosity : null);
  }

  async get_consensus() {
    return this.rpcProxy.get_consensus();
  } // Module Experiment


  async dry_run_transaction(tx) {
    return this.rpcProxy.dry_run_transaction(tx);
  }

  async calculate_dao_maximum_withdraw(out_point, block_hash) {
    return this.rpcProxy.calculate_dao_maximum_withdraw(out_point, block_hash);
  } // Module Net


  async local_node_info() {
    return this.rpcProxy.local_node_info();
  }

  async get_peers() {
    return this.rpcProxy.get_peers();
  }

  async get_banned_addresses() {
    return this.rpcProxy.get_banned_addresses();
  }

  async clear_banned_addresses() {
    return this.rpcProxy.clear_banned_addresses();
  }

  async set_ban(address, command, ban_time, absolute, reason) {
    return this.rpcProxy.set_ban(address, command, ban_time || null, absolute !== undefined ? absolute : null, reason || null);
  }

  async sync_state() {
    return this.rpcProxy.sync_state();
  }

  async set_network_active(state) {
    return this.rpcProxy.set_network_active(state);
  }

  async add_node(peer_id, address) {
    return this.rpcProxy.add_node(peer_id, address);
  }

  async remove_node(peer_id) {
    return this.rpcProxy.remove_node(peer_id);
  }

  async ping_peers() {
    return this.rpcProxy.ping_peers();
  } // Module pool


  async send_transaction(tx, outputs_validator) {
    return this.rpcProxy.send_transaction(tx, outputs_validator || null);
  }

  async tx_pool_info() {
    return this.rpcProxy.tx_pool_info();
  }

  async clear_tx_pool() {
    return this.rpcProxy.clear_tx_pool();
  }

  async get_raw_tx_pool(verbose) {
    return this.rpcProxy.get_raw_tx_pool(verbose !== undefined ? verbose : null);
  } // Module Stats


  async get_blockchain_info() {
    return this.rpcProxy.get_blockchain_info();
  } // Module Alert


  async send_alert(alert) {
    return this.rpcProxy.send_alert(alert);
  } // Module Miner


}

exports.RPC = RPC;
//# sourceMappingURL=index.js.map