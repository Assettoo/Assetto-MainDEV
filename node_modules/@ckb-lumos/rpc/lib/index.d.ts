import { Alert, BannedAddr, Block, BlockEconomicState, CellWithStatus, ChainInfo, Consensus, DryRunResult, Epoch, Hash, Header, HexNumber, HexString, Indexer, LocalNode, OutPoint, RemoteNode, SyncState, Transaction, TransactionProof, TransactionWithStatus, TxPoolIds, TxPoolInfo, TxPoolVerbosity } from "@ckb-lumos/base";
export declare type SerializedBlock = HexString;
export declare type SerializedHeader = HexString;
export declare type OutputsValidator = "default" | "passthrough";
export declare class RPC {
    private rpcProxy;
    /**
     *
     * @param uri
     * @param indexer Will `waitForSync` after rpc call if provided.
     * @param options
     */
    constructor(uri: string, indexer?: Indexer, { waitForSyncCheckIntervalSeconds, blockDifference, rpcOptions, }?: {
        waitForSyncCheckIntervalSeconds?: number;
        blockDifference?: number;
        rpcOptions?: Record<string, unknown>;
    });
    /**
     *
     * @param indexer If not provided or be undefined, will disable `waitForSync`, and if provided, will enable `waitForSync` with provided indexer.
     */
    resetIndexer(indexer?: Indexer): void;
    get_block(block_hash: Hash, verbosity: "0x0"): Promise<SerializedBlock | null>;
    get_block(block_hash: Hash, verbosity?: "0x2"): Promise<Block | null>;
    get_block_by_number(block_number: HexNumber, verbosity: "0x0"): Promise<SerializedBlock | null>;
    get_block_by_number(block_number: HexNumber, verbosity?: "0x2"): Promise<Block | null>;
    get_header(block_hash: Hash, verbosity: "0x0"): Promise<SerializedHeader | null>;
    get_header(block_hash: Hash, verbosity?: "0x1"): Promise<Header | null>;
    get_header_by_number(block_number: HexNumber, verbosity: "0x0"): Promise<SerializedHeader | null>;
    get_header_by_number(block_number: HexNumber, verbosity?: "0x1"): Promise<Header | null>;
    get_transaction(hash: Hash): Promise<TransactionWithStatus | null>;
    get_block_hash(block_number: HexNumber): Promise<Hash | null>;
    get_tip_header(verbosity: "0x0"): Promise<SerializedHeader>;
    get_tip_header(verbosity?: "0x1"): Promise<Header>;
    get_live_cell(out_point: OutPoint, with_data: boolean): Promise<CellWithStatus>;
    get_tip_block_number(): Promise<HexNumber>;
    get_current_epoch(): Promise<Epoch>;
    get_epoch_by_number(epoch_number: HexNumber): Promise<Epoch | null>;
    get_block_economic_state(block_hash: Hash): Promise<BlockEconomicState | null>;
    get_transaction_proof(tx_hashes: Hash[], block_hash?: Hash): Promise<TransactionProof>;
    verify_transaction_proof(tx_proof: TransactionProof): Promise<Hash[]>;
    get_fork_block(block_hash: Hash, verbosity: "0x0"): Promise<SerializedBlock | null>;
    get_fork_block(block_hash: Hash, verbosity?: "0x2"): Promise<Block | null>;
    get_consensus(): Promise<Consensus>;
    dry_run_transaction(tx: Transaction): Promise<DryRunResult>;
    calculate_dao_maximum_withdraw(out_point: OutPoint, block_hash: Hash): Promise<HexNumber>;
    local_node_info(): Promise<LocalNode>;
    get_peers(): Promise<RemoteNode[]>;
    get_banned_addresses(): Promise<BannedAddr>;
    clear_banned_addresses(): Promise<null>;
    set_ban(address: string, command: string, ban_time?: HexNumber, absolute?: boolean, reason?: string): Promise<null>;
    sync_state(): Promise<SyncState>;
    set_network_active(state: boolean): Promise<null>;
    add_node(peer_id: string, address: string): Promise<null>;
    remove_node(peer_id: string): Promise<null>;
    ping_peers(): Promise<null>;
    send_transaction(tx: Transaction, outputs_validator?: OutputsValidator): Promise<Hash>;
    tx_pool_info(): Promise<TxPoolInfo>;
    clear_tx_pool(): Promise<null>;
    get_raw_tx_pool(verbose?: false): Promise<TxPoolIds>;
    get_raw_tx_pool(verbose: true): Promise<TxPoolVerbosity>;
    get_blockchain_info(): Promise<ChainInfo>;
    send_alert(alert: Alert): Promise<null>;
}
