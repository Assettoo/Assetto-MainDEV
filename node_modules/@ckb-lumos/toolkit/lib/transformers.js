"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransformBlock = TransformBlock;
exports.TransformCellDep = TransformCellDep;
exports.TransformCellInput = TransformCellInput;
exports.TransformCellOutput = TransformCellOutput;
exports.TransformCellbaseWitness = TransformCellbaseWitness;
exports.TransformHeader = TransformHeader;
exports.TransformOutPoint = TransformOutPoint;
exports.TransformRawHeader = TransformRawHeader;
exports.TransformRawTransaction = TransformRawTransaction;
exports.TransformScript = TransformScript;
exports.TransformTransaction = TransformTransaction;
exports.TransformUncleBlock = TransformUncleBlock;
exports.TransformWitnessArgs = TransformWitnessArgs;

var validators = _interopRequireWildcard(require("./validators"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// This package provides transformer functions that transform JavaScript objects
// into JSON ready objects that can be passed to RPC. It following the following
// rules:
//
// 1. If the specified object has a serializeJson method, it would invoke this
// method and use the result to replace current object.
// 2. It then restricts the keys of the object to keys required by the specified
// entity(i.e., a Script would only have code_hash, hash_type, args keys),for each
// sub-field, it then recursively perform the steps here from step 1.
// 3. It then optionally run validator functions to ensure the resulting object
// follows specified rules.
//
// Note rule 1 here provides the flexibility in defining your own structures: you
// could define a class containing custom data structures, then provide a
// serializeJson that transforms the custom one into the rigid data structure
// required by CKB. You can also leverage the Reader class we provide as much as
// possible. Since Reader class does provide serializeJson methods, transformers
// here will transform them to valid hex strings required by CKB.
function invokeSerializeJson(debugPath, value) {
  if (value instanceof Object && value.serializeJson instanceof Function) {
    return value.serializeJson.call(value);
  }

  return value;
}

function transformObject(debugPath, object, keys) {
  object = invokeSerializeJson(debugPath, object);

  if (!(object instanceof Object)) {
    throw new Error(`Transformed ${debugPath} is not an object!`);
  }

  const result = {};

  for (const [key, f] of Object.entries(keys)) {
    let value = object[key];

    if (!value) {
      const camelKey = key.replace(/(_[a-z])/g, group => group.toUpperCase().replace("_", ""));
      value = object[camelKey];
    }

    if (value) {
      result[key] = f(`${debugPath}.${key}`, value);
    }
  }

  return result;
}

function TransformScript(script, {
  validation = true,
  debugPath = "script"
} = {}) {
  script = transformObject(debugPath, script, {
    code_hash: invokeSerializeJson,
    hash_type: invokeSerializeJson,
    args: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateScript(script, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return script;
}

function TransformOutPoint(outPoint, {
  validation = true,
  debugPath = "out_point"
} = {}) {
  outPoint = transformObject(debugPath, outPoint, {
    tx_hash: invokeSerializeJson,
    index: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateOutPoint(outPoint, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return outPoint;
}

function toInvoke(transform) {
  return function (debugPath, value) {
    return transform(value, {
      validation: false,
      debugPath
    });
  };
}

function TransformCellInput(cellInput, {
  validation = true,
  debugPath = "cell_input"
} = {}) {
  cellInput = transformObject(debugPath, cellInput, {
    since: invokeSerializeJson,
    previous_output: toInvoke(TransformOutPoint)
  });

  if (validation) {
    validators.ValidateCellInput(cellInput, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return cellInput;
}

function TransformCellOutput(cellOutput, {
  validation = true,
  debugPath = "cell_output"
} = {}) {
  cellOutput = transformObject(debugPath, cellOutput, {
    capacity: invokeSerializeJson,
    lock: toInvoke(TransformScript),
    type: toInvoke(TransformScript)
  });

  if (validation) {
    validators.ValidateCellOutput(cellOutput, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return cellOutput;
}

function TransformCellDep(cellDep, {
  validation = true,
  debugPath = "cell_dep"
} = {}) {
  cellDep = transformObject(debugPath, cellDep, {
    out_point: toInvoke(TransformOutPoint),
    dep_type: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateCellDep(cellDep, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return cellDep;
}

function toInvokeArray(invokeFunction) {
  return function (debugPath, array) {
    return array.map((item, i) => {
      return invokeFunction(`${debugPath}[${i}]`, item);
    });
  };
}

function TransformRawTransaction(rawTransaction, {
  validation = true,
  debugPath = "raw_transaction"
} = {}) {
  rawTransaction = transformObject(debugPath, rawTransaction, {
    version: invokeSerializeJson,
    cell_deps: toInvokeArray(toInvoke(TransformCellDep)),
    header_deps: toInvokeArray(invokeSerializeJson),
    inputs: toInvokeArray(toInvoke(TransformCellInput)),
    outputs: toInvokeArray(toInvoke(TransformCellOutput)),
    outputs_data: toInvokeArray(invokeSerializeJson)
  });

  if (validation) {
    validators.ValidateRawTransaction(rawTransaction, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return rawTransaction;
}

function TransformTransaction(transaction, {
  validation = true,
  debugPath = "transaction"
} = {}) {
  transaction = transformObject(debugPath, transaction, {
    version: invokeSerializeJson,
    cell_deps: toInvokeArray(toInvoke(TransformCellDep)),
    header_deps: toInvokeArray(invokeSerializeJson),
    inputs: toInvokeArray(toInvoke(TransformCellInput)),
    outputs: toInvokeArray(toInvoke(TransformCellOutput)),
    outputs_data: toInvokeArray(invokeSerializeJson),
    witnesses: toInvokeArray(invokeSerializeJson)
  });

  if (validation) {
    validators.ValidateTransaction(transaction, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return transaction;
}

function TransformRawHeader(rawHeader, {
  validation = true,
  debugPath = "raw_header"
} = {}) {
  rawHeader = transformObject(debugPath, rawHeader, {
    version: invokeSerializeJson,
    compact_target: invokeSerializeJson,
    timestamp: invokeSerializeJson,
    number: invokeSerializeJson,
    epoch: invokeSerializeJson,
    parent_hash: invokeSerializeJson,
    transactions_root: invokeSerializeJson,
    proposals_hash: invokeSerializeJson,
    uncles_hash: invokeSerializeJson,
    dao: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateRawHeader(rawHeader, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return rawHeader;
}

function TransformHeader(header, {
  validation = true,
  debugPath = "header"
} = {}) {
  header = transformObject(debugPath, header, {
    version: invokeSerializeJson,
    compact_target: invokeSerializeJson,
    timestamp: invokeSerializeJson,
    number: invokeSerializeJson,
    epoch: invokeSerializeJson,
    parent_hash: invokeSerializeJson,
    transactions_root: invokeSerializeJson,
    proposals_hash: invokeSerializeJson,
    uncles_hash: invokeSerializeJson,
    dao: invokeSerializeJson,
    nonce: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateHeader(header, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return header;
}

function TransformUncleBlock(uncleBlock, {
  validation = true,
  debugPath = "uncle_block"
} = {}) {
  uncleBlock = transformObject(debugPath, uncleBlock, {
    header: toInvoke(TransformHeader),
    proposals: toInvokeArray(invokeSerializeJson)
  });

  if (validation) {
    validators.ValidateUncleBlock(uncleBlock, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return uncleBlock;
}

function TransformBlock(block, {
  validation = true,
  debugPath = "block"
} = {}) {
  block = transformObject(debugPath, block, {
    header: toInvoke(TransformHeader),
    uncles: toInvokeArray(toInvoke(TransformUncleBlock)),
    transactions: toInvokeArray(toInvoke(TransformTransaction)),
    proposals: toInvokeArray(invokeSerializeJson)
  });

  if (validation) {
    validators.ValidateBlock(block, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return block;
}

function TransformCellbaseWitness(cellbaseWitness, {
  validation = true,
  debugPath = "cellbase_witness"
} = {}) {
  cellbaseWitness = transformObject(debugPath, cellbaseWitness, {
    lock: toInvoke(TransformScript),
    message: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateCellbaseWitness(cellbaseWitness, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return cellbaseWitness;
}

function TransformWitnessArgs(witnessArgs, {
  validation = true,
  debugPath = "witness_args"
} = {}) {
  witnessArgs = transformObject(debugPath, witnessArgs, {
    lock: invokeSerializeJson,
    input_type: invokeSerializeJson,
    output_type: invokeSerializeJson
  });

  if (validation) {
    validators.ValidateWitnessArgs(witnessArgs, {
      debugPath: `(transformed) ${debugPath}`
    });
  }

  return witnessArgs;
}
//# sourceMappingURL=transformers.js.map