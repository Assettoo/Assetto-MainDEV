{"version":3,"sources":["../src/index.ts"],"names":["BECH32_LIMIT","byteArrayToHex","a","map","i","toString","slice","join","hexToByteArray","h","test","Error","startsWith","array","length","push","parseInt","minimalCellCapacity","fullCell","validate","result","minimalCellCapacityCompatible","BigInt","validators","ValidateCellOutput","cell_output","bytes","Reader","lock","code_hash","args","type","data","BI","from","mul","locateCellDep","script","config","undefined","scriptTemplate","Object","values","SCRIPTS","find","s","CODE_HASH","HASH_TYPE","hash_type","dep_type","DEP_TYPE","out_point","tx_hash","TX_HASH","index","INDEX","generateAddress","SHORT_ID","words","bech32","toWords","encode","PREFIX","scriptToAddress","generatePredefinedAddress","scriptType","template","availableKeys","keys","generateSecp256k1Blake160Address","generateSecp256k1Blake160MultisigAddress","trySeries","fns","latestCatch","fn","e","parseAddress","address","prefix","bech32m","decode","fromWords","serializedHashType","addressToScript","encodeToAddress","TransactionSkeleton","cellProvider","cellDeps","headerDeps","inputs","outputs","witnesses","fixedEntries","signingEntries","inputSinces","createTransactionFromSkeleton","txSkeleton","tx","version","cell_deps","get","toArray","header_deps","input","since","previous_output","output","outputs_data","ValidateTransaction","sealTransaction","sealingContents","size","forEach","witness","witnessArgs","core","WitnessArgs","newWitnessArgs","inputType","getInputType","hasValue","input_type","value","raw","serializeJson","outputType","getOutputType","output_type","ValidateWitnessArgs","SerializeWitnessArgs","normalizers","NormalizeWitnessArgs","transactionSkeletonToObject","txSkelton","toJS","objectToTransactionSkeleton","obj","key","entries","set"],"mappings":"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","sourcesContent":["import {\n  Address,\n  Cell,\n  CellDep,\n  CellProvider,\n  core,\n  Hash,\n  HexString,\n  PackedSince,\n  Script,\n  Transaction,\n  WitnessArgs,\n} from \"@ckb-lumos/base\";\nimport { bech32, bech32m } from \"bech32\";\nimport { normalizers, Reader, validators } from \"@ckb-lumos/toolkit\";\nimport { List, Map as ImmutableMap, Record } from \"immutable\";\nimport { Config, getConfig } from \"@ckb-lumos/config-manager\";\nimport { BI } from \"@ckb-lumos/bi\";\n\nexport interface Options {\n  config?: Config;\n}\n\nconst BECH32_LIMIT = 1023;\n\nfunction byteArrayToHex(a: number[]): HexString {\n  return \"0x\" + a.map((i) => (\"00\" + i.toString(16)).slice(-2)).join(\"\");\n}\n\nfunction hexToByteArray(h: HexString): number[] {\n  if (!/^(0x)?([0-9a-fA-F][0-9a-fA-F])*$/.test(h)) {\n    throw new Error(\"Invalid hex string!\");\n  }\n  if (h.startsWith(\"0x\")) {\n    h = h.slice(2);\n  }\n  const array = [];\n  while (h.length >= 2) {\n    array.push(parseInt(h.slice(0, 2), 16));\n    h = h.slice(2);\n  }\n  return array;\n}\n\nexport function minimalCellCapacity(\n  fullCell: Cell,\n  { validate = true }: { validate?: boolean } = {}\n): bigint {\n  const result = minimalCellCapacityCompatible(fullCell, { validate });\n  return BigInt(result.toString());\n}\n\nexport function minimalCellCapacityCompatible(\n  fullCell: Cell,\n  { validate = true }: { validate?: boolean } = {}\n): BI {\n  if (validate) {\n    validators.ValidateCellOutput(fullCell.cell_output);\n  }\n  // Capacity field itself\n  let bytes = 8;\n  bytes += new Reader(fullCell.cell_output.lock.code_hash).length();\n  bytes += new Reader(fullCell.cell_output.lock.args).length();\n  // hash_type field\n  bytes += 1;\n  if (fullCell.cell_output.type) {\n    bytes += new Reader(fullCell.cell_output.type.code_hash).length();\n    bytes += new Reader(fullCell.cell_output.type.args).length();\n    bytes += 1;\n  }\n  if (fullCell.data) {\n    bytes += new Reader(fullCell.data).length();\n  }\n  return BI.from(bytes).mul(100000000);\n}\n\nexport function locateCellDep(\n  script: Script,\n  { config = undefined }: Options = {}\n): CellDep | null {\n  config = config || getConfig();\n  const scriptTemplate = Object.values(config.SCRIPTS).find(\n    (s) =>\n      s && s.CODE_HASH === script.code_hash && s.HASH_TYPE === script.hash_type\n  );\n\n  if (scriptTemplate) {\n    return {\n      dep_type: scriptTemplate.DEP_TYPE,\n      out_point: {\n        tx_hash: scriptTemplate.TX_HASH,\n        index: scriptTemplate.INDEX,\n      },\n    };\n  }\n  return null;\n}\n\nexport function generateAddress(\n  script: Script,\n  { config = undefined }: Options = {}\n): Address {\n  config = config || getConfig();\n  const scriptTemplate = Object.values(config.SCRIPTS).find(\n    (s) =>\n      s && s.CODE_HASH === script.code_hash && s.HASH_TYPE === script.hash_type\n  );\n  const data = [];\n  if (scriptTemplate && scriptTemplate.SHORT_ID !== undefined) {\n    data.push(1, scriptTemplate.SHORT_ID);\n    data.push(...hexToByteArray(script.args));\n  } else {\n    data.push(script.hash_type === \"type\" ? 4 : 2);\n    data.push(...hexToByteArray(script.code_hash));\n    data.push(...hexToByteArray(script.args));\n  }\n  const words = bech32.toWords(data);\n  return bech32.encode(config.PREFIX, words, BECH32_LIMIT);\n}\n\nexport const scriptToAddress = generateAddress;\n\nfunction generatePredefinedAddress(\n  args: HexString,\n  scriptType: string,\n  { config = undefined }: Options = {}\n): Address {\n  config = config || getConfig();\n  const template = config.SCRIPTS[scriptType];\n  if (!template) {\n    const availableKeys = Object.keys(config.SCRIPTS);\n    throw new Error(\n      `Invalid script type: ${scriptType}, only support: ${availableKeys}`\n    );\n  }\n  const script: Script = {\n    code_hash: template.CODE_HASH,\n    hash_type: template.HASH_TYPE,\n    args,\n  };\n\n  return generateAddress(script, { config });\n}\n\nexport function generateSecp256k1Blake160Address(\n  args: HexString,\n  { config = undefined }: Options = {}\n): Address {\n  return generatePredefinedAddress(args, \"SECP256K1_BLAKE160\", { config });\n}\n\nexport function generateSecp256k1Blake160MultisigAddress(\n  args: HexString,\n  { config = undefined }: Options = {}\n): Address {\n  return generatePredefinedAddress(args, \"SECP256K1_BLAKE160_MULTISIG\", {\n    config,\n  });\n}\n\nfunction trySeries<T extends (...args: unknown[]) => unknown>(\n  ...fns: T[]\n): ReturnType<T> {\n  let latestCatch: unknown;\n  for (const fn of fns) {\n    try {\n      return fn() as ReturnType<T>;\n    } catch (e) {\n      latestCatch = e;\n    }\n  }\n  /* c8 ignore next */\n  throw latestCatch;\n}\n\nexport function parseAddress(\n  address: Address,\n  { config = undefined }: Options = {}\n): Script {\n  config = config || getConfig();\n  const { prefix, words } = trySeries(\n    () => bech32m.decode(address, BECH32_LIMIT),\n    () => bech32.decode(address, BECH32_LIMIT)\n  );\n  if (prefix !== config.PREFIX) {\n    throw Error(\n      `Invalid prefix! Expected: ${config.PREFIX}, actual: ${prefix}`\n    );\n  }\n  const data = trySeries(\n    () => bech32m.fromWords(words),\n    () => bech32.fromWords(words)\n  );\n  switch (data[0]) {\n    case 0: {\n      //  1 +   32     +    1\n      // 00  code_hash  hash_type\n      /* c8 ignore next 3 */\n      if (data.length < 34) {\n        throw new Error(`Invalid payload length!`);\n      }\n      const serializedHashType = data.slice(33, 34)[0];\n      return {\n        code_hash: byteArrayToHex(data.slice(1, 33)),\n        hash_type: (() => {\n          if (serializedHashType === 0) return \"data\" as const;\n          if (serializedHashType === 1) return \"type\" as const;\n          if (serializedHashType === 2) return \"data1\" as const;\n\n          /* c8 ignore next */\n          throw new Error(`unknown hash_type ${serializedHashType}`);\n        })(),\n        args: byteArrayToHex(data.slice(34)),\n      };\n    }\n    case 1: {\n      /* c8 ignore next 3 */\n      if (data.length < 2) {\n        throw Error(`Invalid payload length!`);\n      }\n      const scriptTemplate = Object.values(config.SCRIPTS).find(\n        (s) => s && s.SHORT_ID === data[1]\n      );\n      /* c8 ignore next 3 */\n      if (!scriptTemplate) {\n        throw Error(`Invalid code hash index: ${data[1]}!`);\n      }\n      return {\n        code_hash: scriptTemplate.CODE_HASH,\n        hash_type: scriptTemplate.HASH_TYPE,\n        args: byteArrayToHex(data.slice(2)),\n      };\n    }\n    case 2: {\n      /* c8 ignore next 3 */\n      if (data.length < 33) {\n        throw Error(`Invalid payload length!`);\n      }\n      return {\n        code_hash: byteArrayToHex(data.slice(1, 33)),\n        hash_type: \"data\",\n        args: byteArrayToHex(data.slice(33)),\n      };\n    }\n    case 4: {\n      /* c8 ignore next 3 */\n      if (data.length < 33) {\n        throw Error(`Invalid payload length!`);\n      }\n      return {\n        code_hash: byteArrayToHex(data.slice(1, 33)),\n        hash_type: \"type\",\n        args: byteArrayToHex(data.slice(33)),\n      };\n    }\n  }\n  /* c8 ignore next */\n  throw Error(`Invalid payload format type: ${data[0]}`);\n}\n\nexport const addressToScript = parseAddress;\n\nexport function encodeToAddress(\n  script: Script,\n  { config = undefined }: Options = {}\n): Address {\n  config = config || getConfig();\n\n  const data: number[] = [];\n\n  const hash_type = (() => {\n    if (script.hash_type === \"data\") return 0;\n    if (script.hash_type === \"type\") return 1;\n    if (script.hash_type === \"data1\") return 2;\n\n    /* c8 ignore next */\n    throw new Error(`unknown hash_type ${script.hash_type}`);\n  })();\n\n  data.push(0x00);\n  data.push(...hexToByteArray(script.code_hash));\n  data.push(hash_type);\n  data.push(...hexToByteArray(script.args));\n\n  return bech32m.encode(config.PREFIX, bech32m.toWords(data), BECH32_LIMIT);\n}\n\nexport interface TransactionSkeletonInterface {\n  cellProvider: CellProvider | null;\n  cellDeps: List<CellDep>;\n  headerDeps: List<Hash>;\n  inputs: List<Cell>;\n  outputs: List<Cell>;\n  witnesses: List<HexString>;\n  fixedEntries: List<{ field: string; index: number }>;\n  signingEntries: List<{ type: string; index: number; message: string }>;\n  inputSinces: ImmutableMap<number, PackedSince>;\n}\n\nexport type TransactionSkeletonType = Record<TransactionSkeletonInterface> &\n  Readonly<TransactionSkeletonInterface>;\n\nexport const TransactionSkeleton = Record<TransactionSkeletonInterface>({\n  cellProvider: null,\n  cellDeps: List(),\n  headerDeps: List(),\n  inputs: List(),\n  outputs: List(),\n  witnesses: List(),\n  fixedEntries: List(),\n  signingEntries: List(),\n  inputSinces: ImmutableMap(),\n});\n\nexport function createTransactionFromSkeleton(\n  txSkeleton: TransactionSkeletonType,\n  { validate = true }: { validate?: boolean } = {}\n): Transaction {\n  const tx: Transaction = {\n    version: \"0x0\",\n    cell_deps: txSkeleton.get(\"cellDeps\").toArray(),\n    header_deps: txSkeleton.get(\"headerDeps\").toArray(),\n    inputs: txSkeleton\n      .get(\"inputs\")\n      .map((input, i) => {\n        if (!input.out_point) {\n          throw new Error(\n            `cannot find OutPoint in Inputs[${i}] when createTransactionFromSkeleton`\n          );\n        }\n        return {\n          since: txSkeleton.get(\"inputSinces\").get(i, \"0x0\"),\n          previous_output: input.out_point,\n        };\n      })\n      .toArray(),\n    outputs: txSkeleton\n      .get(\"outputs\")\n      .map((output) => output.cell_output)\n      .toArray(),\n    outputs_data: txSkeleton\n      .get(\"outputs\")\n      .map((output) => output.data || \"0x0\")\n      .toArray(),\n    witnesses: txSkeleton.get(\"witnesses\").toArray(),\n  };\n  if (validate) {\n    validators.ValidateTransaction(tx);\n  }\n  return tx;\n}\n\nexport function sealTransaction(\n  txSkeleton: TransactionSkeletonType,\n  sealingContents: HexString[]\n): Transaction {\n  const tx = createTransactionFromSkeleton(txSkeleton);\n  if (sealingContents.length !== txSkeleton.get(\"signingEntries\").size) {\n    throw new Error(\n      `Requiring ${\n        txSkeleton.get(\"signingEntries\").size\n      } sealing contents but provided ${sealingContents.length}!`\n    );\n  }\n  txSkeleton.get(\"signingEntries\").forEach((e, i) => {\n    switch (e.type) {\n      case \"witness_args_lock\": {\n        const witness = tx.witnesses[e.index];\n        const witnessArgs = new core.WitnessArgs(new Reader(witness));\n        const newWitnessArgs: WitnessArgs = {\n          lock: sealingContents[i],\n        };\n        const inputType = witnessArgs.getInputType();\n        if (inputType.hasValue()) {\n          newWitnessArgs.input_type = new Reader(\n            inputType.value().raw()\n          ).serializeJson();\n        }\n        const outputType = witnessArgs.getOutputType();\n        if (outputType.hasValue()) {\n          newWitnessArgs.output_type = new Reader(\n            outputType.value().raw()\n          ).serializeJson();\n        }\n        validators.ValidateWitnessArgs(newWitnessArgs);\n        tx.witnesses[e.index] = new Reader(\n          core.SerializeWitnessArgs(\n            normalizers.NormalizeWitnessArgs(newWitnessArgs)\n          )\n        ).serializeJson();\n        break;\n      }\n      default:\n        throw new Error(`Invalid signing entry type: ${e.type}`);\n    }\n  });\n  return tx;\n}\n\nexport interface TransactionSkeletonObject {\n  cellProvider: CellProvider | null;\n  cellDeps: CellDep[];\n  headerDeps: Hash[];\n  inputs: Cell[];\n  outputs: Cell[];\n  witnesses: HexString[];\n  fixedEntries: Array<{ field: string; index: number }>;\n  signingEntries: Array<{ type: string; index: number; message: string }>;\n  inputSinces: Map<number, PackedSince>;\n}\n\n/**\n * Convert TransactionSkeleton to js object\n *\n * @param txSkelton\n */\nexport function transactionSkeletonToObject(\n  txSkelton: TransactionSkeletonType\n): TransactionSkeletonObject {\n  return txSkelton.toJS();\n}\n\n/**\n * Convert js object to TransactionSkeleton\n *\n * @param obj\n */\nexport function objectToTransactionSkeleton(\n  obj: TransactionSkeletonObject\n): TransactionSkeletonType {\n  let inputSinces = ImmutableMap<number, PackedSince>();\n  for (const [key, value] of Object.entries(obj.inputSinces)) {\n    inputSinces = inputSinces.set(+key, value);\n  }\n  const txSkeleton = TransactionSkeleton({\n    cellProvider: obj.cellProvider,\n    cellDeps: List(obj.cellDeps),\n    headerDeps: List(obj.headerDeps),\n    inputs: List(obj.inputs),\n    outputs: List(obj.outputs),\n    witnesses: List(obj.witnesses),\n    fixedEntries: List(obj.fixedEntries),\n    signingEntries: List(obj.signingEntries),\n    inputSinces,\n  });\n  return txSkeleton;\n}\n"],"file":"index.js"}