"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressToScript = exports.TransactionSkeleton = void 0;
exports.createTransactionFromSkeleton = createTransactionFromSkeleton;
exports.encodeToAddress = encodeToAddress;
exports.generateAddress = generateAddress;
exports.generateSecp256k1Blake160Address = generateSecp256k1Blake160Address;
exports.generateSecp256k1Blake160MultisigAddress = generateSecp256k1Blake160MultisigAddress;
exports.locateCellDep = locateCellDep;
exports.minimalCellCapacity = minimalCellCapacity;
exports.minimalCellCapacityCompatible = minimalCellCapacityCompatible;
exports.objectToTransactionSkeleton = objectToTransactionSkeleton;
exports.parseAddress = parseAddress;
exports.scriptToAddress = void 0;
exports.sealTransaction = sealTransaction;
exports.transactionSkeletonToObject = transactionSkeletonToObject;

var _base = require("@ckb-lumos/base");

var _bech = require("bech32");

var _toolkit = require("@ckb-lumos/toolkit");

var _immutable = require("immutable");

var _configManager = require("@ckb-lumos/config-manager");

var _bi = require("@ckb-lumos/bi");

const BECH32_LIMIT = 1023;

function byteArrayToHex(a) {
  return "0x" + a.map(i => ("00" + i.toString(16)).slice(-2)).join("");
}

function hexToByteArray(h) {
  if (!/^(0x)?([0-9a-fA-F][0-9a-fA-F])*$/.test(h)) {
    throw new Error("Invalid hex string!");
  }

  if (h.startsWith("0x")) {
    h = h.slice(2);
  }

  const array = [];

  while (h.length >= 2) {
    array.push(parseInt(h.slice(0, 2), 16));
    h = h.slice(2);
  }

  return array;
}

function minimalCellCapacity(fullCell, {
  validate = true
} = {}) {
  const result = minimalCellCapacityCompatible(fullCell, {
    validate
  });
  return BigInt(result.toString());
}

function minimalCellCapacityCompatible(fullCell, {
  validate = true
} = {}) {
  if (validate) {
    _toolkit.validators.ValidateCellOutput(fullCell.cell_output);
  } // Capacity field itself


  let bytes = 8;
  bytes += new _toolkit.Reader(fullCell.cell_output.lock.code_hash).length();
  bytes += new _toolkit.Reader(fullCell.cell_output.lock.args).length(); // hash_type field

  bytes += 1;

  if (fullCell.cell_output.type) {
    bytes += new _toolkit.Reader(fullCell.cell_output.type.code_hash).length();
    bytes += new _toolkit.Reader(fullCell.cell_output.type.args).length();
    bytes += 1;
  }

  if (fullCell.data) {
    bytes += new _toolkit.Reader(fullCell.data).length();
  }

  return _bi.BI.from(bytes).mul(100000000);
}

function locateCellDep(script, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const scriptTemplate = Object.values(config.SCRIPTS).find(s => s && s.CODE_HASH === script.code_hash && s.HASH_TYPE === script.hash_type);

  if (scriptTemplate) {
    return {
      dep_type: scriptTemplate.DEP_TYPE,
      out_point: {
        tx_hash: scriptTemplate.TX_HASH,
        index: scriptTemplate.INDEX
      }
    };
  }

  return null;
}

function generateAddress(script, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const scriptTemplate = Object.values(config.SCRIPTS).find(s => s && s.CODE_HASH === script.code_hash && s.HASH_TYPE === script.hash_type);
  const data = [];

  if (scriptTemplate && scriptTemplate.SHORT_ID !== undefined) {
    data.push(1, scriptTemplate.SHORT_ID);
    data.push(...hexToByteArray(script.args));
  } else {
    data.push(script.hash_type === "type" ? 4 : 2);
    data.push(...hexToByteArray(script.code_hash));
    data.push(...hexToByteArray(script.args));
  }

  const words = _bech.bech32.toWords(data);

  return _bech.bech32.encode(config.PREFIX, words, BECH32_LIMIT);
}

const scriptToAddress = generateAddress;
exports.scriptToAddress = scriptToAddress;

function generatePredefinedAddress(args, scriptType, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    const availableKeys = Object.keys(config.SCRIPTS);
    throw new Error(`Invalid script type: ${scriptType}, only support: ${availableKeys}`);
  }

  const script = {
    code_hash: template.CODE_HASH,
    hash_type: template.HASH_TYPE,
    args
  };
  return generateAddress(script, {
    config
  });
}

function generateSecp256k1Blake160Address(args, {
  config = undefined
} = {}) {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160", {
    config
  });
}

function generateSecp256k1Blake160MultisigAddress(args, {
  config = undefined
} = {}) {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160_MULTISIG", {
    config
  });
}

function trySeries(...fns) {
  let latestCatch;

  for (const fn of fns) {
    try {
      return fn();
    } catch (e) {
      latestCatch = e;
    }
  }
  /* c8 ignore next */


  throw latestCatch;
}

function parseAddress(address, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const {
    prefix,
    words
  } = trySeries(() => _bech.bech32m.decode(address, BECH32_LIMIT), () => _bech.bech32.decode(address, BECH32_LIMIT));

  if (prefix !== config.PREFIX) {
    throw Error(`Invalid prefix! Expected: ${config.PREFIX}, actual: ${prefix}`);
  }

  const data = trySeries(() => _bech.bech32m.fromWords(words), () => _bech.bech32.fromWords(words));

  switch (data[0]) {
    case 0:
      {
        //  1 +   32     +    1
        // 00  code_hash  hash_type

        /* c8 ignore next 3 */
        if (data.length < 34) {
          throw new Error(`Invalid payload length!`);
        }

        const serializedHashType = data.slice(33, 34)[0];
        return {
          code_hash: byteArrayToHex(data.slice(1, 33)),
          hash_type: (() => {
            if (serializedHashType === 0) return "data";
            if (serializedHashType === 1) return "type";
            if (serializedHashType === 2) return "data1";
            /* c8 ignore next */

            throw new Error(`unknown hash_type ${serializedHashType}`);
          })(),
          args: byteArrayToHex(data.slice(34))
        };
      }

    case 1:
      {
        /* c8 ignore next 3 */
        if (data.length < 2) {
          throw Error(`Invalid payload length!`);
        }

        const scriptTemplate = Object.values(config.SCRIPTS).find(s => s && s.SHORT_ID === data[1]);
        /* c8 ignore next 3 */

        if (!scriptTemplate) {
          throw Error(`Invalid code hash index: ${data[1]}!`);
        }

        return {
          code_hash: scriptTemplate.CODE_HASH,
          hash_type: scriptTemplate.HASH_TYPE,
          args: byteArrayToHex(data.slice(2))
        };
      }

    case 2:
      {
        /* c8 ignore next 3 */
        if (data.length < 33) {
          throw Error(`Invalid payload length!`);
        }

        return {
          code_hash: byteArrayToHex(data.slice(1, 33)),
          hash_type: "data",
          args: byteArrayToHex(data.slice(33))
        };
      }

    case 4:
      {
        /* c8 ignore next 3 */
        if (data.length < 33) {
          throw Error(`Invalid payload length!`);
        }

        return {
          code_hash: byteArrayToHex(data.slice(1, 33)),
          hash_type: "type",
          args: byteArrayToHex(data.slice(33))
        };
      }
  }
  /* c8 ignore next */


  throw Error(`Invalid payload format type: ${data[0]}`);
}

const addressToScript = parseAddress;
exports.addressToScript = addressToScript;

function encodeToAddress(script, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const data = [];

  const hash_type = (() => {
    if (script.hash_type === "data") return 0;
    if (script.hash_type === "type") return 1;
    if (script.hash_type === "data1") return 2;
    /* c8 ignore next */

    throw new Error(`unknown hash_type ${script.hash_type}`);
  })();

  data.push(0x00);
  data.push(...hexToByteArray(script.code_hash));
  data.push(hash_type);
  data.push(...hexToByteArray(script.args));
  return _bech.bech32m.encode(config.PREFIX, _bech.bech32m.toWords(data), BECH32_LIMIT);
}

const TransactionSkeleton = (0, _immutable.Record)({
  cellProvider: null,
  cellDeps: (0, _immutable.List)(),
  headerDeps: (0, _immutable.List)(),
  inputs: (0, _immutable.List)(),
  outputs: (0, _immutable.List)(),
  witnesses: (0, _immutable.List)(),
  fixedEntries: (0, _immutable.List)(),
  signingEntries: (0, _immutable.List)(),
  inputSinces: (0, _immutable.Map)()
});
exports.TransactionSkeleton = TransactionSkeleton;

function createTransactionFromSkeleton(txSkeleton, {
  validate = true
} = {}) {
  const tx = {
    version: "0x0",
    cell_deps: txSkeleton.get("cellDeps").toArray(),
    header_deps: txSkeleton.get("headerDeps").toArray(),
    inputs: txSkeleton.get("inputs").map((input, i) => {
      if (!input.out_point) {
        throw new Error(`cannot find OutPoint in Inputs[${i}] when createTransactionFromSkeleton`);
      }

      return {
        since: txSkeleton.get("inputSinces").get(i, "0x0"),
        previous_output: input.out_point
      };
    }).toArray(),
    outputs: txSkeleton.get("outputs").map(output => output.cell_output).toArray(),
    outputs_data: txSkeleton.get("outputs").map(output => output.data || "0x0").toArray(),
    witnesses: txSkeleton.get("witnesses").toArray()
  };

  if (validate) {
    _toolkit.validators.ValidateTransaction(tx);
  }

  return tx;
}

function sealTransaction(txSkeleton, sealingContents) {
  const tx = createTransactionFromSkeleton(txSkeleton);

  if (sealingContents.length !== txSkeleton.get("signingEntries").size) {
    throw new Error(`Requiring ${txSkeleton.get("signingEntries").size} sealing contents but provided ${sealingContents.length}!`);
  }

  txSkeleton.get("signingEntries").forEach((e, i) => {
    switch (e.type) {
      case "witness_args_lock":
        {
          const witness = tx.witnesses[e.index];
          const witnessArgs = new _base.core.WitnessArgs(new _toolkit.Reader(witness));
          const newWitnessArgs = {
            lock: sealingContents[i]
          };
          const inputType = witnessArgs.getInputType();

          if (inputType.hasValue()) {
            newWitnessArgs.input_type = new _toolkit.Reader(inputType.value().raw()).serializeJson();
          }

          const outputType = witnessArgs.getOutputType();

          if (outputType.hasValue()) {
            newWitnessArgs.output_type = new _toolkit.Reader(outputType.value().raw()).serializeJson();
          }

          _toolkit.validators.ValidateWitnessArgs(newWitnessArgs);

          tx.witnesses[e.index] = new _toolkit.Reader(_base.core.SerializeWitnessArgs(_toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
          break;
        }

      default:
        throw new Error(`Invalid signing entry type: ${e.type}`);
    }
  });
  return tx;
}

/**
 * Convert TransactionSkeleton to js object
 *
 * @param txSkelton
 */
function transactionSkeletonToObject(txSkelton) {
  return txSkelton.toJS();
}
/**
 * Convert js object to TransactionSkeleton
 *
 * @param obj
 */


function objectToTransactionSkeleton(obj) {
  let inputSinces = (0, _immutable.Map)();

  for (const [key, value] of Object.entries(obj.inputSinces)) {
    inputSinces = inputSinces.set(+key, value);
  }

  const txSkeleton = TransactionSkeleton({
    cellProvider: obj.cellProvider,
    cellDeps: (0, _immutable.List)(obj.cellDeps),
    headerDeps: (0, _immutable.List)(obj.headerDeps),
    inputs: (0, _immutable.List)(obj.inputs),
    outputs: (0, _immutable.List)(obj.outputs),
    witnesses: (0, _immutable.List)(obj.witnesses),
    fixedEntries: (0, _immutable.List)(obj.fixedEntries),
    signingEntries: (0, _immutable.List)(obj.signingEntries),
    inputSinces
  });
  return txSkeleton;
}
//# sourceMappingURL=index.js.map