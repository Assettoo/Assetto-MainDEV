"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extraInputs = void 0;
const tslib_1 = require("tslib");
const jsbi_1 = (0, tslib_1.__importDefault)(require("jsbi"));
const calculateTransactionFee_1 = (0, tslib_1.__importDefault)(require("../calculateTransactionFee"));
const sizes_1 = require("../sizes");
const exceptions_1 = require("../exceptions");
const extraInputs = (params) => {
    const changeThreshold = jsbi_1.default.BigInt(`${params.changeThreshold}`);
    const feeRate = jsbi_1.default.BigInt(`${params.feeRate}`);
    const currentChangeOutput = params.tx.outputs[params.tx.outputs.length - 1];
    const currentChange = jsbi_1.default.BigInt(currentChangeOutput.capacity);
    const fee = jsbi_1.default.BigInt((0, calculateTransactionFee_1.default)(`0x${(0, sizes_1.getTransactionSize)(params.tx).toString(16)}`, `0x${feeRate.toString(16)}`));
    const lack = jsbi_1.default.subtract(jsbi_1.default.add(fee, changeThreshold), currentChange);
    if (jsbi_1.default.LE(lack, jsbi_1.default.BigInt(0))) {
        return Object.assign(Object.assign({}, params.tx), { outputs: [
                ...params.tx.outputs.slice(0, -1),
                Object.assign(Object.assign({}, currentChangeOutput), { capacity: `0x${jsbi_1.default.subtract(currentChange, fee).toString(16)}` }),
            ] });
    }
    params.cells.sort((c1, c2) => +jsbi_1.default.subtract(jsbi_1.default.BigInt(c1.capacity), jsbi_1.default.BigInt(c2.capacity)));
    const SIZE_PER_INPUT = jsbi_1.default.BigInt(44);
    const FEE_PER_INPUT = jsbi_1.default.divide(jsbi_1.default.multiply(SIZE_PER_INPUT, feeRate), jsbi_1.default.BigInt(1000));
    for (let i = 1; i <= Math.min(params.extraCount, params.cells.length); i++) {
        const extraCost = jsbi_1.default.multiply(jsbi_1.default.BigInt(i), FEE_PER_INPUT);
        const totalLack = jsbi_1.default.add(lack, extraCost);
        const extraCapacity = params.cells
            .slice(0, i)
            .reduce((sum, c) => jsbi_1.default.add(sum, jsbi_1.default.BigInt(c.capacity)), jsbi_1.default.BigInt(0));
        if (jsbi_1.default.GE(extraCapacity, totalLack)) {
            const inputs = [
                ...params.tx.inputs,
                ...params.cells.slice(0, i).map(c => ({
                    previousOutput: c.outPoint,
                    since: '0x0',
                })),
            ];
            const change = jsbi_1.default.add(changeThreshold, jsbi_1.default.subtract(extraCapacity, totalLack));
            const changeOutput = Object.assign(Object.assign({}, currentChangeOutput), { capacity: `0x${change.toString(16)}` });
            const outputs = [...params.tx.outputs.slice(0, -1), changeOutput];
            const tx = Object.assign(Object.assign({}, params.tx), { inputs, outputs });
            return tx;
        }
    }
    throw new exceptions_1.ReconciliationException();
};
exports.extraInputs = extraInputs;
exports.default = exports.extraInputs;
//# sourceMappingURL=extraInputs.js.map