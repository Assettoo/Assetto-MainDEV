"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeOption = exports.serializeTable = exports.serializeDynVec = exports.serializeFixVec = exports.serializeStruct = exports.serializeArray = exports.getOffsets = exports.fullLengthSize = exports.offsetSize = void 0;
const convertors_1 = require("../convertors");
exports.offsetSize = 4;
exports.fullLengthSize = 4;
const getOffsets = (elmLengths) => {
    const headerLength = exports.fullLengthSize + exports.offsetSize * elmLengths.length;
    const offsets = [headerLength];
    elmLengths.forEach((_, idx) => {
        if (idx) {
            offsets.push(offsets[offsets.length - 1] + elmLengths[idx - 1]);
        }
    });
    return offsets;
};
exports.getOffsets = getOffsets;
const serializeArray = (array) => {
    if (typeof array !== 'string' && !Array.isArray(array)) {
        throw new TypeError('The array to be serialized should by type of string or bytes');
    }
    const bytes = typeof array === 'string' ? (0, convertors_1.hexToBytes)(array) : array;
    return (0, convertors_1.bytesToHex)(bytes);
};
exports.serializeArray = serializeArray;
const serializeStruct = (struct) => {
    let res = '';
    struct.forEach(value => {
        res += (0, exports.serializeArray)(value).slice(2);
    });
    return `0x${res}`;
};
exports.serializeStruct = serializeStruct;
const serializeFixVec = (fixVec) => {
    if (typeof fixVec !== 'string' && !Array.isArray(fixVec)) {
        throw new TypeError('The fixed vector to be serialized should be a string or an array of bytes');
    }
    const vec = typeof fixVec === 'string' ? [...(0, convertors_1.hexToBytes)(fixVec)].map(b => `0x${b.toString(16)}`) : fixVec;
    const serializedItemVec = vec.map(item => (0, exports.serializeArray)(item).slice(2));
    const header = (0, convertors_1.toUint32Le)(`0x${serializedItemVec.length.toString(16)}`).slice(2);
    return `0x${header}${serializedItemVec.join('')}`;
};
exports.serializeFixVec = serializeFixVec;
const serializeDynVec = (dynVec) => {
    if (!Array.isArray(dynVec)) {
        throw new TypeError('The dynamic vector to be serialized should be an array of bytes');
    }
    const serializedItemVec = dynVec.map(item => (0, exports.serializeArray)(item).slice(2));
    const body = serializedItemVec.join('');
    let offsets = '';
    if (serializedItemVec.length) {
        offsets = (0, exports.getOffsets)(serializedItemVec.map(item => item.length / 2))
            .map(offset => (0, convertors_1.toUint32Le)(`0x${offset.toString(16)}`).slice(2))
            .join('');
    }
    const headerLength = exports.fullLengthSize + exports.offsetSize * serializedItemVec.length;
    const fullLength = (0, convertors_1.toUint32Le)(`0x${(headerLength + body.length / 2).toString(16)}`).slice(2);
    return `0x${fullLength}${offsets}${body}`;
};
exports.serializeDynVec = serializeDynVec;
const serializeTable = (table) => {
    const bodyElms = [];
    table.forEach(value => {
        bodyElms.push((0, exports.serializeArray)(value).slice(2));
    });
    const body = bodyElms.join('');
    const headerLength = exports.fullLengthSize + exports.offsetSize * table.size;
    const fullLength = (0, convertors_1.toUint32Le)(`0x${(headerLength + body.length / 2).toString(16)}`).slice(2);
    const offsets = (0, exports.getOffsets)(bodyElms.map(arg => arg.length / 2))
        .map(offset => (0, convertors_1.toUint32Le)(`0x${offset.toString(16)}`).slice(2))
        .join('');
    return `0x${fullLength}${offsets}${body}`;
};
exports.serializeTable = serializeTable;
const serializeOption = (innerItem) => (!innerItem ? '0x' : innerItem);
exports.serializeOption = serializeOption;
//# sourceMappingURL=basic.js.map