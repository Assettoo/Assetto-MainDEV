"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToScript = exports.parseAddress = exports.pubkeyToAddress = exports.fullPayloadToAddress = exports.bech32Address = exports.toAddressPayload = exports.scriptToAddress = exports.AddressType = exports.AddressPrefix = void 0;
const __1 = require("..");
const systemScripts_1 = require("../systemScripts");
const convertors_1 = require("../convertors");
const exceptions_1 = require("../exceptions");
const MAX_BECH32_LIMIT = 1023;
var AddressPrefix;
(function (AddressPrefix) {
    AddressPrefix["Mainnet"] = "ckb";
    AddressPrefix["Testnet"] = "ckt";
})(AddressPrefix = exports.AddressPrefix || (exports.AddressPrefix = {}));
var AddressType;
(function (AddressType) {
    AddressType["FullVersion"] = "0x00";
    AddressType["HashIdx"] = "0x01";
    AddressType["DataCodeHash"] = "0x02";
    AddressType["TypeCodeHash"] = "0x04";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
const payloadToAddress = (payload, isMainnet = true) => __1.bech32m.encode(isMainnet ? AddressPrefix.Mainnet : AddressPrefix.Testnet, __1.bech32m.toWords(payload), MAX_BECH32_LIMIT);
const scriptToPayload = ({ codeHash, hashType, args }) => {
    if (!args.startsWith('0x')) {
        throw new exceptions_1.HexStringWithout0xException(args);
    }
    if (!codeHash.startsWith('0x') || codeHash.length !== 66) {
        throw new exceptions_1.CodeHashException(codeHash);
    }
    let HashType;
    (function (HashType) {
        HashType["data"] = "00";
        HashType["type"] = "01";
        HashType["data1"] = "02";
    })(HashType || (HashType = {}));
    if (!HashType[hashType]) {
        throw new exceptions_1.HashTypeException(hashType);
    }
    return (0, convertors_1.hexToBytes)(`0x00${codeHash.slice(2)}${HashType[hashType]}${args.slice(2)}`);
};
const scriptToAddress = (script, isMainnet = true) => payloadToAddress(scriptToPayload(script), isMainnet);
exports.scriptToAddress = scriptToAddress;
const toAddressPayload = (args, type = AddressType.HashIdx, codeHashOrCodeHashIndex = '0x00', hashType) => {
    if (typeof args === 'string' && !args.startsWith('0x')) {
        throw new exceptions_1.HexStringWithout0xException(args);
    }
    if ([AddressType.DataCodeHash, AddressType.TypeCodeHash].includes(type)) {
        console.warn(`Address of 'AddressType.DataCodeHash' or 'AddressType.TypeCodeHash' is deprecated, please use address of AddressPrefix.FullVersion`);
    }
    if (type !== AddressType.FullVersion) {
        return new Uint8Array([
            ...(0, convertors_1.hexToBytes)(type),
            ...(0, convertors_1.hexToBytes)(codeHashOrCodeHashIndex),
            ...(typeof args === 'string' ? (0, convertors_1.hexToBytes)(args) : args),
        ]);
    }
    if (!codeHashOrCodeHashIndex.startsWith('0x') || codeHashOrCodeHashIndex.length !== 66) {
        throw new exceptions_1.CodeHashException(codeHashOrCodeHashIndex);
    }
    if (!hashType) {
        throw new exceptions_1.ParameterRequiredException('hashType');
    }
    return scriptToPayload({
        codeHash: codeHashOrCodeHashIndex,
        hashType,
        args: typeof args === 'string' ? args : (0, convertors_1.bytesToHex)(args),
    });
};
exports.toAddressPayload = toAddressPayload;
const bech32Address = (args, { prefix = AddressPrefix.Mainnet, type = AddressType.HashIdx, codeHashOrCodeHashIndex = '0x00' } = {}) => __1.bech32.encode(prefix, __1.bech32.toWords((0, exports.toAddressPayload)(args, type, codeHashOrCodeHashIndex)), MAX_BECH32_LIMIT);
exports.bech32Address = bech32Address;
const fullPayloadToAddress = ({ args, prefix, type = AddressType.DataCodeHash, codeHash, }) => (0, exports.bech32Address)(args, { prefix, type, codeHashOrCodeHashIndex: codeHash });
exports.fullPayloadToAddress = fullPayloadToAddress;
const pubkeyToAddress = (pubkey, options = {}) => {
    const publicKeyHash = (0, __1.blake160)(pubkey);
    return (0, exports.bech32Address)(publicKeyHash, options);
};
exports.pubkeyToAddress = pubkeyToAddress;
const isValidShortVersionPayload = (payload) => {
    const [, index, ...data] = payload;
    switch (index) {
        case 0:
        case 1: {
            if (data.length !== 20) {
                throw new exceptions_1.AddressPayloadException(payload, 'short');
            }
            break;
        }
        case 2: {
            if (data.length === 20 || data.length === 22 || data.length === 24) {
                break;
            }
            throw new exceptions_1.AddressPayloadException(payload, 'short');
        }
        default: {
            throw new exceptions_1.AddressPayloadException(payload, 'short');
        }
    }
};
const isPayloadValid = (payload) => {
    const type = payload[0];
    const data = payload.slice(1);
    switch (type) {
        case +AddressType.HashIdx: {
            isValidShortVersionPayload(payload);
            break;
        }
        case +AddressType.DataCodeHash:
        case +AddressType.TypeCodeHash: {
            if (data.length < 32) {
                throw new exceptions_1.AddressPayloadException(payload, 'full');
            }
            break;
        }
        case +AddressType.FullVersion: {
            const codeHash = data.slice(0, 32);
            if (codeHash.length < 32) {
                throw new exceptions_1.CodeHashException((0, convertors_1.bytesToHex)(codeHash));
            }
            const hashType = parseInt(data[32].toString(), 16);
            if (hashType > 2) {
                throw new exceptions_1.HashTypeException(`0x${hashType.toString(16)}`);
            }
            break;
        }
        default: {
            throw new exceptions_1.AddressPayloadException(payload);
        }
    }
};
const parseAddress = (address, encode = 'binary') => {
    let payload = new Uint8Array();
    try {
        const decoded = __1.bech32.decode(address, MAX_BECH32_LIMIT);
        payload = new Uint8Array(__1.bech32.fromWords(new Uint8Array(decoded.words)));
    }
    catch (_a) {
        const decoded = __1.bech32m.decode(address, MAX_BECH32_LIMIT);
        payload = new Uint8Array(__1.bech32m.fromWords(new Uint8Array(decoded.words)));
    }
    try {
        isPayloadValid(payload);
    }
    catch (err) {
        throw new exceptions_1.AddressException(address, err.stack, err.type);
    }
    return encode === 'binary' ? payload : (0, convertors_1.bytesToHex)(payload);
};
exports.parseAddress = parseAddress;
const addressToScript = (address) => {
    const payload = (0, exports.parseAddress)(address);
    const type = payload[0];
    if (type === +AddressType.FullVersion) {
        const HASH_TYPE = {
            '00': 'data',
            '01': 'type',
            '02': 'data1',
        };
        const p = (0, convertors_1.bytesToHex)(payload);
        const codeHash = `0x${p.substr(4, 64)}`;
        const hashType = HASH_TYPE[p.substr(68, 2)];
        const args = `0x${p.substr(70)}`;
        return { codeHash, hashType, args };
    }
    if (type === +AddressType.HashIdx) {
        const codeHashIndices = [
            systemScripts_1.SECP256K1_BLAKE160,
            systemScripts_1.SECP256K1_MULTISIG,
            address.startsWith(AddressPrefix.Mainnet) ? systemScripts_1.ANYONE_CAN_PAY_MAINNET : systemScripts_1.ANYONE_CAN_PAY_TESTNET,
        ];
        const index = payload[1];
        const args = payload.slice(2);
        const script = codeHashIndices[index];
        return {
            codeHash: script.codeHash,
            hashType: script.hashType,
            args: (0, convertors_1.bytesToHex)(args),
        };
    }
    const codeHashAndArgs = (0, convertors_1.bytesToHex)(payload.slice(1));
    const hashType = type === +AddressType.DataCodeHash ? 'data' : 'type';
    return {
        codeHash: codeHashAndArgs.substr(0, 66),
        hashType,
        args: `0x${codeHashAndArgs.substr(66)}`,
    };
};
exports.addressToScript = addressToScript;
//# sourceMappingURL=index.js.map