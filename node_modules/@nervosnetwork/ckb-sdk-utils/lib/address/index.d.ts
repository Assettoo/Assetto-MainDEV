/// <reference types="@nervosnetwork/ckb-types" />
export declare enum AddressPrefix {
    Mainnet = "ckb",
    Testnet = "ckt"
}
export declare enum AddressType {
    FullVersion = "0x00",
    HashIdx = "0x01",
    DataCodeHash = "0x02",
    TypeCodeHash = "0x04"
}
export declare const scriptToAddress: (script: CKBComponents.Script, isMainnet?: boolean) => string;
export declare type CodeHashIndex = '0x00' | '0x01' | '0x02';
export interface AddressOptions {
    prefix?: AddressPrefix;
    type?: AddressType;
    codeHashOrCodeHashIndex?: CodeHashIndex | CKBComponents.Hash256;
}
export declare const toAddressPayload: (args: string | Uint8Array, type?: AddressType, codeHashOrCodeHashIndex?: CodeHashIndex | CKBComponents.Hash256, hashType?: CKBComponents.ScriptHashType | undefined) => Uint8Array;
export declare const bech32Address: (args: Uint8Array | string, { prefix, type, codeHashOrCodeHashIndex }?: AddressOptions) => string;
export declare const fullPayloadToAddress: ({ args, prefix, type, codeHash, }: {
    args: string;
    prefix?: AddressPrefix | undefined;
    type?: AddressType.DataCodeHash | AddressType.TypeCodeHash | undefined;
    codeHash: CKBComponents.Hash256;
}) => string;
export declare const pubkeyToAddress: (pubkey: Uint8Array | string, options?: AddressOptions) => string;
export declare interface ParseAddress {
    (address: string): Uint8Array;
    (address: string, encode: 'binary'): Uint8Array;
    (address: string, encode: 'hex'): string;
    (address: string, encode: 'binary' | 'hex'): Uint8Array | string;
}
export declare const parseAddress: ParseAddress;
export declare const addressToScript: (address: string) => CKBComponents.Script;
