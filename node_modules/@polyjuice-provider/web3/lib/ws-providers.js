"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyjuiceWebsocketProvider = void 0;
const base_1 = require("@polyjuice-provider/base");
const web3_core_helpers_1 = require("web3-core-helpers");
const Web3WsProvider = require("web3-providers-ws");
class PolyjuiceWebsocketProvider extends Web3WsProvider {
    constructor(host, polyjuiceConfig, option) {
        super(host, option);
        this.signer = new base_1.Signer();
        const godwoker_option = {
            godwoken: {
                rollup_type_hash: polyjuiceConfig.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuiceConfig.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
            polyjuice: {
                creator_id: polyjuiceConfig.creatorId,
                default_from_address: polyjuiceConfig.defaultFromAddress,
            },
        };
        if (!polyjuiceConfig.web3Url || !(0, base_1.verifyHttpUrl)(polyjuiceConfig.web3Url)) {
            throw new Error("You must provide web3 http-protocol URL in PolyjuiceConfig when using polyjuice websocket provider. this restrict might be removed in the future. but right now, please bear with this method.");
        }
        this.godwoker = new base_1.Godwoker(polyjuiceConfig.web3Url, godwoker_option); // must use http url here
        this.abi = new base_1.Abi(polyjuiceConfig.abiItems || []);
        this.deployAddressMapping = [];
        this.deploymentRecords = {};
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    setMultiAbi(abiItemsArray) {
        const abiItems = [].concat.apply([], abiItemsArray);
        this.abi = new base_1.Abi(abiItems);
    }
    addAbi(_abiItems) {
        const abiItems = this.abi.get_abi_items().concat(_abiItems);
        this.abi = new base_1.Abi(abiItems);
    }
    async convertDeployArgs(args, abiItems, bytecode) {
        const convertResult = await (0, base_1.convertContractConstructorArgs)(args, abiItems, bytecode, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
        // later when sending this deployment transaction,
        // we will submit this.deployContractAddressMapping to web3 as well,
        // for saving address mapping if needed.
        this.deployAddressMapping = convertResult.addressMapping;
        // deploymentRecords will be used to extract constructor args from eth_tx's input data
        this.deploymentRecords = {
            ...this.deploymentRecords,
            ...convertResult.deploymentRecords,
        };
        return convertResult.newArgs;
    }
    async send(payload, callback) {
        const _this = this;
        let id = payload.id;
        const request = { payload: payload, callback: callback };
        if (Array.isArray(payload)) {
            id = payload[0].id;
        }
        if (this.connection.readyState === this.connection.CONNECTING ||
            this.reconnecting) {
            this.requestQueue.set(id, request);
            return;
        }
        if (this.connection.readyState !== this.connection.OPEN) {
            this.requestQueue.delete(id);
            this.emit(this.ERROR, web3_core_helpers_1.errors.ConnectionNotOpenError());
            request.callback(web3_core_helpers_1.errors.ConnectionNotOpenError());
            return;
        }
        this.responseQueue.set(id, request);
        this.requestQueue.delete(id);
        try {
            await this.godwoker.init();
            const { id: _id, method, params } = payload;
            const jsonRpcId = +_id;
            switch (method) {
                case "eth_sendRawTransaction":
                    // todo: forbidden normal eth raw tx pass.
                    try {
                        const tx_hash = await this.godwoker.poly_submitSerializedL2Transaction(params[0]);
                        const res = {
                            jsonrpc: payload.jsonrpc,
                            id: jsonRpcId,
                            result: tx_hash,
                        };
                        callback(null, res);
                        this.simulateWebsocketResponse(res, id);
                    }
                    catch (error) {
                        request.callback(error);
                        _this.responseQueue.delete(id);
                    }
                    break;
                case "eth_sendTransaction":
                    try {
                        const { from, gas, gasPrice, value, data } = params[0];
                        const to = (0, base_1.formalizeEthToAddress)(params[0].to);
                        const t = {
                            from: from,
                            to: to,
                            value: value || 0,
                            data: data || "",
                            gas: gas,
                            gasPrice: gasPrice,
                        };
                        const signingMethod = async (message) => {
                            return await this.signer.sign_with_metamask(message, from);
                        };
                        const rawTxString = t.to === base_1.DEFAULT_EMPTY_ETH_ADDRESS
                            ? await (0, base_1.buildDeployProcess)(this.deployAddressMapping, this.deploymentRecords, this.abi, this.godwoker, t, signingMethod.bind(this), base_1.SigningMessageType.noPrefix)
                            : await (0, base_1.buildSendTransaction)(this.abi, this.godwoker, t, signingMethod.bind(this), base_1.SigningMessageType.noPrefix);
                        const tx_hash = await this.godwoker.poly_submitSerializedL2Transaction(rawTxString);
                        // await this.godwoker.waitForTransactionReceipt(tx_hash);
                        const res = {
                            jsonrpc: payload.jsonrpc,
                            id: jsonRpcId,
                            result: tx_hash,
                        };
                        callback(null, res);
                        this.simulateWebsocketResponse(res, id);
                    }
                    catch (error) {
                        request.callback(error);
                        _this.responseQueue.delete(id);
                    }
                    break;
                case "eth_call":
                    try {
                        const { from, gas, gasPrice, value, data, to } = params[0];
                        const t = {
                            from: from || this.godwoker.default_from_address,
                            to: to,
                            value: value || 0,
                            data: data || "",
                            gas: gas || base_1.POLY_MAX_TRANSACTION_GAS_LIMIT,
                            gasPrice: gasPrice || base_1.POLY_MIN_GAS_PRICE,
                        };
                        const return_data = await (0, base_1.executeCallTransaction)(this.abi, this.godwoker, t);
                        const res = {
                            jsonrpc: payload.jsonrpc,
                            id: jsonRpcId,
                            result: return_data,
                        };
                        callback(null, res);
                        this.simulateWebsocketResponse(res, id);
                    }
                    catch (error) {
                        request.callback(error);
                        _this.responseQueue.delete(id);
                    }
                    break;
                case "eth_estimateGas":
                    try {
                        let new_payload = payload;
                        const { data } = params[0];
                        const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                        new_payload.params[0].data = data_with_short_address;
                        new_payload.params[0].from =
                            new_payload.params[0].from || this.godwoker.default_from_address;
                        this.connection.send(JSON.stringify(new_payload)); // this should be handle by provider
                    }
                    catch (error) {
                        request.callback(error);
                        _this.responseQueue.delete(id);
                    }
                    break;
                default:
                    this.connection.send(JSON.stringify(request.payload));
                    break;
            }
        }
        catch (error) {
            request.callback(error);
            _this.responseQueue.delete(id);
        }
    }
    simulateWebsocketResponse(result, id) {
        if (this.responseQueue.has(id)) {
            if (this.responseQueue.get(id).callback !== undefined) {
                this.responseQueue.get(id).callback(false, result);
            }
            this.responseQueue.delete(id);
        }
    }
}
exports.PolyjuiceWebsocketProvider = PolyjuiceWebsocketProvider;
//# sourceMappingURL=ws-providers.js.map