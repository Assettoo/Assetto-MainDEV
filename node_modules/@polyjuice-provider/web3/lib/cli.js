"use strict";
/**
 * this file is a custom http provider used to proxy ETH rpc call to godwoken-polyjuice chain.
 * it is fork and based on https://github.com/ChainSafe/web3.js/tree/1.x/packages/web3-providers-http
 * this is only aims for nodejs development purpose. it will sign tx with private-key, which it is dangerous.
 * please ues it at your own risk.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyjuiceHttpProviderCli = void 0;
const signer_1 = __importDefault(require("@polyjuice-provider/base/lib/signer"));
const providers_1 = require("./providers");
const base_1 = require("@polyjuice-provider/base");
class PolyjuiceHttpProviderCli extends providers_1.PolyjuiceHttpProvider {
    constructor(host, polyjuice_config, private_key, _options) {
        super(host, polyjuice_config);
        this.signer = new signer_1.default(private_key);
    }
    async send(payload, callback) {
        await this.godwoker.init();
        const { method, params } = payload;
        switch (method) {
            case "eth_sendTransaction":
                try {
                    const that = this;
                    const { from, gas, gasPrice, value, data } = params[0];
                    const to = (0, base_1.formalizeEthToAddress)(params[0].to);
                    const t = {
                        from: from,
                        to: to,
                        value: value || 0,
                        data: data || "",
                        gas: gas,
                        gasPrice: gasPrice,
                    };
                    const signingMethod = async (message) => {
                        console.log(`it is very dangerous to sign with private-key, please use it carefully and only use in test development!`);
                        console.log("sinature: ", await this.signer.sign_with_private_key(message));
                        return await that.signer.sign_with_private_key(message);
                    };
                    const rawTxString = await (0, base_1.buildSendTransaction)(this.abi, this.godwoker, t, signingMethod.bind(this), base_1.SigningMessageType.noPrefix);
                    const tx_hash = await this.godwoker.poly_submitSerializedL2Transaction(rawTxString);
                    await this.godwoker.waitForTransactionReceipt(tx_hash);
                    const res = {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: tx_hash,
                    };
                    callback(null, res);
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error,
                    });
                }
                break;
            default:
                super.send(payload, callback);
                break;
        }
    }
}
exports.PolyjuiceHttpProviderCli = PolyjuiceHttpProviderCli;
//# sourceMappingURL=cli.js.map