"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcPolyjuiceTxHash = exports.TxConfigValueTypeToString = exports.formatEthTransaction = exports.transactionConfigToPolyjuiceEthTransaction = exports.PolyjuiceAccounts = void 0;
const base_1 = require("@polyjuice-provider/base");
const account_1 = __importDefault(require("eth-lib/lib/account"));
const base_2 = require("@ckb-lumos/base");
const godwoken_1 = require("@polyjuice-provider/godwoken");
const schemas_1 = require("@polyjuice-provider/godwoken/schemas");
// do not change the following require to import, otherwise it will cause error.
// the original web3-eth-accounts Account class is exported by module.exports.
const Accounts = require("web3-eth-accounts");
class PolyjuiceAccounts extends Accounts {
    constructor(polyjuiceConfig, provider) {
        if (provider) {
            super(provider);
        }
        else {
            super();
        }
        if (!polyjuiceConfig.web3Url) {
            throw new Error("should support web3 rpc url in PolyjuiceConfig.");
        }
        const godwokerOption = {
            godwoken: {
                rollup_type_hash: polyjuiceConfig.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuiceConfig.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
            polyjuice: {
                creator_id: polyjuiceConfig.creatorId,
                default_from_address: polyjuiceConfig.defaultFromAddress,
            },
        };
        this.godwoker = new base_1.Godwoker(polyjuiceConfig.web3Url, godwokerOption);
        this.abi = new base_1.Abi(polyjuiceConfig.abiItems || []);
        this.deployAddressMapping = [];
        this.deploymentRecords = {};
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    setMultiAbi(abiItemsArray) {
        const abiItems = [].concat.apply([], abiItemsArray);
        this.abi = new base_1.Abi(abiItems);
    }
    addAbi(_abiItems) {
        const abiItems = this.abi.get_abi_items().concat(_abiItems);
        this.abi = new base_1.Abi(abiItems);
    }
    async convertDeployArgs(args, abiItems, bytecode) {
        const convertResult = await (0, base_1.convertContractConstructorArgs)(args, abiItems, bytecode, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
        // later when sending this deployment transaction,
        // we will submit this.deployContractAddressMapping to web3 as well,
        // for saving address mapping if needed.
        this.deployAddressMapping = convertResult.addressMapping;
        // deploymentRecords will be used to extract constructor args from eth_tx's input data
        this.deploymentRecords = {
            ...this.deploymentRecords,
            ...convertResult.deploymentRecords,
        };
        return convertResult.newArgs;
    }
    signTransaction(_tx, privateKey, callback) {
        const that = this;
        callback = callback || function () { };
        if (!_tx) {
            const error = new Error("No transaction object given!");
            callback(error);
            return Promise.reject(error);
        }
        if (!_tx.from) {
            _tx.from = this.privateKeyToAccount(privateKey).address;
        }
        // use godwoken-polyjuice transaction signing method
        // (which is different tx structure and use a message signing)
        // to sign transaction.
        let tx = transactionConfigToPolyjuiceEthTransaction(_tx);
        try {
            // do init incase user not passing config parameter during construction
            return this.godwoker.initSync().then(async function () {
                let message = null;
                const signingMethod = (_message) => {
                    message = _message;
                    return account_1.default.sign(message, privateKey);
                };
                const rawTx = tx.to === base_1.DEFAULT_EMPTY_ETH_ADDRESS
                    ? await (0, base_1.buildDeployProcess)(that.deployAddressMapping, that.deploymentRecords, that.abi, that.godwoker, tx, signingMethod.bind(that))
                    : await (0, base_1.buildSendTransaction)(that.abi, that.godwoker, tx, signingMethod);
                const deRawTx = (0, base_1.deserializeL2TransactionWithAddressMapping)(rawTx);
                let result = {
                    messageHash: message,
                    v: "0x0",
                    r: "0x0",
                    s: deRawTx.tx.signature,
                    rawTransaction: rawTx,
                    transactionHash: calcPolyjuiceTxHash(deRawTx.tx.raw),
                };
                callback(null, result);
                return Promise.resolve(result);
            });
        }
        catch (error) {
            callback(error);
            return Promise.reject(error);
        }
    }
}
exports.PolyjuiceAccounts = PolyjuiceAccounts;
function transactionConfigToPolyjuiceEthTransaction(tx) {
    let { from, to, value, gas, gasPrice, data, nonce } = tx;
    if (!from) {
        throw new Error("from is missing!");
    }
    if (typeof from === "number") {
        //todo: handle from is number
        throw new Error("todo: handle from is number case!");
    }
    return formatEthTransaction({ from, to, value, gas, gasPrice, data, nonce });
}
exports.transactionConfigToPolyjuiceEthTransaction = transactionConfigToPolyjuiceEthTransaction;
// todo: remove to @polyjuice-provider/base
function formatEthTransaction({ from, to, value, gas, gasPrice, data, nonce, }) {
    const ethTx = {
        from: from,
        to: (0, base_1.formalizeEthToAddress)(to),
        value: value ? TxConfigValueTypeToString(value) : "0x00",
        gas: gas
            ? TxConfigValueTypeToString(gas)
            : `0x${BigInt(base_1.POLY_MAX_TRANSACTION_GAS_LIMIT).toString(16)}`,
        gasPrice: gasPrice
            ? TxConfigValueTypeToString(gasPrice)
            : `0x${BigInt(base_1.POLY_MIN_GAS_PRICE).toString(16)}`,
        data: data || "0x00",
        nonce: nonce ? TxConfigValueTypeToString(nonce) : "0x1",
    };
    return ethTx;
}
exports.formatEthTransaction = formatEthTransaction;
function TxConfigValueTypeToString(value) {
    if (typeof value === "string") {
        value = "0x" + BigInt(value).toString(16);
    }
    if (typeof value === "number") {
        value = "0x" + BigInt(value).toString(16);
    }
    if (typeof value !== "string" || typeof value !== "number") {
        // BN.js type
        value = value.toString(16);
    }
    return value;
}
exports.TxConfigValueTypeToString = TxConfigValueTypeToString;
// todo: move to @polyjuice-provider/godwoken
function calcPolyjuiceTxHash(tx) {
    const tx_hash = base_2.utils
        .ckbHash((0, schemas_1.SerializeRawL2Transaction)(godwoken_1.normalizer.NormalizeRawL2Transaction(tx)))
        .serializeJson();
    return tx_hash;
}
exports.calcPolyjuiceTxHash = calcPolyjuiceTxHash;
//# sourceMappingURL=accounts.js.map