"use strict";
/**
 * this file is a custom http provider used to proxy ETH rpc call to godwoken-polyjuice chain.
 * it is fork and based on https://github.com/ChainSafe/web3.js/tree/1.x/packages/web3-providers-http
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyjuiceHttpProvider = void 0;
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const web3_core_helpers_1 = require("web3-core-helpers");
const xhr2_cookies_1 = require("xhr2-cookies");
const base_1 = require("@polyjuice-provider/base");
class PolyjuiceHttpProvider {
    constructor(host, polyjuiceConfig, options) {
        this.signer = new base_1.Signer();
        const godwoker_option = {
            godwoken: {
                rollup_type_hash: polyjuiceConfig.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuiceConfig.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
            polyjuice: {
                creator_id: polyjuiceConfig.creatorId,
                default_from_address: polyjuiceConfig.defaultFromAddress,
            },
        };
        this.godwoker = new base_1.Godwoker(host, godwoker_option);
        this.abi = new base_1.Abi(polyjuiceConfig.abiItems || []);
        options = options || {};
        this.withCredentials = options.withCredentials || false;
        this.timeout = options.timeout || 0;
        this.headers = options.headers;
        this.agent = options.agent;
        this.connected = false;
        // keepAlive is true unless explicitly set to false
        const keepAlive = options.keepAlive !== false;
        this.host = host || "http://localhost:8024";
        if (!this.agent) {
            if (this.host.substring(0, 5) === "https") {
                this.httpsAgent = new https.Agent({ keepAlive });
            }
            else {
                this.httpAgent = new http.Agent({ keepAlive });
            }
        }
        this.deployAddressMapping = [];
        this.deploymentRecords = {};
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    setMultiAbi(abiItemsArray) {
        const abiItems = [].concat.apply([], abiItemsArray);
        this.abi = new base_1.Abi(abiItems);
    }
    addAbi(_abiItems) {
        const abiItems = this.abi.get_abi_items().concat(_abiItems);
        this.abi = new base_1.Abi(abiItems);
    }
    async convertDeployArgs(args, abiItems, bytecode) {
        const convertResult = await (0, base_1.convertContractConstructorArgs)(args, abiItems, bytecode, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
        // later when sending this deployment transaction,
        // we will submit this.deployContractAddressMapping to web3 as well,
        // for saving address mapping if needed.
        this.deployAddressMapping = convertResult.addressMapping;
        // deploymentRecords will be used to extract constructor args from eth_tx's input data
        this.deploymentRecords = {
            ...this.deploymentRecords,
            ...convertResult.deploymentRecords,
        };
        return convertResult.newArgs;
    }
    async send(payload, callback) {
        await this.godwoker.init();
        const { method, params } = payload;
        switch (method) {
            case "eth_sendRawTransaction":
                // todo: forbidden normal eth raw tx pass.
                try {
                    const tx_hash = await this.godwoker.poly_submitSerializedL2Transaction(params[0]);
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: tx_hash,
                    });
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error,
                    });
                }
                break;
            case "eth_sendTransaction":
                try {
                    const { from, gas, gasPrice, value, data } = params[0];
                    const to = (0, base_1.formalizeEthToAddress)(params[0].to);
                    const t = {
                        from: from,
                        to: to,
                        value: value || 0,
                        data: data || "",
                        gas: gas,
                        gasPrice: gasPrice,
                    };
                    const signingMethod = async (message) => {
                        return await this.signer.sign_with_metamask(message, from);
                    };
                    // special case: contract deployment
                    const rawTxString = t.to === base_1.DEFAULT_EMPTY_ETH_ADDRESS
                        ? await (0, base_1.buildDeployProcess)(this.deployAddressMapping, this.deploymentRecords, this.abi, this.godwoker, t, signingMethod.bind(this), base_1.SigningMessageType.noPrefix)
                        : await (0, base_1.buildSendTransaction)(this.abi, this.godwoker, t, signingMethod.bind(this), base_1.SigningMessageType.noPrefix);
                    const tx_hash = await this.godwoker.poly_submitSerializedL2Transaction(rawTxString);
                    // await this.godwoker.waitForTransactionReceipt(tx_hash);
                    const res = {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: tx_hash,
                    };
                    callback(null, res);
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error,
                    });
                }
                break;
            case "eth_call":
                try {
                    const { from, gas, gasPrice, value, data, to } = params[0];
                    const t = {
                        from: from || this.godwoker.default_from_address,
                        to: to,
                        value: value || 0,
                        data: data || "",
                        gas: gas || base_1.POLY_MAX_TRANSACTION_GAS_LIMIT,
                        gasPrice: gasPrice || base_1.POLY_MIN_GAS_PRICE,
                    };
                    const return_data = await (0, base_1.executeCallTransaction)(this.abi, this.godwoker, t);
                    const res = {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: return_data,
                    };
                    callback(null, res);
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error,
                    });
                }
                break;
            case "eth_estimateGas":
                try {
                    let new_payload = payload;
                    const { data } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    new_payload.params[0].data = data_with_short_address;
                    new_payload.params[0].from =
                        new_payload.params[0].from || this.godwoker.default_from_address;
                    this._send(new_payload, callback); // this should be handle by provider
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error,
                    });
                }
                break;
            default:
                this._send(payload, callback);
                break;
        }
    }
    _prepareRequest() {
        let request;
        // the current runtime is a browser
        if (typeof XMLHttpRequest !== "undefined") {
            request = new XMLHttpRequest();
        }
        else {
            request = new xhr2_cookies_1.XMLHttpRequest();
            let agents = {
                httpsAgent: this.httpsAgent,
                httpAgent: this.httpAgent,
                baseUrl: this.baseUrl,
            };
            if (this.agent) {
                agents.httpsAgent = this.agent.https;
                agents.httpAgent = this.agent.http;
                agents.baseUrl = this.agent.baseUrl;
            }
            request.nodejsSet(agents);
        }
        request.open("POST", this.host, true);
        request.setRequestHeader("Content-Type", "application/json");
        request.timeout = this.timeout;
        request.withCredentials = this.withCredentials;
        if (this.headers) {
            this.headers.forEach(function (header) {
                request.setRequestHeader(header.name, header.value);
            });
        }
        return request;
    }
    /**
     * Should be used to make async request
     *
     * @method send
     * @param {Object} payload
     * @param {Function} callback triggered on end with (err, result)
     */
    _send(payload, callback) {
        let _this = this;
        let request = this._prepareRequest();
        request.onreadystatechange = function () {
            if (request.readyState === 4 && request.timeout !== 1) {
                let result = request.responseText;
                let error = null;
                try {
                    result = JSON.parse(result);
                }
                catch (e) {
                    error = web3_core_helpers_1.errors.InvalidResponse(request.responseText);
                }
                _this.connected = true;
                callback(error, result);
            }
        };
        request.ontimeout = function () {
            _this.connected = false;
            callback(web3_core_helpers_1.errors.ConnectionTimeout(this.timeout));
        };
        try {
            request.send(JSON.stringify(payload));
        }
        catch (error) {
            this.connected = false;
            callback(web3_core_helpers_1.errors.InvalidConnection(this.host));
        }
    }
    /**
     * Returns the desired boolean.
     *
     * @method supportsSubscriptions
     * @returns {boolean}
     */
    supportsSubscriptions() {
        return false;
    }
    disconnect() {
        return this.connected;
    }
}
exports.PolyjuiceHttpProvider = PolyjuiceHttpProvider;
//# sourceMappingURL=providers.js.map