"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NormalizeUnlockWithdrawalViaFinalize = exports.NormalizeWithdrawalLockArgs = exports.NormalizeSUDTTransfer = exports.NormalizeSUDTQuery = exports.NormalizeCreateAccount = exports.NormalizeFee = exports.NormalizeWithdrawalRequest = exports.NormalizeRawWithdrawalRequest = exports.NormalizeRawL2TransactionWithAddressMapping = exports.NormalizeL2TransactionWithAddressMapping = exports.NormalizeAddressMapping = exports.NormalizeAddressMappingItem = exports.NormalizeAbiItems = exports.NormalizeAbiItem = exports.NormalizeAbiOutput = exports.NormalizeAbiInput = exports.NormalizeBoolean = exports.NormalizeStateMutabilityType = exports.NormalizeAbiType = exports.hexStringToUtfString = exports.utfStringToHexString = exports.NormalizeL2Transaction = exports.NormalizeRawL2Transaction = exports.NormalizeCustodianLockArgs = exports.NormalizeHeaderInfo = exports.NormalizeDepositLockArgs = exports.NormalizeDepositRequest = void 0;
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const lodash_1 = __importDefault(require("lodash"));
// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,
// later we can think about exposing those functions directly.
function normalizeHexNumber(length) {
    return function (debugPath, value) {
        if (!(value instanceof ArrayBuffer)) {
            let intValue = BigInt(value).toString(16);
            if (intValue.length % 2 !== 0) {
                intValue = "0" + intValue;
            }
            if (intValue.length / 2 > length) {
                throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);
            }
            const view = new DataView(new ArrayBuffer(length));
            for (let i = 0; i < intValue.length / 2; i++) {
                const start = intValue.length - (i + 1) * 2;
                view.setUint8(i, parseInt(intValue.substr(start, 2), 16));
            }
            value = view.buffer;
        }
        if (value.byteLength < length) {
            const array = new Uint8Array(length);
            array.set(new Uint8Array(value), 0);
            value = array.buffer;
        }
        return value;
    };
}
function normalizeRawData(length) {
    return function (debugPath, value) {
        try {
            value = new ckb_js_toolkit_1.Reader(value).toArrayBuffer();
        }
        catch (error) {
            throw new Error(`${debugPath} invalid value ${value}, error: ${error === null || error === void 0 ? void 0 : error.message}`);
        }
        if (length > 0 && value.byteLength !== length) {
            throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);
        }
        return value;
    };
}
function normalizeObject(debugPath, obj, keys) {
    const result = {};
    for (const [key, f] of Object.entries(keys)) {
        const value = obj[key];
        if (!value) {
            throw new Error(`${debugPath} is missing ${key}!`);
        }
        result[key] = f(`${debugPath}.${key}`, value);
    }
    return result;
}
function toNormalize(normalize) {
    return function (debugPath, value) {
        return normalize(value, {
            debugPath,
        });
    };
}
function toNormalizeArray(normalizeFunction) {
    return function (debugPath, array) {
        return array.map((item, i) => {
            return normalizeFunction(`${debugPath}[${i}]`, item);
        });
    };
}
function NormalizeDepositRequest(request, { debugPath = "deposit_request" } = {}) {
    return normalizeObject(debugPath, request, {
        capacity: normalizeHexNumber(8),
        amount: normalizeHexNumber(16),
        sudt_script_hash: normalizeRawData(32),
        script: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
    });
}
exports.NormalizeDepositRequest = NormalizeDepositRequest;
function NormalizeDepositLockArgs(args, { debugPath = "deposit_lock_args" } = {}) {
    return normalizeObject(debugPath, args, {
        owner_lock_hash: normalizeRawData(32),
        layer2_lock: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
        cancel_timeout: normalizeHexNumber(8),
    });
}
exports.NormalizeDepositLockArgs = NormalizeDepositLockArgs;
function NormalizeHeaderInfo(headerInfo, { debugPath = "header_info" } = {}) {
    return normalizeObject(debugPath, headerInfo, {
        number: normalizeHexNumber(8),
        block_hash: normalizeRawData(32),
    });
}
exports.NormalizeHeaderInfo = NormalizeHeaderInfo;
function NormalizeCustodianLockArgs(args, { debugPath = "custodian_lock_args" } = {}) {
    return normalizeObject(debugPath, args, {
        owner_lock_hash: normalizeRawData(32),
        deposit_block_hash: normalizeRawData(32),
        deposit_block_number: normalizeHexNumber(8),
    });
}
exports.NormalizeCustodianLockArgs = NormalizeCustodianLockArgs;
function NormalizeRawL2Transaction(rawL2Transaction, { debugPath = "raw_l2_transaction" } = {}) {
    return normalizeObject(debugPath, rawL2Transaction, {
        from_id: normalizeHexNumber(4),
        to_id: normalizeHexNumber(4),
        nonce: normalizeHexNumber(4),
        args: normalizeRawData(-1),
    });
}
exports.NormalizeRawL2Transaction = NormalizeRawL2Transaction;
function NormalizeL2Transaction(l2Transaction, { debugPath = "l2_transaction" } = {}) {
    return normalizeObject(debugPath, l2Transaction, {
        raw: toNormalize(NormalizeRawL2Transaction),
        signature: normalizeRawData(65),
    });
}
exports.NormalizeL2Transaction = NormalizeL2Transaction;
function utfStringToHexString(value) {
    return "0x" + Buffer.from(value, "utf-8").toString("hex");
}
exports.utfStringToHexString = utfStringToHexString;
function hexStringToUtfString(value) {
    if (!value.startsWith("0x") || value.length % 2)
        throw new Error(`${value} expected hex string with 0x and even number length`);
    return Buffer.from(value.slice(2), "hex").toString("utf-8");
}
exports.hexStringToUtfString = hexStringToUtfString;
function NormalizeAbiType(value, { debugPath = "abi_item_abi_type" } = {}) {
    switch (value) {
        case "constructor":
            return 1;
        case "event":
            return 2;
        case "fallback":
            return 3;
        case "function":
            return 4;
        default:
            throw new Error(`${debugPath} has invalid value: ${value}`);
    }
}
exports.NormalizeAbiType = NormalizeAbiType;
function NormalizeStateMutabilityType(value, { debugPath = "abi_item_abi_type" } = {}) {
    switch (value) {
        case "view":
            return 1;
        case "nonpayable":
            return 2;
        case "payable":
            return 3;
        case "pure":
            return 4;
        default:
            throw new Error(`${debugPath} has invalid value: ${value}`);
    }
}
exports.NormalizeStateMutabilityType = NormalizeStateMutabilityType;
function NormalizeBoolean(value, { debugPath = "boolean" } = {}) {
    switch (value) {
        case true:
            return 1;
        case false:
            return 2;
        default:
            throw new Error(`${debugPath} has invalid value: ${value}`);
    }
}
exports.NormalizeBoolean = NormalizeBoolean;
function NormalizeAbiInput(_abiInput, { debugPath = "address_mapping_abi_item_input" } = {}) {
    let abiInput = lodash_1.default.cloneDeep(_abiInput); //don't change origin abi
    abiInput.name = utfStringToHexString(abiInput.name);
    abiInput.type = utfStringToHexString(abiInput.type);
    const result = normalizeObject(debugPath, abiInput, {
        name: normalizeRawData(-1),
        type: normalizeRawData(-1),
    });
    if (abiInput.indexed != undefined) {
        result.indexed = NormalizeBoolean(abiInput.indexed, {
            debugPath: `${debugPath}.indexed`,
        });
    }
    if (abiInput.components) {
        result.components = abiInput.components.map((v) => NormalizeAbiInput(v));
    }
    if (abiInput.internalType) {
        result.internalType = normalizeRawData(-1)(debugPath, utfStringToHexString(abiInput.internalType));
    }
    return result;
}
exports.NormalizeAbiInput = NormalizeAbiInput;
function NormalizeAbiOutput(_abiOutput, { debugPath = "address_mapping_abi_item_output" } = {}) {
    let abiOutput = _abiOutput;
    abiOutput.name = utfStringToHexString(abiOutput.name);
    abiOutput.type = utfStringToHexString(abiOutput.type);
    const result = normalizeObject(debugPath, abiOutput, {
        name: normalizeRawData(-1),
        type: normalizeRawData(-1),
    });
    if (abiOutput.components) {
        result.components_ = abiOutput.components.map((v) => NormalizeAbiOutput(v));
    }
    if (abiOutput.internalType) {
        result.internalType_ = normalizeRawData(-1);
    }
    return result;
}
exports.NormalizeAbiOutput = NormalizeAbiOutput;
function NormalizeAbiItem(_abiItem, { debugPath = "address_mapping_abi_item" } = {}) {
    let abiItem = lodash_1.default.cloneDeep(_abiItem); // do not change the original abi;
    let result = {
        type: NormalizeAbiType(abiItem.type),
    };
    if (abiItem.name) {
        result.name = normalizeRawData(-1)(debugPath, utfStringToHexString(abiItem.name));
    }
    if (abiItem.inputs) {
        result.inputs = abiItem.inputs.map((v) => NormalizeAbiInput(v));
    }
    if (abiItem.outputs) {
        result.outputs = abiItem.outputs.map((v) => NormalizeAbiOutput(v));
    }
    if (abiItem.payable != undefined) {
        result.payable = NormalizeBoolean(abiItem.payable);
    }
    if (abiItem.anonymous != undefined) {
        result.anonymous = NormalizeBoolean(abiItem.anonymous);
    }
    if (abiItem.constant != undefined) {
        result.constant = NormalizeBoolean(abiItem.constant);
    }
    if (abiItem.stateMutability) {
        result.stateMutability = NormalizeStateMutabilityType(abiItem.stateMutability);
    }
    if (abiItem.gas) {
        result.gas = normalizeRawData(4)(debugPath, abiItem.stateMutability);
    }
    return result;
}
exports.NormalizeAbiItem = NormalizeAbiItem;
function NormalizeAbiItems(_abiItems, { debugPath = "address_mapping_abi_items" } = {}) {
    let abiItems = _abiItems;
    return toNormalizeArray(NormalizeAbiItem)(debugPath, abiItems);
}
exports.NormalizeAbiItems = NormalizeAbiItems;
function NormalizeAddressMappingItem(addressMappingItem, { debugPath = "address_mapping_item" } = {}) {
    return normalizeObject(debugPath, addressMappingItem, {
        eth_address: normalizeRawData(20),
        gw_short_address: normalizeRawData(20),
    });
}
exports.NormalizeAddressMappingItem = NormalizeAddressMappingItem;
function NormalizeAddressMapping(addressMapping, { debugPath = "address_mapping" } = {}) {
    return normalizeObject(debugPath, addressMapping, {
        length: normalizeHexNumber(4),
        data: toNormalizeArray(toNormalize(NormalizeAddressMappingItem)),
    });
}
exports.NormalizeAddressMapping = NormalizeAddressMapping;
function NormalizeL2TransactionWithAddressMapping(l2TransactionWithAddressMapping, { debugPath = "l2_transaction_with_address_mapping" } = {}) {
    return normalizeObject(debugPath, l2TransactionWithAddressMapping, {
        tx: toNormalize(NormalizeL2Transaction),
        addresses: toNormalize(NormalizeAddressMapping),
        extra: normalizeRawData(-1),
    });
}
exports.NormalizeL2TransactionWithAddressMapping = NormalizeL2TransactionWithAddressMapping;
function NormalizeRawL2TransactionWithAddressMapping(rawL2TransactionWithAddressMapping, { debugPath = "raw_l2_transaction_with_address_mapping" } = {}) {
    return normalizeObject(debugPath, rawL2TransactionWithAddressMapping, {
        raw_tx: toNormalize(NormalizeRawL2Transaction),
        addresses: toNormalize(NormalizeAddressMapping),
        extra: normalizeRawData(-1),
    });
}
exports.NormalizeRawL2TransactionWithAddressMapping = NormalizeRawL2TransactionWithAddressMapping;
function NormalizeRawWithdrawalRequest(raw_request, { debugPath = "raw_withdrawal_request" } = {}) {
    return normalizeObject(debugPath, raw_request, {
        nonce: normalizeHexNumber(4),
        capacity: normalizeHexNumber(8),
        amount: normalizeHexNumber(16),
        sudt_script_hash: normalizeRawData(32),
        account_script_hash: normalizeRawData(32),
        sell_amount: normalizeHexNumber(16),
        sell_capacity: normalizeHexNumber(8),
        owner_lock_hash: normalizeRawData(32),
        payment_lock_hash: normalizeRawData(32),
    });
}
exports.NormalizeRawWithdrawalRequest = NormalizeRawWithdrawalRequest;
function NormalizeWithdrawalRequest(request, { debugPath = "withdrawal_request" } = {}) {
    return normalizeObject(debugPath, request, {
        raw: toNormalize(NormalizeRawWithdrawalRequest),
        signature: normalizeRawData(65),
    });
}
exports.NormalizeWithdrawalRequest = NormalizeWithdrawalRequest;
function NormalizeFee(fee, { debugPath = "fee" } = {}) {
    return normalizeObject(debugPath, fee, {
        sudt_id: normalizeHexNumber(4),
        amount: normalizeHexNumber(16),
    });
}
exports.NormalizeFee = NormalizeFee;
function NormalizeCreateAccount(createAccount, { debugPath = "create_account" } = {}) {
    return normalizeObject(debugPath, createAccount, {
        script: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
        fee: toNormalize(NormalizeFee),
    });
}
exports.NormalizeCreateAccount = NormalizeCreateAccount;
function NormalizeSUDTQuery(sudt_query, { debugPath = "sudt_query" } = {}) {
    return normalizeObject(debugPath, sudt_query, {
        account_id: normalizeHexNumber(4),
    });
}
exports.NormalizeSUDTQuery = NormalizeSUDTQuery;
function NormalizeSUDTTransfer(sudt_transfer, { debugPath = "sudt_transfer" } = {}) {
    return normalizeObject(debugPath, sudt_transfer, {
        to: normalizeRawData(20),
        amount: normalizeHexNumber(16),
        fee: normalizeHexNumber(16),
    });
}
exports.NormalizeSUDTTransfer = NormalizeSUDTTransfer;
function NormalizeWithdrawalLockArgs(withdrawal_lock_args, { debugPath = "withdrawal_lock_args" } = {}) {
    return normalizeObject(debugPath, withdrawal_lock_args, {
        // the original deposit info
        // used for helping programs generate reverted custodian cell
        deposit_block_hash: normalizeRawData(32),
        deposit_block_number: normalizeHexNumber(8),
        // the original custodian lock hash
        withdrawal_block_hash: normalizeRawData(32),
        withdrawal_block_number: normalizeHexNumber(8),
        // buyer can pay sell_amount token to unlock
        sudt_script_hash: normalizeRawData(32),
        sell_amount: normalizeHexNumber(16),
        sell_capacity: normalizeHexNumber(8),
        // layer1 lock to withdraw after challenge period
        owner_lock_hash: normalizeRawData(32),
        // layer1 lock to receive the payment, must exists on the chain
        payment_lock_hash: normalizeRawData(32),
    });
}
exports.NormalizeWithdrawalLockArgs = NormalizeWithdrawalLockArgs;
function NormalizeUnlockWithdrawalViaFinalize(unlock_withdrawal_finalize, { debugPath = "unlock_withdrawal_finalize" } = {}) {
    return normalizeObject(debugPath, unlock_withdrawal_finalize, {
        block_proof: normalizeRawData(-1),
    });
}
exports.NormalizeUnlockWithdrawalViaFinalize = NormalizeUnlockWithdrawalViaFinalize;
//# sourceMappingURL=normalizer.js.map