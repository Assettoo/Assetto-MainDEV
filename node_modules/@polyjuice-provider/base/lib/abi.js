"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Abi = exports.getAddressesFromInputDataByAbi = exports.filterInterestedInput = exports.decodeInputDataByAbi = exports.deserializeAbiItem = exports.deserializeStateMutabilityType = exports.deserializeAbiType = exports.deserializeUtf8Bytes = exports.deserializeBoolFromByteOpt = exports.serializeAbiItem = void 0;
const constant_1 = require("./constant");
const abi_1 = require("@polyjuice-provider/godwoken/schemas/abi/abi");
const types_1 = require("./types");
const normalizer_1 = require("@polyjuice-provider/godwoken/lib/normalizer");
const lodash_1 = __importDefault(require("lodash"));
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const Web3EthAbi = require("web3-eth-abi");
function serializeAbiItem(_abiItem) {
    let abiItem = lodash_1.default.cloneDeep(_abiItem); // do not change the original abiItem;
    return new ckb_js_toolkit_1.Reader((0, abi_1.SerializeAbiItem)((0, normalizer_1.NormalizeAbiItem)(abiItem))).serializeJson();
}
exports.serializeAbiItem = serializeAbiItem;
function deserializeBoolFromByteOpt(value) {
    if (value.hasValue()) {
        switch (value.value()) {
            case 1:
                return true;
            case 2:
                return false;
            default:
                throw new Error("invalid bool ByteOpt");
        }
    }
    return undefined;
}
exports.deserializeBoolFromByteOpt = deserializeBoolFromByteOpt;
function deserializeUtf8Bytes(value) {
    return (0, normalizer_1.hexStringToUtfString)(new ckb_js_toolkit_1.Reader(value.raw()).serializeJson());
}
exports.deserializeUtf8Bytes = deserializeUtf8Bytes;
function deserializeAbiType(value) {
    switch (value) {
        case 1:
            return "constructor";
        case 2:
            return "event";
        case 3:
            return "fallback";
        case 4:
            return "function";
        default:
            throw new Error(`deserialize AbiType has invalid value: ${value}`);
    }
}
exports.deserializeAbiType = deserializeAbiType;
function deserializeStateMutabilityType(value) {
    switch (value) {
        case 1:
            return "view";
        case 2:
            return "nonpayable";
        case 3:
            return "payable";
        case 4:
            return "pure";
        default:
            throw new Error(`deserialize StateMutabilityType has invalid value: ${value}`);
    }
}
exports.deserializeStateMutabilityType = deserializeStateMutabilityType;
function deserializeAbiItem(value) {
    const data = new abi_1.AbiItem(new ckb_js_toolkit_1.Reader(value));
    const type = deserializeAbiType(data.getType());
    const anonymous = deserializeBoolFromByteOpt(data.getAnonymous());
    const constant = deserializeBoolFromByteOpt(data.getConstant());
    const payable = deserializeBoolFromByteOpt(data.getPayable());
    const gas = data.getGas().hasValue()
        ? data.getGas().value().toLittleEndianUint32()
        : undefined;
    const name = data.getName().hasValue()
        ? deserializeUtf8Bytes(data.getName().value())
        : undefined;
    const inputs_len_in_int = data.getInputs().hasValue()
        ? data.getInputs().value().length()
        : 0;
    const outputs_len_in_int = data.getOutputs().hasValue()
        ? data.getOutputs().value().length()
        : 0;
    const inputs = [...Array(inputs_len_in_int).keys()].map((index) => {
        const value = data.getInputs().value().indexAt(index);
        const name_bytes = value.getName();
        const type_bytes = value.getType();
        const indexed = value.getIndexed().hasValue()
            ? deserializeBoolFromByteOpt(value.getIndexed())
            : undefined;
        const internalType = value.getInternalType().hasValue()
            ? deserializeUtf8Bytes(value.getInternalType().value())
            : undefined;
        let result = {
            name: deserializeUtf8Bytes(name_bytes),
            type: deserializeUtf8Bytes(type_bytes),
        };
        if (indexed !== undefined) {
            result.indexed = indexed;
        }
        if (internalType !== undefined) {
            result.internalType = internalType;
        }
        // we not able to deserialize the abiInputs, so just ignore for now
        return result;
    });
    const outputs = [...Array(outputs_len_in_int).keys()].map((index) => {
        const value = data.getOutputs().value().indexAt(index);
        const internalType = value.getInternalType().hasValue()
            ? deserializeUtf8Bytes(value.getInternalType().value())
            : undefined;
        let result = {
            name: deserializeUtf8Bytes(value.getName()),
            type: deserializeUtf8Bytes(value.getType()),
        };
        if (internalType !== undefined) {
            result.internalType = internalType;
        }
        // we not able to deserialize the abiOutputs, so just ignore for now
        return result;
    });
    let result = {
        type,
    };
    if (inputs_len_in_int !== 0) {
        result.inputs = inputs;
    }
    if (outputs_len_in_int !== 0) {
        result.outputs = outputs;
    }
    if (name !== undefined) {
        result.name = name;
    }
    if (anonymous !== undefined) {
        result.anonymous = anonymous;
    }
    if (constant !== undefined) {
        result.constant = constant;
    }
    if (payable !== undefined) {
        result.payable = payable;
    }
    if (gas !== undefined) {
        result.gas = gas;
    }
    return result;
}
exports.deserializeAbiItem = deserializeAbiItem;
function decodeInputDataByAbi(data, abiItem) {
    if (!abiItem.inputs)
        throw new Error(`abiItem should have inputs! abiItem: ${JSON.stringify(abiItem, null, 2)}`);
    const expectedName = Web3EthAbi.encodeFunctionSignature(abiItem).slice(2);
    const name = data.slice(2, 10);
    if (name !== expectedName)
        throw new Error(`function signature unmatched! expect ${expectedName}, got ${name}. abiItem: ${JSON.stringify(abiItem, null, 2)}, data: ${data}`);
    let decoded = Web3EthAbi.decodeParameters(abiItem.inputs, "0x" + data.slice(10));
    let retData = {
        name: abiItem.name || "",
        params: [],
    };
    for (let i = 0; i < decoded.__length__; i++) {
        let param = decoded[i];
        let parsedParam = param;
        const isUint = abiItem.inputs[i].type.indexOf("uint") === 0;
        const isInt = abiItem.inputs[i].type.indexOf("int") === 0;
        const isAddress = abiItem.inputs[i].type.indexOf("address") === 0;
        if (isUint || isInt) {
            const isArray = Array.isArray(param);
            if (isArray) {
                parsedParam = param.map((val) => BigInt(val).toString());
            }
            else {
                parsedParam = BigInt(param).toString();
            }
        }
        // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all
        if (isAddress) {
            const isArray = Array.isArray(param);
            if (isArray) {
                parsedParam = param.map((_) => _.toLowerCase());
            }
            else {
                parsedParam = param.toLowerCase();
            }
        }
        retData.params.push({
            name: abiItem.inputs[i].name,
            value: parsedParam,
            type: abiItem.inputs[i].type,
        });
    }
    return retData;
}
exports.decodeInputDataByAbi = decodeInputDataByAbi;
function filterInterestedInput(data, abiItem) {
    const inputs = decodeInputDataByAbi(data, abiItem);
    return inputs.params.filter((input) => input.type === "address" || input.type === "address[]");
}
exports.filterInterestedInput = filterInterestedInput;
function getAddressesFromInputDataByAbi(data, abiItem) {
    const params = filterInterestedInput(data, abiItem);
    let addresses = [];
    for (let i = 0; i < params.length; i++) {
        const p = params[i];
        if (Array.isArray(p.value)) {
            addresses = addresses.concat(p.value);
        }
        else {
            addresses.push(p.value);
        }
    }
    return addresses;
}
exports.getAddressesFromInputDataByAbi = getAddressesFromInputDataByAbi;
class Abi {
    constructor(_abi_items) {
        this.abi_items = [];
        this.interested_methods = [];
        this.interested_method_ids = {};
        this.abi_items = _abi_items;
        this.interested_methods = this.filter_interested_methods(this.abi_items);
        this.interested_method_ids = this.get_method_ids(this.interested_methods);
    }
    get_method_ids(_abi_items) {
        const method_ids = {};
        for (let item of _abi_items) {
            const id = Web3EthAbi.encodeFunctionSignature(item).slice(2);
            method_ids[id] = item;
        }
        return method_ids;
    }
    filter_interested_methods(_abi_items) {
        return _abi_items.filter((item) => item.type === "function" &&
            (this.filter_interested_inputs(item).length > 0 || // at least one param is eth-address
                this.filter_interested_outputs(item).length > 0) // at least one output return type is eth-address
        );
    }
    filter_interested_inputs(_abiItem) {
        if (!_abiItem.inputs)
            return [];
        return _abiItem.inputs.filter((input) => input.type === "address" || input.type === "address[]");
    }
    filter_interested_outputs(_abiItem) {
        if (!_abiItem.outputs)
            return [];
        return _abiItem.outputs.filter((output) => output.type === "address" || output.type === "address[]");
    }
    get_interested_methods() {
        return this.interested_methods;
    }
    get_abi_items() {
        return this.abi_items;
    }
    decode_method(data) {
        const method_id = data.slice(2, 10);
        const abiItem = this.interested_method_ids[method_id];
        if (!abiItem)
            throw new Error(`can not find abiItems in interested_method_ids, id: ${method_id}`);
        let decoded = Web3EthAbi.decodeParameters(abiItem.inputs, "0x" + data.slice(10));
        let retData = {
            name: abiItem.name || "",
            params: [],
        };
        if (!abiItem.inputs)
            return retData;
        for (let i = 0; i < decoded.__length__; i++) {
            let param = decoded[i];
            let parsedParam = param;
            const isUint = abiItem.inputs[i].type.indexOf("uint") === 0;
            const isInt = abiItem.inputs[i].type.indexOf("int") === 0;
            const isAddress = abiItem.inputs[i].type.indexOf("address") === 0;
            if (isUint || isInt) {
                const isArray = Array.isArray(param);
                if (isArray) {
                    parsedParam = param.map((val) => BigInt(val).toString());
                }
                else {
                    parsedParam = BigInt(param).toString();
                }
            }
            // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all
            if (isAddress) {
                const isArray = Array.isArray(param);
                if (isArray) {
                    parsedParam = param.map((_) => _.toLowerCase());
                }
                else {
                    parsedParam = param.toLowerCase();
                }
            }
            retData.params.push({
                name: abiItem.inputs[i].name,
                value: parsedParam,
                type: abiItem.inputs[i].type,
            });
        }
        return retData;
    }
    // todo: use this func to remove all repeated code.
    // params: <data: eth tx's encode input data>
    get_interested_abi_item_by_encoded_data(data) {
        const method_id = data.slice(2, 10);
        const abi_item = this.interested_method_ids[method_id];
        return abi_item;
    }
    // decode method data, if it is related with address type in inputs,
    // replace the address params with godwoken_short_address
    async refactor_data_with_short_address(data, calculate_short_address, _mapping_callback) {
        const mapping_callback = _mapping_callback || function () { };
        const method_id = data.slice(2, 10);
        const abi_item = this.interested_method_ids[method_id];
        if (!abi_item) {
            mapping_callback([]);
            return data;
        }
        let addressMappingItemVec = [];
        const decode_data = this.decode_method(data);
        const new_decode_data = decode_data.params.map(async (p) => {
            if (p.type === "address" || p.type === "address[]") {
                if (Array.isArray(p.value)) {
                    p.value = await Promise.all(p.value.map(async (v) => {
                        const short_address = await calculate_short_address(v);
                        if (short_address.type === types_1.ShortAddressType.notExistEoaAddress) {
                            addressMappingItemVec.push({
                                eth_address: v,
                                gw_short_address: short_address.value,
                            });
                        }
                        return short_address.value;
                    }));
                    return p;
                }
                // not array type, just single value
                const short_address = await calculate_short_address(p.value);
                if (short_address.type === types_1.ShortAddressType.notExistEoaAddress) {
                    addressMappingItemVec.push({
                        eth_address: p.value,
                        gw_short_address: short_address.value,
                    });
                }
                p.value = short_address.value;
                return p;
            }
            return p;
        });
        const new_data = Web3EthAbi.encodeFunctionCall(abi_item, await Promise.all(new_decode_data.map(async (p) => (await p).value)));
        mapping_callback(addressMappingItemVec);
        return new_data;
    }
    // decode the run_result return value, and check:
    // 	if it is related with address type, replace godwoken_short_address with eth_address.
    //
    // known-issue:
    // 	- when the return value is EOA address and when it haven't create account on godwoken,
    //	  we query from web3 address mapping store layer to get the origin EOA address.
    //	  however, we do not support return address type with create2 contract address which not exist yet.
    async refactor_return_value_with_short_address(return_value, abi_item, calculate_origin_eth_address) {
        if (!abi_item.outputs)
            return return_value;
        const output_value_types = abi_item.outputs.map((item) => item.type);
        let decoded_values = Web3EthAbi.decodeParameters(output_value_types, return_value);
        const interested_value_indexes = output_value_types.reduce((result, t, index) => {
            if (t === "address" || t === "address[]") {
                result.push(index);
            }
            return result;
        }, []);
        for await (const index of interested_value_indexes) {
            if (decoded_values[index] === constant_1.DEFAULT_EMPTY_ETH_ADDRESS) {
                // special case: 0x0000.. normally when calling an parameter which is un-init.
                continue;
            }
            decoded_values[index] = Array.isArray(decoded_values[index])
                ? await Promise.all(decoded_values[index].map(async (v) => await calculate_origin_eth_address(v)))
                : await calculate_origin_eth_address(decoded_values[index]);
        }
        let decode_values_with_refactor = Object.values(decoded_values);
        decode_values_with_refactor = decode_values_with_refactor.slice(0, decode_values_with_refactor.length - 1);
        return Web3EthAbi.encodeParameters(output_value_types, decode_values_with_refactor);
    }
    // todo: support user providing an url path, and read the abi json from it
    read_abi_from_json_file() { }
}
exports.Abi = Abi;
//# sourceMappingURL=abi.js.map