"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeBytesToUInt128 = exports.LeBytesToUInt64 = exports.LeBytesToUInt32 = exports.LeBytesToUInt8 = exports.UInt128ToLeBytes = exports.UInt64ToLeBytes = exports.UInt32ToLeBytes = exports.UInt8ToLeBytes = exports.validateBytecode = exports.validateEthAddressArray = exports.validateEthAddress = exports.convertContractConstructorArgs = exports.checkMatchByteCode = exports.splitByteCodeAndConstructorArgs = exports.restoreDeploymentSignature = exports.calculateDeploymentSignature = exports.calculateByteCodeSignature = exports.Godwoker = exports.ckbToEth = exports.ethToCkb = exports.encodeSudtTransferArgs = exports.encodeArgs = exports.decodeArgs = exports.serializeRawL2Transaction = exports.serializeL2Transaction = exports.buildRawL2TransactionWithAddressMapping = exports.buildL2TransactionWithAddressMapping = exports.deserializeL2TransactionWithAddressMapping = exports.serializeL2TransactionWithAddressMapping = exports.deserializeRawL2TransactionWithAddressMapping = exports.serializeRawL2TransactionWithAddressMapping = exports.deserializeAddressMapping = exports.serializeAddressMapping = exports.normalizeEthTransaction = exports.normalizeHexValue = exports.isHexString = exports.verifyHttpUrl = exports.formalizeEthToAddress = exports.L2TransactionStatus = exports.GetTxVerbose = exports.RequireResult = exports.EthTransactionStatus = void 0;
const base_1 = require("@ckb-lumos/base");
const godwoken_1 = require("@polyjuice-provider/godwoken");
const schemas_1 = require("@polyjuice-provider/godwoken/schemas");
const addressMapping_1 = require("@polyjuice-provider/godwoken/schemas/addressMapping/addressMapping");
const normalizer_1 = require("@polyjuice-provider/godwoken/lib/normalizer");
const constant_1 = require("./constant");
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const cross_fetch_1 = __importDefault(require("cross-fetch")); // for nodejs compatibility polyfill
const buffer_1 = require("buffer"); // for browser compatibility polyfill
const types_1 = require("./types");
const constant_2 = require("./constant");
const keccak256_1 = __importDefault(require("keccak256"));
// replace for buffer polyfill under 0.6 version.
// eg: for react project using webpack 4 (this is the most common case when created by running `npx create-react-app`),
// the default react-scripts config just use buffer@0.4.3 which doesn't include writeBigUint64LE function.
// code copy from https://github.com/feross/buffer/blob/master/index.js#L1497-L1513
function writeBigUint64LE(buf, value, offset = 0) {
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number((value >> BigInt(32)) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
buffer_1.Buffer.prototype.writeBigUInt64LE = function (value, offset) {
    return writeBigUint64LE(this, value, offset);
};
const jaysonBrowserClient = require("jayson/lib/client/browser");
const fetch = typeof window !== "undefined" ? window.fetch : cross_fetch_1.default;
var EthTransactionStatus;
(function (EthTransactionStatus) {
    EthTransactionStatus["success"] = "0x1";
    EthTransactionStatus["failure"] = "0x0";
})(EthTransactionStatus = exports.EthTransactionStatus || (exports.EthTransactionStatus = {}));
var RequireResult;
(function (RequireResult) {
    RequireResult[RequireResult["canBeEmpty"] = 0] = "canBeEmpty";
    RequireResult[RequireResult["canNotBeEmpty"] = 1] = "canNotBeEmpty";
})(RequireResult = exports.RequireResult || (exports.RequireResult = {}));
var GetTxVerbose;
(function (GetTxVerbose) {
    GetTxVerbose[GetTxVerbose["TxWithStatus"] = 0] = "TxWithStatus";
    GetTxVerbose[GetTxVerbose["OnlyStatus"] = 1] = "OnlyStatus";
})(GetTxVerbose = exports.GetTxVerbose || (exports.GetTxVerbose = {}));
var L2TransactionStatus;
(function (L2TransactionStatus) {
    L2TransactionStatus[L2TransactionStatus["Pending"] = 0] = "Pending";
    L2TransactionStatus[L2TransactionStatus["Committed"] = 1] = "Committed";
})(L2TransactionStatus = exports.L2TransactionStatus || (exports.L2TransactionStatus = {}));
function formalizeEthToAddress(to_address) {
    if (to_address === "0x")
        return constant_1.DEFAULT_EMPTY_ETH_ADDRESS;
    if (!to_address)
        return constant_1.DEFAULT_EMPTY_ETH_ADDRESS;
    if (typeof to_address === "string" && to_address.length !== 42)
        throw new Error(`invalid ETH to_address length ${to_address.length}.`);
    if (typeof to_address !== "string")
        throw new Error(`invalid type of to_address ${typeof to_address}`);
    return to_address;
}
exports.formalizeEthToAddress = formalizeEthToAddress;
function verifyHttpUrl(_url) {
    const url = new URL(_url);
    if (url.protocol === "https:" || url.protocol === "http:") {
        return true;
    }
    return false;
}
exports.verifyHttpUrl = verifyHttpUrl;
function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
exports.isHexString = isHexString;
function normalizeHexValue(value) {
    if (typeof value === "number") {
        let hex = "";
        while (value) {
            hex = constant_1.HEX_CHARACTERS[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return "0x0" + value;
        }
        return "0x" + value;
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            value = "0x0" + value.substring(2);
        }
        return value.toLowerCase();
    }
    throw new Error(`invalid hexlify value type ${value}`);
}
exports.normalizeHexValue = normalizeHexValue;
function normalizeEthTransaction(tx) {
    if (!tx.from || typeof tx.from !== "string") {
        throw new Error("missing From in Transaction!");
    }
    return {
        from: tx.from,
        to: formalizeEthToAddress(tx.to),
        gas: normalizeHexValue(tx.gas || tx.gasLimit || constant_1.POLY_MAX_TRANSACTION_GAS_LIMIT),
        gasPrice: normalizeHexValue(tx.gasPrice || constant_1.POLY_MIN_GAS_PRICE),
        value: normalizeHexValue(tx.value || "0x00"),
        data: normalizeHexValue(tx.data || "0x00"),
    };
}
exports.normalizeEthTransaction = normalizeEthTransaction;
function serializeAddressMapping(addressMapping) {
    const _tx = (0, normalizer_1.NormalizeAddressMapping)(addressMapping);
    return new ckb_js_toolkit_1.Reader((0, addressMapping_1.SerializeAddressMapping)(_tx)).serializeJson();
}
exports.serializeAddressMapping = serializeAddressMapping;
function deserializeAddressMapping(value) {
    const data = new addressMapping_1.AddressMapping(new ckb_js_toolkit_1.Reader(value));
    const addresses_len = "0x" + data.getLength().toLittleEndianUint32().toString(16);
    const addresses_len_in_int = parseInt(addresses_len);
    return {
        length: addresses_len,
        data: [...Array(addresses_len_in_int).keys()].map((index) => {
            return {
                eth_address: new ckb_js_toolkit_1.Reader(data.getData().indexAt(index).getEthAddress().raw()).serializeJson(),
                gw_short_address: new ckb_js_toolkit_1.Reader(data.getData().indexAt(index).getGwShortAddress().raw()).serializeJson(),
            };
        }),
    };
}
exports.deserializeAddressMapping = deserializeAddressMapping;
function serializeRawL2TransactionWithAddressMapping(rawL2TransactionWithAddressMapping) {
    const _tx = (0, normalizer_1.NormalizeRawL2TransactionWithAddressMapping)(rawL2TransactionWithAddressMapping);
    return new ckb_js_toolkit_1.Reader((0, addressMapping_1.SerializeRawL2TransactionWithAddressMapping)(_tx)).serializeJson();
}
exports.serializeRawL2TransactionWithAddressMapping = serializeRawL2TransactionWithAddressMapping;
function deserializeRawL2TransactionWithAddressMapping(value) {
    const data = new addressMapping_1.RawL2TransactionWithAddressMapping(new ckb_js_toolkit_1.Reader(value));
    const address_length = "0x" + data.getAddresses().getLength().toLittleEndianUint32().toString(16);
    const address_length_in_int = parseInt(address_length);
    const raw_tx = {
        from_id: "0x" + data.getRawTx().getFromId().toLittleEndianUint32().toString(16),
        to_id: "0x" + data.getRawTx().getToId().toLittleEndianUint32().toString(16),
        args: new ckb_js_toolkit_1.Reader(data.getRawTx().getArgs().raw()).serializeJson(),
        nonce: "0x" + data.getRawTx().getNonce().toLittleEndianUint32().toString(16),
    };
    const addressMapping = {
        length: address_length,
        data: [...Array(address_length_in_int).keys()].map((index) => {
            return {
                eth_address: new ckb_js_toolkit_1.Reader(data.getAddresses().getData().indexAt(index).getEthAddress().raw()).serializeJson(),
                gw_short_address: new ckb_js_toolkit_1.Reader(data.getAddresses().getData().indexAt(index).getGwShortAddress().raw()).serializeJson(),
            };
        }),
    };
    const rawL2TransactionWithAddressMapping = {
        raw_tx: raw_tx,
        addresses: addressMapping,
        extra: new ckb_js_toolkit_1.Reader(data.getExtra().raw()).serializeJson(),
    };
    return rawL2TransactionWithAddressMapping;
}
exports.deserializeRawL2TransactionWithAddressMapping = deserializeRawL2TransactionWithAddressMapping;
function serializeL2TransactionWithAddressMapping(l2TransactionWithAddressMapping) {
    const _tx = (0, normalizer_1.NormalizeL2TransactionWithAddressMapping)(l2TransactionWithAddressMapping);
    return new ckb_js_toolkit_1.Reader((0, addressMapping_1.SerializeL2TransactionWithAddressMapping)(_tx)).serializeJson();
}
exports.serializeL2TransactionWithAddressMapping = serializeL2TransactionWithAddressMapping;
function deserializeL2TransactionWithAddressMapping(value) {
    const data = new addressMapping_1.L2TransactionWithAddressMapping(new ckb_js_toolkit_1.Reader(value));
    const address_length = "0x" + data.getAddresses().getLength().toLittleEndianUint32().toString(16);
    const address_length_in_int = parseInt(address_length);
    const tx = {
        raw: {
            from_id: "0x" +
                data.getTx().getRaw().getFromId().toLittleEndianUint32().toString(16),
            to_id: "0x" +
                data.getTx().getRaw().getToId().toLittleEndianUint32().toString(16),
            args: new ckb_js_toolkit_1.Reader(data.getTx().getRaw().getArgs().raw()).serializeJson(),
            nonce: "0x" +
                data.getTx().getRaw().getNonce().toLittleEndianUint32().toString(16),
        },
        signature: new ckb_js_toolkit_1.Reader(data.getTx().getSignature().raw()).serializeJson(),
    };
    const addressMapping = {
        length: address_length,
        data: [...Array(address_length_in_int).keys()].map((index) => {
            return {
                eth_address: new ckb_js_toolkit_1.Reader(data.getAddresses().getData().indexAt(index).getEthAddress().raw()).serializeJson(),
                gw_short_address: new ckb_js_toolkit_1.Reader(data.getAddresses().getData().indexAt(index).getGwShortAddress().raw()).serializeJson(),
            };
        }),
    };
    const rawL2TransactionWithAddressMapping = {
        tx: tx,
        addresses: addressMapping,
        extra: new ckb_js_toolkit_1.Reader(data.getExtra().raw()).serializeJson(),
    };
    return rawL2TransactionWithAddressMapping;
}
exports.deserializeL2TransactionWithAddressMapping = deserializeL2TransactionWithAddressMapping;
function buildL2TransactionWithAddressMapping(tx, addressMappingItemVec, abiItem) {
    const addressMapping = {
        length: "0x" + addressMappingItemVec.length.toString(16),
        data: addressMappingItemVec,
    };
    return {
        tx: tx,
        addresses: addressMapping,
        extra: abiItem || constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR,
    };
}
exports.buildL2TransactionWithAddressMapping = buildL2TransactionWithAddressMapping;
function buildRawL2TransactionWithAddressMapping(tx, addressMappingItemVec, abiItem) {
    const addressMapping = {
        length: "0x" + addressMappingItemVec.length.toString(16),
        data: addressMappingItemVec,
    };
    return {
        raw_tx: tx,
        addresses: addressMapping,
        extra: abiItem || constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR,
    };
}
exports.buildRawL2TransactionWithAddressMapping = buildRawL2TransactionWithAddressMapping;
function serializeL2Transaction(tx) {
    const _tx = (0, normalizer_1.NormalizeL2Transaction)(tx);
    return new ckb_js_toolkit_1.Reader((0, schemas_1.SerializeL2Transaction)(_tx)).serializeJson();
}
exports.serializeL2Transaction = serializeL2Transaction;
function serializeRawL2Transaction(tx) {
    const _tx = (0, normalizer_1.NormalizeRawL2Transaction)(tx);
    return new ckb_js_toolkit_1.Reader((0, schemas_1.SerializeRawL2Transaction)(_tx)).serializeJson();
}
exports.serializeRawL2Transaction = serializeRawL2Transaction;
function decodeArgs(_args) {
    const args = _args.slice(2);
    const args_0_7 = "0x" + args.slice(0, 14);
    const args_7 = "0x" + args.slice(14, 16);
    const args_8_16 = "0x" + args.slice(16, 32);
    const args_16_32 = "0x" + args.slice(32, 64);
    const args_32_48 = "0x" + args.slice(64, 96);
    const args_48_52 = "0x" + args.slice(96, 104);
    const args_data = "0x" + args.slice(104);
    const header = buffer_1.Buffer.from(args_0_7.slice(8), "hex").toString("utf-8");
    const type = args_7;
    const gas_limit = "0x" + LeBytesToUInt64(args_8_16).toString(16);
    const gas_price = "0x" + LeBytesToUInt128(args_16_32).toString(16);
    const value = "0x" + LeBytesToUInt128(args_32_48).toString(16);
    const data_length = "0x" + LeBytesToUInt32(args_48_52).toString(16);
    const data = args_data;
    return { header, type, gas_limit, gas_price, value, data_length, data };
}
exports.decodeArgs = decodeArgs;
function encodeArgs(_tx) {
    const { to, gasPrice, gas: gasLimit, value, data } = _tx;
    // header
    const args_0_7 = "0x" +
        buffer_1.Buffer.from("FFFFFF", "hex").toString("hex") +
        buffer_1.Buffer.from("POLY", "utf8").toString("hex");
    // gas limit
    const args_8_16 = UInt64ToLeBytes(BigInt(gasLimit));
    // gas price
    const args_16_32 = UInt128ToLeBytes(gasPrice === "0x" ? BigInt(0) : BigInt(gasPrice));
    // value
    const args_32_48 = UInt128ToLeBytes(value === "0x" ? BigInt(0) : BigInt(value));
    const dataByteLength = buffer_1.Buffer.from(data.slice(2), "hex").length;
    // data length
    const args_48_52 = UInt32ToLeBytes(dataByteLength);
    // data
    const args_data = data;
    let args_7 = "";
    if (to === constant_1.DEFAULT_EMPTY_ETH_ADDRESS || to === "0x" || to === "0x0") {
        args_7 = "0x03";
    }
    else {
        args_7 = "0x00";
    }
    const args = "0x" +
        args_0_7.slice(2) +
        args_7.slice(2) +
        args_8_16.slice(2) +
        args_16_32.slice(2) +
        args_32_48.slice(2) +
        args_48_52.slice(2) +
        args_data.slice(2);
    return args;
}
exports.encodeArgs = encodeArgs;
function encodeSudtTransferArgs(toAddress, amount, fee) {
    const sudtTransfer = {
        to: toAddress,
        amount: "0x" + amount.toString(16),
        fee: "0x" + fee.toString(16),
    };
    const sudtArgs = {
        type: "SUDTTransfer",
        value: (0, normalizer_1.NormalizeSUDTTransfer)(sudtTransfer),
    };
    const serializedSudtArgs = new ckb_js_toolkit_1.Reader((0, schemas_1.SerializeSUDTArgs)(sudtArgs)).serializeJson();
    return serializedSudtArgs;
}
exports.encodeSudtTransferArgs = encodeSudtTransferArgs;
function ethToCkb(value, decimal = constant_1.DEFAULT_ETH_TO_CKB_SUDT_DECIMAL) {
    return BigInt(value) / BigInt(decimal);
}
exports.ethToCkb = ethToCkb;
function ckbToEth(value, decimal = constant_1.DEFAULT_ETH_TO_CKB_SUDT_DECIMAL) {
    return BigInt(value) * BigInt(decimal);
}
exports.ckbToEth = ckbToEth;
class Godwoker {
    constructor(host, option) {
        var _a, _b, _c, _d, _e;
        const callServer = function (request, callback) {
            const opt = (option === null || option === void 0 ? void 0 : option.request_option) || {
                method: "POST",
                body: request,
                headers: {
                    "Content-Type": "application/json",
                },
            };
            fetch(host, opt)
                .then(function (res) {
                return res.text();
            })
                .then(function (text) {
                callback(null, text);
            })
                .catch(function (err) {
                callback(err);
            });
        };
        this.client = jaysonBrowserClient(callServer);
        this.godwokenUtils = new godwoken_1.GodwokenUtils((_a = option === null || option === void 0 ? void 0 : option.godwoken) === null || _a === void 0 ? void 0 : _a.rollup_type_hash);
        this.eth_account_lock = (_b = option === null || option === void 0 ? void 0 : option.godwoken) === null || _b === void 0 ? void 0 : _b.eth_account_lock;
        this.rollup_type_hash = (_c = option === null || option === void 0 ? void 0 : option.godwoken) === null || _c === void 0 ? void 0 : _c.rollup_type_hash;
        this.creator_id = (_d = option === null || option === void 0 ? void 0 : option.polyjuice) === null || _d === void 0 ? void 0 : _d.creator_id;
        this.default_from_address = (_e = option === null || option === void 0 ? void 0 : option.polyjuice) === null || _e === void 0 ? void 0 : _e.default_from_address;
        this.queryEthAddressByShortAddress = option === null || option === void 0 ? void 0 : option.queryEthAddressByShortAddress;
        this.saveEthAddressShortAddressMapping =
            option === null || option === void 0 ? void 0 : option.saveEthAddressShortAddressMapping;
    }
    // call init if you haven't pass rollup configs to constructor
    async init() {
        var _a;
        if (!this.rollup_type_hash) {
            this.rollup_type_hash = await this.getRollupTypeHash();
        }
        if (!((_a = this.eth_account_lock) === null || _a === void 0 ? void 0 : _a.code_hash)) {
            this.eth_account_lock = {
                code_hash: await this.getEthAccountLockHash(),
                hash_type: "type",
            };
        }
        if (!this.creator_id) {
            this.creator_id = await this.getPolyjuiceCreatorAccountId();
        }
        if (!this.default_from_address) {
            this.default_from_address = await this.getPolyjuiceDefaultFromAddress();
        }
        if (!this.godwokenUtils.rollupTypeHash) {
            this.godwokenUtils = new godwoken_1.GodwokenUtils(this.rollup_type_hash);
        }
    }
    initSync() {
        const that = this;
        const rollupPromise = () => {
            return this.rollup_type_hash
                ? this.rollup_type_hash
                : this.getRollupTypeHash();
        };
        const ethAccountPromise = () => {
            var _a, _b;
            return ((_a = this.eth_account_lock) === null || _a === void 0 ? void 0 : _a.code_hash)
                ? (_b = this.eth_account_lock) === null || _b === void 0 ? void 0 : _b.code_hash
                : this.getEthAccountLockHash();
        };
        const creatorIdPromise = () => {
            return this.creator_id
                ? this.creator_id
                : this.getPolyjuiceCreatorAccountId();
        };
        const defaultFromAddressPromise = () => {
            return this.default_from_address
                ? this.default_from_address
                : this.getPolyjuiceDefaultFromAddress();
        };
        return Promise.all([
            rollupPromise(),
            ethAccountPromise(),
            creatorIdPromise(),
            defaultFromAddressPromise(),
        ])
            .then(function (args) {
            that.rollup_type_hash = args[0];
            that.eth_account_lock = {
                code_hash: args[1],
                hash_type: "type",
            };
            that.creator_id = args[2];
            that.default_from_address = args[3];
            if (!that.godwokenUtils.rollupTypeHash)
                that.godwokenUtils = new godwoken_1.GodwokenUtils(that.rollup_type_hash);
            return Promise.resolve();
        })
            .catch(function (err) {
            return Promise.reject(err);
        });
    }
    packSignature(_signature) {
        let v = Number.parseInt(_signature.slice(-2), 16);
        if (v >= 27)
            v -= 27;
        const signature = _signature.slice(0, -2) + v.toString(16).padStart(2, "0");
        return signature;
    }
    async jsonRPC(method, params, _errMsgWhenNoResult, requireResult = RequireResult.canNotBeEmpty) {
        const errMsgWhenNoResult = _errMsgWhenNoResult || "";
        const errWhenNoResult = new Error(`result from jsonRPC ${method} is null or undefined. ${errMsgWhenNoResult}`);
        return new Promise((resolve, reject) => {
            this.client.request(method, params, (err, res) => {
                if (err)
                    return reject(err);
                if (!res)
                    return reject(new Error("Rpc Response not found!"));
                if (res.error)
                    return reject(res.error);
                if (requireResult === RequireResult.canBeEmpty)
                    return resolve(res.result); // here result might be non-exist
                if (res.result === undefined || res.result === null)
                    return reject(errWhenNoResult);
                return resolve(res.result);
            });
        });
    }
    computeScriptHashByEoaEthAddress(eth_address) {
        var _a, _b;
        const layer2_lock = {
            code_hash: ((_a = this.eth_account_lock) === null || _a === void 0 ? void 0 : _a.code_hash) || "",
            hash_type: (_b = this.eth_account_lock) === null || _b === void 0 ? void 0 : _b.hash_type,
            args: this.rollup_type_hash + eth_address.slice(2),
        };
        const lock_hash = base_1.utils.computeScriptHash(layer2_lock);
        return lock_hash;
    }
    async getScriptByScriptHash(_script_hash) {
        const errorWhenNoResult = `unable to fetch script from ${_script_hash}`;
        return this.jsonRPC("gw_get_script", [_script_hash], errorWhenNoResult);
    }
    async getScriptHashByAccountId(account_id) {
        const errorWhenNoResult = `unable to fetch account script hash from 0x${BigInt(account_id).toString(16)}`;
        return this.jsonRPC("gw_get_script_hash", [`0x${BigInt(account_id).toString(16)}`], errorWhenNoResult);
    }
    async getAccountIdByScriptHash(script_hash) {
        const errorWhenNoResult = `unable to fetch account id from script hash ${script_hash}`;
        return this.jsonRPC("gw_get_account_id_by_script_hash", [script_hash], errorWhenNoResult);
    }
    async getAccountIdByEoaEthAddress(eth_address) {
        var _a, _b;
        const layer2_lock = {
            code_hash: ((_a = this.eth_account_lock) === null || _a === void 0 ? void 0 : _a.code_hash) || "",
            hash_type: (_b = this.eth_account_lock) === null || _b === void 0 ? void 0 : _b.hash_type,
            args: this.rollup_type_hash + eth_address.slice(2),
        };
        const lock_hash = base_1.utils.computeScriptHash(layer2_lock);
        const errorWhenNoResult = `unable to fetch account id from ${eth_address}, lock_hash is ${lock_hash}`;
        return this.jsonRPC("gw_get_account_id_by_script_hash", [lock_hash], errorWhenNoResult);
    }
    async getScriptHashByShortAddress(_address, requireResult = RequireResult.canNotBeEmpty) {
        const errorWhenNoResult = `unable to fetch script from ${_address}`;
        return this.jsonRPC("gw_get_script_hash_by_short_address", [_address], errorWhenNoResult, requireResult);
    }
    computeShortAddressByEoaEthAddress(_address) {
        const short_address = this.computeScriptHashByEoaEthAddress(_address).slice(0, 42);
        return short_address;
    }
    async getShortAddressByAllTypeEthAddress(_address) {
        // todo: support create2 address in such case that it haven't create real contract yet.
        if (_address === constant_1.DEFAULT_EMPTY_ETH_ADDRESS) {
            // special case: 0x0000...
            // todo: right now we keep the 0x00000.., later maybe should convert to polyjuice creator short address?
            return {
                value: _address,
                type: types_1.ShortAddressType.creatorAddress,
            };
        }
        try {
            // assume it is an contract address (thus already an short address)
            const isContractAddress = await this.isShortAddressOnChain(_address);
            if (isContractAddress) {
                return {
                    value: _address,
                    type: types_1.ShortAddressType.contractAddress,
                };
            }
            // script hash not exist with short address, assume it is EOA address..
            const short_addr = this.computeShortAddressByEoaEthAddress(_address);
            const is_eoa_exist = await this.isShortAddressOnChain(short_addr);
            if (is_eoa_exist) {
                return {
                    value: short_addr,
                    type: types_1.ShortAddressType.eoaAddress,
                };
            }
            // not exist eoa address:
            // remember to save the script and eoa address mapping with user-specific callback function
            if (this.saveEthAddressShortAddressMapping) {
                this.saveEthAddressShortAddressMapping(_address, short_addr);
            }
            return {
                value: short_addr,
                type: types_1.ShortAddressType.notExistEoaAddress,
            };
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    async getEthAddressByAllTypeShortAddress(_short_address) {
        // todo: support create2 address in such case which it haven't create real contract yet.
        var _a;
        if (_short_address === constant_1.DEFAULT_EMPTY_ETH_ADDRESS) {
            // special case: 0x0000...
            // todo: right now we keep the 0x00000.., later maybe should convert to polyjuice creator short address?
            return _short_address;
        }
        // first, query on-chain
        const is_address_on_chain = await this.isShortAddressOnChain(_short_address);
        if (is_address_on_chain) {
            const script_hash = await this.getScriptHashByShortAddress(_short_address);
            const script = await this.getScriptByScriptHash(script_hash);
            if (script.code_hash === ((_a = this.eth_account_lock) === null || _a === void 0 ? void 0 : _a.code_hash)) {
                // eoa address
                return "0x" + script.args.slice(66, 106);
            }
            // assume it is contract address
            return _short_address;
        }
        // not on-chain, assume it is eoa address which haven't create account on godwoken yet
        const query_callback = this.queryEthAddressByShortAddress
            ? this.queryEthAddressByShortAddress
            : this.defaultQueryEthAddressByShortAddress.bind(this);
        const eth_address = await query_callback(_short_address);
        // check address and short_address indeed matched.
        if (this.checkEthAddressIsEoa(eth_address, _short_address)) {
            return eth_address;
        }
        throw Error(`query result of eoa address ${_short_address} with ${_short_address} is not match!`);
    }
    async isShortAddressOnChain(short_address, scriptHashCallback) {
        scriptHashCallback =
            scriptHashCallback || function (_script_hash) { };
        try {
            const script_hash = await this.getScriptHashByShortAddress(short_address, RequireResult.canBeEmpty);
            if (script_hash) {
                scriptHashCallback(script_hash);
                return true;
            }
            // not exist on chain
            return false;
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    // re-compute the eth address with code_hash info to make sure
    // it indeed match with short_address
    checkEthAddressIsEoa(eth_address, _target_short_address) {
        const source_short_address = this.computeShortAddressByEoaEthAddress(eth_address);
        return (source_short_address.toLowerCase() === _target_short_address.toLowerCase());
    }
    // default method
    async defaultQueryEthAddressByShortAddress(_short_address) {
        const errorWhenNoResult = `unable to fetch eth address from ${_short_address}`;
        return this.jsonRPC("poly_getEthAddressByGodwokenShortAddress", [_short_address], errorWhenNoResult);
    }
    async getNonce(account_id) {
        const errorWhenNoResult = `unable to fetch nonce, account_id: ${account_id}}`;
        return this.jsonRPC("gw_get_nonce", [`0x${account_id.toString(16)}`], errorWhenNoResult);
    }
    async assembleRawL2Transaction(eth_tx) {
        const from = await this.getAccountIdByEoaEthAddress(eth_tx.from);
        const to = await this.allTypeEthAddressToAccountId(eth_tx.to);
        const nonce = await this.getNonce(parseInt(from));
        const encodedArgs = encodeArgs(eth_tx);
        const tx = {
            from_id: "0x" + BigInt(from).toString(16),
            to_id: "0x" + BigInt(to).toString(16),
            args: encodedArgs,
            nonce: "0x" + BigInt(nonce).toString(16),
        };
        return tx;
    }
    generateTransactionMessageToSign(tx, sender_script_hash, receiver_script_hash, is_add_prefix_in_signing_message = false) {
        return this.godwokenUtils.generateTransactionMessageToSign(tx, sender_script_hash, receiver_script_hash, is_add_prefix_in_signing_message);
    }
    async generateMessageFromRawL2Transaction(rawL2Tx, msg_type = types_1.SigningMessageType.withPrefix) {
        const sender_script_hash = await this.getScriptHashByAccountId(parseInt(rawL2Tx.from_id, 16));
        const receiver_script_hash = await this.getScriptHashByAccountId(parseInt(rawL2Tx.to_id, 16));
        const message = this.generateTransactionMessageToSign(rawL2Tx, sender_script_hash, receiver_script_hash, msg_type === types_1.SigningMessageType.withPrefix // with personal sign prefix in message, default is true.
        );
        return message;
    }
    async generateMessageFromEthTransaction(tx, msg_type = types_1.SigningMessageType.withPrefix) {
        const { from, to } = tx;
        const to_id = await this.allTypeEthAddressToAccountId(to);
        const sender_script_hash = this.computeScriptHashByEoaEthAddress(from);
        const receiver_script_hash = await this.getScriptHashByAccountId(parseInt(to_id));
        const polyjuice_tx = await this.assembleRawL2Transaction(tx);
        const message = this.generateTransactionMessageToSign(polyjuice_tx, sender_script_hash, receiver_script_hash, msg_type === types_1.SigningMessageType.withPrefix // with personal sign prefix in message, default is true.
        );
        return message;
    }
    serializeL2Transaction(tx) {
        const _tx = (0, normalizer_1.NormalizeL2Transaction)(tx);
        return new ckb_js_toolkit_1.Reader((0, schemas_1.SerializeL2Transaction)(_tx)).serializeJson();
    }
    serializeRawL2Transaction(tx) {
        const _tx = (0, normalizer_1.NormalizeRawL2Transaction)(tx);
        return new ckb_js_toolkit_1.Reader((0, schemas_1.SerializeRawL2Transaction)(_tx)).serializeJson();
    }
    serializeL2TransactionWithAddressMapping(tx) {
        const _tx = (0, normalizer_1.NormalizeL2TransactionWithAddressMapping)(tx);
        return new ckb_js_toolkit_1.Reader((0, addressMapping_1.SerializeL2TransactionWithAddressMapping)(_tx)).serializeJson();
    }
    serializeRawL2TransactionWithAddressMapping(tx) {
        const _tx = (0, normalizer_1.NormalizeRawL2TransactionWithAddressMapping)(tx);
        return new ckb_js_toolkit_1.Reader((0, addressMapping_1.SerializeRawL2TransactionWithAddressMapping)(_tx)).serializeJson();
    }
    async gw_executeL2Transaction(raw_tx, signature) {
        const l2_tx = { raw: raw_tx, signature: signature };
        const serialize_tx = this.serializeL2Transaction(l2_tx);
        const errorWhenNoResult = `failed to get gw_execute_l2transaction runResult.`;
        return this.jsonRPC("gw_execute_l2transaction", [serialize_tx], errorWhenNoResult);
    }
    async gw_executeRawL2Transaction(raw_tx) {
        const serialize_tx = this.serializeRawL2Transaction(raw_tx);
        const errorWhenNoResult = `failed to get gw_executeRawL2Transaction runResult`;
        return this.jsonRPC("gw_execute_raw_l2transaction", [serialize_tx], errorWhenNoResult);
    }
    // poly_executeRawL2Transaction diff from gw_executeRawL2Transaction for it carry extra addressMapping data
    async poly_executeRawL2Transaction(raw_tx) {
        const serialize_tx = this.serializeRawL2TransactionWithAddressMapping(raw_tx);
        const errorWhenNoResult = `failed to get poly_execute_raw_l2transaction runResult`;
        return this.jsonRPC("poly_executeRawL2Transaction", [serialize_tx], errorWhenNoResult);
    }
    async gw_submitL2Transaction(raw_tx, signature) {
        const l2_tx = { raw: raw_tx, signature: signature };
        const serialize_tx = this.serializeL2Transaction(l2_tx);
        const errorWhenNoResult = `failed to get gw_submit_l2transaction txHash, l2_tx: ${JSON.stringify(l2_tx, null, 2)}`;
        return this.jsonRPC("gw_submit_l2transaction", [serialize_tx], errorWhenNoResult);
    }
    async gw_submitSerializedL2Transaction(serialize_tx) {
        const errorWhenNoResult = `failed to get gw_submit_l2transaction txHash, serialize_tx: serialize_tx`;
        return this.jsonRPC("gw_submit_l2transaction", [serialize_tx], errorWhenNoResult);
    }
    // poly_submitL2Transaction diff from gw_submitL2Transaction for it carry extra addressMapping data
    async poly_submitL2Transaction(l2_tx) {
        const serialize_tx = this.serializeL2TransactionWithAddressMapping(l2_tx);
        const errorWhenNoResult = `failed to get poly_submitL2Transaction txHash, l2_tx: ${JSON.stringify(l2_tx, null, 2)}`;
        return this.jsonRPC("poly_submitL2Transaction", [serialize_tx], errorWhenNoResult);
    }
    async poly_submitSerializedL2Transaction(serialize_tx) {
        const errorWhenNoResult = `failed to get gw_submit_l2transaction txHash, serialize_tx: serialize_tx`;
        return this.jsonRPC("poly_submitL2Transaction", [serialize_tx], errorWhenNoResult);
    }
    async gw_getTransactionReceipt(tx_hash) {
        return this.jsonRPC("gw_get_transaction_receipt", [tx_hash], null, RequireResult.canBeEmpty);
    }
    async getRollupTypeHash() {
        const errorWhenNoResult = `unable to fetch rollupTypeHash from web3 server.`;
        return this.jsonRPC("poly_getRollupTypeHash", [], errorWhenNoResult);
    }
    async getEthAccountLockHash() {
        const errorWhenNoResult = `unable to fetch ethAccountLockHash from web3 server.`;
        return this.jsonRPC("poly_getEthAccountLockHash", [], errorWhenNoResult);
    }
    async getContractValidatorHash() {
        const errorWhenNoResult = `unable to fetch ContractValidatorHash from web3 server.`;
        return this.jsonRPC("poly_getContractValidatorTypeHash", [], errorWhenNoResult);
    }
    async getPolyjuiceCreatorAccountId() {
        const errorWhenNoResult = `unable to fetch creatorId from web3 server.`;
        return this.jsonRPC("poly_getCreatorId", [], errorWhenNoResult);
    }
    async getPolyjuiceDefaultFromAddress() {
        const errorWhenNoResult = `unable to fetch defaultFromAddress from web3 server.`;
        return this.jsonRPC("poly_getDefaultFromAddress", [], errorWhenNoResult);
    }
    async eth_getTransactionReceipt(tx_hash) {
        return this.jsonRPC("eth_getTransactionReceipt", [tx_hash], null, RequireResult.canBeEmpty);
    }
    async gw_getTransaction(tx_hash, verbose) {
        const args = verbose != null ? [tx_hash, verbose] : [tx_hash];
        return this.jsonRPC("gw_get_transaction", args, null, RequireResult.canBeEmpty);
    }
    async waitForTransactionReceipt(tx_hash, timeout_ms = constant_1.WAIT_TIMEOUT_MILSECS, loop_interval_ms = constant_1.WAIT_LOOP_INTERVAL_MILSECS, show_log = false) {
        for (let index = 0; index < timeout_ms; index += loop_interval_ms) {
            const tx_with_status = await this.gw_getTransaction(tx_hash);
            if (tx_with_status !== null) {
                return;
            }
            await this.asyncSleep(loop_interval_ms);
            if (show_log === true) {
                console.log(`keep fetching tx_receipt with ${tx_hash}, waited for ${index} mil seconds`);
            }
        }
        throw new Error(`tx might be failed: cannot fetch tx_receipt with tx ${tx_hash} in ${timeout_ms} mil seconds`);
    }
    asyncSleep(ms = 0) {
        return new Promise((r) => setTimeout(r, ms));
    }
    async allTypeEthAddressToScriptHash(_address) {
        // todo: support create2 address in such case that it haven't create real contract yet.
        const address = buffer_1.Buffer.from(_address.slice(2), "hex");
        if (address.byteLength !== 20)
            throw new Error(`Invalid eth address length: ${address.byteLength}`);
        if (address.equals(buffer_1.Buffer.from(Array(20).fill(0)))) {
            // special-case: meta-contract address should return creator id
            const to_id = this.creator_id || (await this.getPolyjuiceCreatorAccountId());
            return await this.getScriptHashByAccountId(parseInt(to_id, 16));
        }
        // assume it is normal contract address, thus an godwoken-short-address
        let script_hash;
        const setScriptHash = (value) => {
            script_hash = value;
        };
        const is_contract_address = await this.isShortAddressOnChain(_address, setScriptHash);
        if (is_contract_address) {
            return script_hash;
        }
        // otherwise, assume it is EOA address
        return this.computeScriptHashByEoaEthAddress(_address);
    }
    async allTypeEthAddressToAccountId(_address) {
        // todo: support create2 address in such case that it haven't create real contract yet.
        const address = buffer_1.Buffer.from(_address.slice(2), "hex");
        if (address.byteLength !== 20)
            throw new Error(`Invalid eth address length: ${address.byteLength}`);
        if (address.equals(buffer_1.Buffer.from(Array(20).fill(0))))
            // special-case: meta-contract address should return creator id
            return this.creator_id || (await this.getPolyjuiceCreatorAccountId());
        // assume it is normal contract address, thus an godwoken-short-address
        let script_hash;
        const setScriptHash = (value) => {
            script_hash = value;
        };
        const is_contract_address = await this.isShortAddressOnChain(_address, setScriptHash);
        if (is_contract_address) {
            // below the getScriptHashByShortAddress request is no need
            // since we have pass callback fn to get ScriptHash value
            //script_hash = await this.getScriptHashByShortAddress(_address);
            return await this.getAccountIdByScriptHash(script_hash);
        }
        // otherwise, assume it is EOA address
        script_hash = this.computeScriptHashByEoaEthAddress(_address);
        const accountId = await this.getAccountIdByScriptHash(script_hash);
        return accountId;
    }
}
exports.Godwoker = Godwoker;
function calculateByteCodeSignature(bytecode) {
    const byteCodeSignature = (0, keccak256_1.default)(buffer_1.Buffer.from(bytecode, "hex"))
        .slice(0, constant_2.CONTRACT_BYTE_CODE_HASH_HEAD_IN_BYTE)
        .toString("hex");
    return "0x" + byteCodeSignature;
}
exports.calculateByteCodeSignature = calculateByteCodeSignature;
function calculateDeploymentSignature(bytecode // does not contains with "0x"
) {
    validateBytecode(bytecode);
    const length = bytecode.length;
    const byteCodeId = bytecode.slice(-constant_2.CONTRACT_BYTE_CODE_ID_OFFSET);
    const byteCodeSignature = calculateByteCodeSignature(bytecode).slice(2);
    const deploymentSignature = UInt32ToLeBytes(length) + byteCodeId + byteCodeSignature;
    return deploymentSignature;
}
exports.calculateDeploymentSignature = calculateDeploymentSignature;
function restoreDeploymentSignature(signature) {
    const lengthHexString = signature.slice(0, 10); // "0x" + first 4 bytes = uint32LeByte(length)
    const length = LeBytesToUInt32(lengthHexString);
    const byteCodeId = signature.slice(10, constant_2.CONTRACT_BYTE_CODE_ID_OFFSET + 10);
    const byteCodeSignature = signature.slice(-(constant_2.CONTRACT_BYTE_CODE_HASH_HEAD_IN_BYTE * 2));
    return {
        length,
        byteCodeId,
        byteCodeSignature,
    };
}
exports.restoreDeploymentSignature = restoreDeploymentSignature;
function splitByteCodeAndConstructorArgs(inputData, deploymentRecords) {
    const signatures = Object.keys(deploymentRecords);
    for (const signature of signatures) {
        const byteCodeLength = restoreDeploymentSignature(signature).length;
        const isMatched = checkMatchByteCode(inputData, signature);
        if (isMatched) {
            const bytecode = inputData.slice(2).slice(0, byteCodeLength);
            const args = inputData.slice(2).slice(byteCodeLength);
            return {
                bytecode,
                args,
                signature,
            };
        }
        // did not find matched deploymentRecords
        return undefined;
    }
}
exports.splitByteCodeAndConstructorArgs = splitByteCodeAndConstructorArgs;
function checkMatchByteCode(inputData_, deploymentSignature) {
    const inputData = inputData_.slice(2); // remove "0x"
    const result = restoreDeploymentSignature(deploymentSignature);
    if (!inputData.includes(result.byteCodeId)) {
        return false;
    }
    const byteCodeLength = result.length;
    if (inputData.length < byteCodeLength) {
        return false;
    }
    const bytecode = inputData.slice(0, byteCodeLength);
    const bytecodeSignature = calculateByteCodeSignature(bytecode).slice(2);
    return bytecodeSignature === result.byteCodeSignature;
}
exports.checkMatchByteCode = checkMatchByteCode;
// replace the constructor arguments for contract deployment if it is address-type related.
// since the input data do not contains function signature(format = contract bytecode + args), and we support multiple ABIs,
// it is not possible to decode the constructor args in the stage of sending transaction from providers,
// we will require developers do address converting using the below method before deploying contract explicitly.
async function convertContractConstructorArgs(args, abiItems, bytecode, calculate_short_address) {
    validateBytecode(bytecode);
    const deploymentSignature = calculateDeploymentSignature(bytecode);
    let deploymentRecords = {};
    let addressMapping = [];
    const constructorAbiItems = abiItems.filter((item) => item.type === "constructor");
    if (constructorAbiItems.length === 0) {
        return {
            newArgs: args,
            isInterested: false,
            addressMapping,
            deploymentRecords,
        };
    }
    if (constructorAbiItems.length > 1) {
        throw new Error(`invalid abiItems! more than one constructor found. ${JSON.stringify(abiItems, null, 2)}`);
    }
    const abiItem = constructorAbiItems[0];
    deploymentRecords[deploymentSignature] = abiItem;
    if (!abiItem.inputs) {
        return {
            newArgs: args,
            isInterested: false,
            addressMapping,
            deploymentRecords,
        };
    }
    if (args.length !== abiItem.inputs.length) {
        throw new Error(`args'length ${args.length} and abiItem's inputs length ${abiItem.inputs.length} did not matched!`);
    }
    const isInterested = abiItem.inputs.filter((input) => input.type === "address" || input.type === "address[]").length > 0;
    if (!isInterested) {
        return {
            newArgs: args,
            isInterested: false,
            addressMapping,
            deploymentRecords,
        };
    }
    const convertArgs = await Promise.all(args.map(async (arg, index) => {
        let newArg;
        const type = abiItem.inputs[index].type;
        switch (type) {
            case "address":
                validateEthAddress(arg);
                const shortAddress = await calculate_short_address(arg);
                newArg = shortAddress.value;
                if (shortAddress.type === types_1.ShortAddressType.notExistEoaAddress) {
                    // save the mapping for later usage
                    addressMapping.push({
                        eth_address: arg,
                        gw_short_address: shortAddress.value,
                    });
                }
                break;
            case "address[]":
                validateEthAddressArray(arg);
                newArg = await Promise.all(await arg.map(async (item) => {
                    const shortAddress = await calculate_short_address(item);
                    if (shortAddress.type === types_1.ShortAddressType.notExistEoaAddress) {
                        addressMapping.push({
                            eth_address: item,
                            gw_short_address: shortAddress.value,
                        });
                    }
                    return shortAddress.value;
                }));
                break;
            default:
                newArg = arg;
                break;
        }
        return newArg;
    }));
    return {
        newArgs: convertArgs,
        isInterested: true,
        addressMapping,
        deploymentRecords,
    };
}
exports.convertContractConstructorArgs = convertContractConstructorArgs;
function validateEthAddress(value) {
    if (typeof value !== "string") {
        throw new Error(`ethAddress is not string, ${value}`);
    }
    if (value.length !== 42) {
        throw new Error(`ethAddress's length is not 42, ${value}`);
    }
    if (!value.startsWith("0x")) {
        throw new Error(`ethAddress does not start with 0x, ${value}`);
    }
}
exports.validateEthAddress = validateEthAddress;
function validateEthAddressArray(value) {
    if (!Array.isArray(value)) {
        throw new Error(`ethAddressArray is not a array, ${value}`);
    }
    for (let item of value) {
        validateEthAddress(item);
    }
}
exports.validateEthAddressArray = validateEthAddressArray;
function validateBytecode(value) {
    if (typeof value !== "string") {
        throw new Error(`bytecode is not string, ${value}`);
    }
    if (value === "") {
        throw new Error(`contract bytecode can not be empty, ${value}`);
    }
    const byteSize = buffer_1.Buffer.from(value, "hex").byteLength;
    if (byteSize >= constant_2.MAX_CONTRACT_CODE_SIZE_IN_BYTE) {
        throw new Error(`max bytecode size: ${constant_2.MAX_CONTRACT_CODE_SIZE_IN_BYTE},  found ${byteSize}.`);
    }
    // todo: add more validation
}
exports.validateBytecode = validateBytecode;
// todo: move to another file
function UInt8ToLeBytes(num) {
    const buf = buffer_1.Buffer.allocUnsafe(1);
    buf.writeUInt8(+num, 0);
    return "0x" + buf.toString("hex");
}
exports.UInt8ToLeBytes = UInt8ToLeBytes;
function UInt32ToLeBytes(num) {
    const buf = buffer_1.Buffer.allocUnsafe(4);
    buf.writeUInt32LE(+num, 0);
    return "0x" + buf.toString("hex");
}
exports.UInt32ToLeBytes = UInt32ToLeBytes;
function UInt64ToLeBytes(num) {
    num = BigInt(num);
    const buf = buffer_1.Buffer.alloc(8);
    buf.writeBigUInt64LE(num);
    return `0x${buf.toString("hex")}`;
}
exports.UInt64ToLeBytes = UInt64ToLeBytes;
function UInt128ToLeBytes(u128) {
    if (u128 < constant_1.U128_MIN) {
        throw new Error(`u128 ${u128} too small`);
    }
    if (u128 > constant_1.U128_MAX) {
        throw new Error(`u128 ${u128} too large`);
    }
    const buf = buffer_1.Buffer.alloc(16);
    buf.writeBigUInt64LE(u128 & BigInt("0xFFFFFFFFFFFFFFFF"), 0);
    buf.writeBigUInt64LE(u128 >> BigInt(64), 8);
    return "0x" + buf.toString("hex");
}
exports.UInt128ToLeBytes = UInt128ToLeBytes;
function LeBytesToUInt8(hex) {
    const buf = buffer_1.Buffer.from(hex.slice(2), "hex");
    return buf.readUInt8();
}
exports.LeBytesToUInt8 = LeBytesToUInt8;
function LeBytesToUInt32(hex) {
    const buf = buffer_1.Buffer.from(hex.slice(2), "hex");
    return buf.readUInt32LE();
}
exports.LeBytesToUInt32 = LeBytesToUInt32;
function LeBytesToUInt64(hex) {
    const buf = buffer_1.Buffer.from(hex.slice(2), "hex");
    return buf.readBigUInt64LE();
}
exports.LeBytesToUInt64 = LeBytesToUInt64;
function LeBytesToUInt128(hex) {
    const buf = buffer_1.Buffer.from(hex.slice(2), "hex");
    return buf.slice(8, 16).readBigUInt64LE();
}
exports.LeBytesToUInt128 = LeBytesToUInt128;
//# sourceMappingURL=util.js.map