"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSerializeAddressMappingAbiItem = exports.buildProcess = exports.buildDeployProcess = exports.buildEstimateGasTransaction = exports.executeCallTransaction = exports.buildSendTransaction = exports.ProcessTransactionType = void 0;
const util_1 = require("./util");
const abi_1 = require("./abi");
const types_1 = require("./types");
const constant_1 = require("./constant");
const lodash_1 = __importDefault(require("lodash"));
var ProcessTransactionType;
(function (ProcessTransactionType) {
    ProcessTransactionType[ProcessTransactionType["send"] = 0] = "send";
    ProcessTransactionType[ProcessTransactionType["call"] = 1] = "call";
    ProcessTransactionType[ProcessTransactionType["estimateGas"] = 2] = "estimateGas";
})(ProcessTransactionType = exports.ProcessTransactionType || (exports.ProcessTransactionType = {}));
async function buildSendTransaction(abi, godwoker, tx, signingMethod, signingMessageType) {
    const process = {
        type: ProcessTransactionType.send,
        signingMethod: signingMethod,
        signingMessageType: signingMessageType,
    };
    const serializeTx = await buildProcess(abi, godwoker, tx, process);
    if (typeof serializeTx !== "string")
        throw new Error("build sendTransaction end up with non-string type return!");
    return serializeTx;
}
exports.buildSendTransaction = buildSendTransaction;
async function executeCallTransaction(abi, godwoker, tx) {
    const process = {
        type: ProcessTransactionType.call,
    };
    const callReturnData = await buildProcess(abi, godwoker, tx, process);
    if (typeof callReturnData !== "string")
        throw new Error("execute callTransaction end up with non-string return!");
    return callReturnData;
}
exports.executeCallTransaction = executeCallTransaction;
async function buildEstimateGasTransaction(abi, godwoker, tx) {
    const process = {
        type: ProcessTransactionType.call,
    };
    const rawL2Tx = await buildProcess(abi, godwoker, tx, process);
    if (typeof rawL2Tx === "string")
        throw new Error("build estimateGasTransaction end up with string return!");
    if (!isRawL2Transaction(rawL2Tx))
        throw new Error("build estimateGasTransaction end up with invalid RawL2Transaction type return!");
    return rawL2Tx;
}
exports.buildEstimateGasTransaction = buildEstimateGasTransaction;
// one special type transaction: contract deployment.
// to address must be zero address and must be a send transaction
// we can't convert address for contract deployment since:
//  (1. it doesn't have a function signature in eth_tx's input data
//  (2. we support multiple contract ABIs
// thus it is impossible to identified a deploy transaction's abiItem and do the address converting
// instead, we ask developer to explicitly convert the address while we recorded some info to build address mapping if needed.
async function buildDeployProcess(deployAddressMapping, deploymentRecords, abi, godwoker, tx, signingMethod, signingMessageType_) {
    const process = {
        type: ProcessTransactionType.send,
        signingMethod: signingMethod,
        signingMessageType: signingMessageType_,
    };
    if ((0, util_1.formalizeEthToAddress)(tx.to) !== constant_1.DEFAULT_EMPTY_ETH_ADDRESS) {
        throw new Error(`deployTransaction must be a zero to address transaction`);
    }
    if (!tx.from) {
        throw new Error("tx.from can not be missing in sendTransaction!");
    }
    if (!process.signingMethod) {
        throw new Error("process.signingMethod can not be missing in deployTransaction!");
    }
    const result = (0, util_1.splitByteCodeAndConstructorArgs)(tx.data, deploymentRecords);
    if (result == null) {
        // let's build a standard send transaction
        // since we can't find matched deploymentRecords
        return buildSendTransaction(abi, godwoker, tx, signingMethod, signingMessageType_);
    }
    const t = (0, util_1.normalizeEthTransaction)({
        from: tx.from,
        to: tx.to,
        value: tx.value,
        gas: tx.gas,
        gasPrice: tx.gasPrice,
        data: tx.data,
    });
    const rawL2Tx = await godwoker.assembleRawL2Transaction(t);
    const signingMessageType = process.signingMessageType || types_1.SigningMessageType.withPrefix;
    // generate message to sign
    const senderScriptHash = godwoker.computeScriptHashByEoaEthAddress(t.from);
    const receiverScriptHash = await godwoker.getScriptHashByAccountId(parseInt(rawL2Tx.to_id, 16));
    const message = godwoker.generateTransactionMessageToSign(rawL2Tx, senderScriptHash, receiverScriptHash, signingMessageType === types_1.SigningMessageType.withPrefix);
    const _signature = await process.signingMethod(message);
    const signature = godwoker.packSignature(_signature);
    const l2Tx = { raw: rawL2Tx, signature: signature };
    const abiItem = deploymentRecords[result.signature];
    const _abiItem = lodash_1.default.cloneDeep(abiItem); // do not change the original abi object
    let serializedAbiItem = (0, abi_1.serializeAbiItem)(_abiItem);
    const polyL2Tx = (0, util_1.buildL2TransactionWithAddressMapping)(l2Tx, deployAddressMapping, serializedAbiItem);
    return godwoker.serializeL2TransactionWithAddressMapping(polyL2Tx);
}
exports.buildDeployProcess = buildDeployProcess;
async function buildProcess(abi, godwoker, tx, process) {
    if (!tx.from && process.type === ProcessTransactionType.send) {
        throw new Error("tx.from can not be missing in sendTransaction!");
    }
    if (!process.signingMethod && process.type === ProcessTransactionType.send) {
        throw new Error("process.signingMethod can not be missing in sendTransaction!");
    }
    if (process.type === ProcessTransactionType.estimateGas &&
        !process.executeEstimateGasMethod) {
        throw new Error("executeEstimateGasMethod can not be missing in estimateGas!");
    }
    tx.from = tx.from || godwoker.default_from_address;
    let addressMappingItemVec = [];
    function setAddressMappingItemVec(_addressMappingItemVec) {
        addressMappingItemVec = _addressMappingItemVec;
    }
    let dataWithShortAddress;
    dataWithShortAddress = await abi.refactor_data_with_short_address(tx.data, godwoker.getShortAddressByAllTypeEthAddress.bind(godwoker), setAddressMappingItemVec);
    const t = (0, util_1.normalizeEthTransaction)({
        from: tx.from,
        to: tx.to,
        value: tx.value,
        gas: tx.gas,
        gasPrice: tx.gasPrice,
        data: dataWithShortAddress,
    });
    const rawL2Tx = await godwoker.assembleRawL2Transaction(t);
    switch (process.type) {
        case ProcessTransactionType.send: {
            const signingMessageType = process.signingMessageType || types_1.SigningMessageType.withPrefix;
            // generate message to sign
            const senderScriptHash = godwoker.computeScriptHashByEoaEthAddress(t.from);
            const receiverScriptHash = await godwoker.getScriptHashByAccountId(parseInt(rawL2Tx.to_id, 16));
            const message = godwoker.generateTransactionMessageToSign(rawL2Tx, senderScriptHash, receiverScriptHash, signingMessageType === types_1.SigningMessageType.withPrefix);
            const _signature = await process.signingMethod(message);
            const signature = godwoker.packSignature(_signature);
            const l2Tx = { raw: rawL2Tx, signature: signature };
            let serializedAbiItem = buildSerializeAddressMappingAbiItem(abi, dataWithShortAddress);
            const polyL2Tx = (0, util_1.buildL2TransactionWithAddressMapping)(l2Tx, addressMappingItemVec, serializedAbiItem);
            return godwoker.serializeL2TransactionWithAddressMapping(polyL2Tx);
        }
        case ProcessTransactionType.call: {
            let serializedAbiItem = buildSerializeAddressMappingAbiItem(abi, dataWithShortAddress);
            const polyRawL2Tx = (0, util_1.buildRawL2TransactionWithAddressMapping)(rawL2Tx, addressMappingItemVec, serializedAbiItem);
            const run_result = await godwoker.poly_executeRawL2Transaction(polyRawL2Tx);
            const abi_item = abi.get_interested_abi_item_by_encoded_data(tx.data);
            if (!abi_item)
                return run_result.return_data;
            return await abi.refactor_return_value_with_short_address(run_result.return_data, abi_item, godwoker.getEthAddressByAllTypeShortAddress.bind(godwoker));
        }
        case ProcessTransactionType.estimateGas: {
            return rawL2Tx;
        }
        default:
            throw new Error("unknown process type!");
    }
}
exports.buildProcess = buildProcess;
function buildSerializeAddressMappingAbiItem(abi, data) {
    const abiItem = abi.get_interested_abi_item_by_encoded_data(data);
    if (!abiItem)
        return constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR;
    const abiInputs = abi.filter_interested_inputs(abiItem);
    if (abiInputs.length === 0)
        return constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR; // we only want abiItem with interested inputs not outputs
    const _abiItem = lodash_1.default.cloneDeep(abiItem); // do not change the original abi object
    return (0, abi_1.serializeAbiItem)(_abiItem);
}
exports.buildSerializeAddressMappingAbiItem = buildSerializeAddressMappingAbiItem;
function isRawL2Transaction(value) {
    return (value.from_id != undefined &&
        value.to_id != undefined &&
        value.nonce != undefined &&
        value.args != undefined);
}
//# sourceMappingURL=process.js.map