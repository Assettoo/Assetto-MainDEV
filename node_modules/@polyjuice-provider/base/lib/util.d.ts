import { Script, Hash, HexNumber, HexString } from "@ckb-lumos/base";
import { GodwokenUtils, RawL2Transaction, L2Transaction, RunResult, TransactionReceipt as GwTransactionReceipt } from "@polyjuice-provider/godwoken";
import { AddressMapping, RawL2TransactionWithAddressMapping, L2TransactionWithAddressMapping, AddressMappingItem } from "@polyjuice-provider/godwoken/lib/addressTypes";
import { AbiItems, ShortAddress, SigningMessageType } from "./types";
import { AbiItem } from "web3-utils";
declare global {
    interface Window {
        fetch: any;
    }
}
export interface EthTransactionReceipt {
    transactionHash: Hash;
    blockHash: Hash;
    blockNumber: HexNumber;
    transactionIndex: HexNumber;
    gasUsed: HexNumber;
    cumulativeGasUsed: HexNumber;
    logsBloom: HexString;
    logs: EthLogItem[];
    contractAddress: HexString;
    status: EthTransactionStatus;
}
export interface EthLogItem {
    address: HexString;
    blockHash: Hash;
    blockNumber: HexNumber;
    transactionIndex: HexNumber;
    transactionHash: Hash;
    data: HexString;
    logIndex: HexNumber;
    topics: HexString[];
    removed: boolean;
}
export declare enum EthTransactionStatus {
    success = "0x1",
    failure = "0x0"
}
export declare type EthAddress = HexString;
export declare type EthTransaction = {
    from: HexString;
    to: HexString;
    gas?: HexNumber;
    gasPrice?: HexNumber;
    value: HexNumber;
    data: HexString;
    nonce?: HexNumber;
};
export declare type InformalEthTransaction = {
    from?: HexString;
    to?: HexString;
    gas?: HexNumber | bigint | number;
    gasLimit?: HexNumber | bigint | number;
    gasPrice?: HexNumber | bigint | number;
    value?: HexNumber | bigint | number;
    data?: HexString;
    nonce?: HexNumber | bigint | number;
};
export declare type L2TransactionArgs = {
    to_id: number;
    value: bigint;
    data: HexString;
};
export declare type GodwokerOption = {
    godwoken?: {
        rollup_type_hash?: Hash;
        eth_account_lock?: Omit<Script, "args">;
    };
    polyjuice?: {
        creator_id?: HexNumber;
        default_from_address?: HexString;
    };
    queryEthAddressByShortAddress?: (short_address: string) => string;
    saveEthAddressShortAddressMapping?: (eth_address: string, short_address: string) => void;
    request_option?: object;
};
export declare type RequestRpcResult = {
    err: any;
    data?: string;
};
export declare enum RequireResult {
    canBeEmpty = 0,
    canNotBeEmpty = 1
}
export declare enum GetTxVerbose {
    TxWithStatus = 0,
    OnlyStatus = 1
}
export declare enum L2TransactionStatus {
    Pending = 0,
    Committed = 1
}
export interface L2TransactionView {
    inner: L2Transaction;
    tx_hash: HexString;
}
export interface L2TransactionWithStatus {
    transaction: L2TransactionView | null;
    status: L2TransactionStatus;
}
export declare function formalizeEthToAddress(to_address: string | undefined | null): string;
export declare function verifyHttpUrl(_url: string): boolean;
export declare function isHexString(value: any, length?: number): boolean;
export declare function normalizeHexValue(value: HexNumber | bigint | number): HexString;
export declare function normalizeEthTransaction(tx: InformalEthTransaction): {
    from: string;
    to: string;
    gas: string;
    gasPrice: string;
    value: string;
    data: string;
};
export declare function serializeAddressMapping(addressMapping: AddressMapping): HexString;
export declare function deserializeAddressMapping(value: HexString): AddressMapping;
export declare function serializeRawL2TransactionWithAddressMapping(rawL2TransactionWithAddressMapping: RawL2TransactionWithAddressMapping): HexString;
export declare function deserializeRawL2TransactionWithAddressMapping(value: HexString): RawL2TransactionWithAddressMapping;
export declare function serializeL2TransactionWithAddressMapping(l2TransactionWithAddressMapping: L2TransactionWithAddressMapping): HexString;
export declare function deserializeL2TransactionWithAddressMapping(value: HexString): L2TransactionWithAddressMapping;
export declare function buildL2TransactionWithAddressMapping(tx: L2Transaction, addressMappingItemVec: AddressMappingItem[], abiItem?: HexString): L2TransactionWithAddressMapping;
export declare function buildRawL2TransactionWithAddressMapping(tx: RawL2Transaction, addressMappingItemVec: AddressMappingItem[], abiItem?: HexString): RawL2TransactionWithAddressMapping;
export declare function serializeL2Transaction(tx: L2Transaction): HexString;
export declare function serializeRawL2Transaction(tx: RawL2Transaction): HexString;
export declare function decodeArgs(_args: HexString): {
    header: string;
    type: string;
    gas_limit: string;
    gas_price: string;
    value: string;
    data_length: string;
    data: string;
};
export declare function encodeArgs(_tx: EthTransaction): string;
export declare function encodeSudtTransferArgs(toAddress: HexString, amount: bigint, fee: bigint): string;
export declare function ethToCkb(value: HexString, decimal?: number): bigint;
export declare function ckbToEth(value: HexString, decimal?: number): bigint;
export declare class Godwoker {
    eth_account_lock: Omit<Script, "args"> | undefined;
    rollup_type_hash: string | undefined;
    creator_id: HexNumber | undefined;
    default_from_address: HexString | undefined;
    client: any;
    godwokenUtils: GodwokenUtils;
    queryEthAddressByShortAddress: ((short_address: string) => string) | undefined;
    saveEthAddressShortAddressMapping: ((eth_address: string, short_address: string) => void) | undefined;
    constructor(host: string, option?: GodwokerOption);
    init(): Promise<void>;
    initSync(): Promise<void>;
    packSignature(_signature: HexString): HexString;
    jsonRPC(method: string, params: any[], _errMsgWhenNoResult?: string | null, requireResult?: RequireResult): Promise<any>;
    computeScriptHashByEoaEthAddress(eth_address: string): HexString;
    getScriptByScriptHash(_script_hash: string): Promise<Script>;
    getScriptHashByAccountId(account_id: number): Promise<HexString>;
    getAccountIdByScriptHash(script_hash: string): Promise<HexNumber>;
    getAccountIdByEoaEthAddress(eth_address: string): Promise<HexNumber>;
    getScriptHashByShortAddress(_address: string, requireResult?: RequireResult): Promise<HexString>;
    computeShortAddressByEoaEthAddress(_address: string): HexString;
    getShortAddressByAllTypeEthAddress(_address: string): Promise<ShortAddress>;
    getEthAddressByAllTypeShortAddress(_short_address: HexString): Promise<HexString>;
    isShortAddressOnChain(short_address: HexString, scriptHashCallback?: (script_hash: HexString) => void): Promise<boolean>;
    checkEthAddressIsEoa(eth_address: string, _target_short_address: string): boolean;
    defaultQueryEthAddressByShortAddress(_short_address: string): Promise<HexString>;
    getNonce(account_id: number): Promise<HexNumber>;
    assembleRawL2Transaction(eth_tx: EthTransaction): Promise<RawL2Transaction>;
    generateTransactionMessageToSign(tx: RawL2Transaction, sender_script_hash: string, receiver_script_hash: string, is_add_prefix_in_signing_message?: boolean): string;
    generateMessageFromRawL2Transaction(rawL2Tx: RawL2Transaction, msg_type?: SigningMessageType): Promise<string>;
    generateMessageFromEthTransaction(tx: EthTransaction, msg_type?: SigningMessageType): Promise<string>;
    serializeL2Transaction(tx: L2Transaction): HexString;
    serializeRawL2Transaction(tx: RawL2Transaction): HexString;
    serializeL2TransactionWithAddressMapping(tx: L2TransactionWithAddressMapping): HexString;
    serializeRawL2TransactionWithAddressMapping(tx: RawL2TransactionWithAddressMapping): HexString;
    gw_executeL2Transaction(raw_tx: RawL2Transaction, signature: HexString): Promise<RunResult>;
    gw_executeRawL2Transaction(raw_tx: RawL2Transaction): Promise<RunResult>;
    poly_executeRawL2Transaction(raw_tx: RawL2TransactionWithAddressMapping): Promise<RunResult>;
    gw_submitL2Transaction(raw_tx: RawL2Transaction, signature: HexString): Promise<Hash>;
    gw_submitSerializedL2Transaction(serialize_tx: HexString): Promise<Hash>;
    poly_submitL2Transaction(l2_tx: L2TransactionWithAddressMapping): Promise<Hash>;
    poly_submitSerializedL2Transaction(serialize_tx: HexString): Promise<Hash>;
    gw_getTransactionReceipt(tx_hash: Hash): Promise<GwTransactionReceipt | null>;
    getRollupTypeHash(): Promise<HexString>;
    getEthAccountLockHash(): Promise<HexString>;
    getContractValidatorHash(): Promise<HexString>;
    getPolyjuiceCreatorAccountId(): Promise<HexNumber>;
    getPolyjuiceDefaultFromAddress(): Promise<HexString>;
    eth_getTransactionReceipt(tx_hash: Hash): Promise<EthTransactionReceipt | null>;
    gw_getTransaction(tx_hash: Hash, verbose?: GetTxVerbose): Promise<any>;
    waitForTransactionReceipt(tx_hash: Hash, timeout_ms?: number, loop_interval_ms?: number, show_log?: boolean): Promise<void>;
    asyncSleep(ms?: number): Promise<unknown>;
    allTypeEthAddressToScriptHash(_address: HexString): Promise<HexNumber>;
    allTypeEthAddressToAccountId(_address: HexString): Promise<HexNumber>;
}
export declare type DeploymentSignature = HexString;
export interface DeploymentRecords {
    [signature: string]: AbiItem;
}
export declare function calculateByteCodeSignature(bytecode: string): string;
export declare function calculateDeploymentSignature(bytecode: string): DeploymentSignature;
export declare function restoreDeploymentSignature(signature: DeploymentSignature): {
    length: number;
    byteCodeId: string;
    byteCodeSignature: string;
};
export declare function splitByteCodeAndConstructorArgs(inputData: HexString, deploymentRecords: DeploymentRecords): {
    bytecode: string;
    args: string;
    signature: string;
} | undefined;
export declare function checkMatchByteCode(inputData_: HexString, deploymentSignature: DeploymentSignature): boolean;
export interface ConvertConstructorArgsResult {
    newArgs: any[];
    isInterested: boolean;
    addressMapping: AddressMappingItem[];
    deploymentRecords: DeploymentRecords;
}
export declare function convertContractConstructorArgs(args: any[], abiItems: AbiItems, bytecode: string, calculate_short_address: (ethAddress: HexString) => Promise<ShortAddress>): Promise<ConvertConstructorArgsResult>;
export declare function validateEthAddress(value: any): void;
export declare function validateEthAddressArray(value: any): void;
export declare function validateBytecode(value: any): void;
export declare function UInt8ToLeBytes(num: number): HexString;
export declare function UInt32ToLeBytes(num: number): HexString;
export declare function UInt64ToLeBytes(num: bigint): HexString;
export declare function UInt128ToLeBytes(u128: bigint): HexString;
export declare function LeBytesToUInt8(hex: HexString): number;
export declare function LeBytesToUInt32(hex: HexString): number;
export declare function LeBytesToUInt64(hex: HexString): bigint;
export declare function LeBytesToUInt128(hex: HexString): bigint;
